<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0ing&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-05T03:13:00.193Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zer0ing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈SPI机制</title>
    <link href="http://yoursite.com/2019/09/04/%E6%B5%85%E8%B0%88SPI%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/04/浅谈SPI机制/</id>
    <published>2019-09-04T07:13:34.000Z</published>
    <updated>2019-11-05T03:13:00.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SPI的概念"><a href="#SPI的概念" class="headerlink" title="SPI的概念"></a>SPI的概念</h3><p>面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。</p><p>SPI 全称为<code>Service Provider Interface</code>，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p><h4 id="SPI对比API"><a href="#SPI对比API" class="headerlink" title="SPI对比API"></a>SPI对比API</h4><img src="/2019/09/04/浅谈SPI机制/API对比SPI.png"><p><strong>API</strong>:</p><ol><li>概念上更接近实现方</li><li>组织上位于实现方所在的包中</li><li>实现和接口在一个包中</li></ol><p><strong>SPI</strong>:</p><ol><li>概念上更依赖调用方</li><li>组织上位于调用方所在的包中</li><li>实现位于独立的包中（也可认为在提供方中）</li></ol><h3 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h3><p>在JDK6里面引进的一个新的特性<code>ServiceLoader</code>，它主要是用来装载一系列的service provider。而且<code>ServiceLoader</code>可以通过service provider的配置文件来装载指定的service provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的<code>META-INF/services/</code>目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包<code>META-INF/services/</code>里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p><h4 id="Java-SPI-示例"><a href="#Java-SPI-示例" class="headerlink" title="Java SPI 示例"></a>Java SPI 示例</h4><p>前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Robot &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OptimusPrime implements Robot &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, I am Optimus Prime.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bumblebee implements Robot &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, I am Bumblebee.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来 <code>META-INF/services</code> 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spi.OptimusPrime</span><br><span class="line">org.apache.spi.Bumblebee</span><br></pre></td></tr></table></figure><p>做好所需的准备工作，接下来编写代码进行测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class JavaSPITest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sayHello() throws Exception &#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        System.out.println(&quot;Java SPI&quot;);</span><br><span class="line">        serviceLoader.forEach(Robot::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看一下测试结果，从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。</p><img src="/2019/09/04/浅谈SPI机制/JavaSPI测试结果.jpg"><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p><code>DriverManager</code> 是JDBC里管理和注册不同数据库driver的工具类。针对一个数据库 可能会存在着不同的数据库驱动实现，我们在使用特定的驱动实现时不希望修改现有的代码才能达到目的，而希望通过一个简单的配置就可以达到效果。比如，我们现在有一个数据库的驱动A，我们希望在程序里使用它而不修改代码。一种理想的选择就是我们将驱动A的信息加入到一个配置文件中，程序通过读取配置文件信息将A加载进来。而以后如果我们希望改用另外一个驱动B的时候，我们只需要将配置文件里的信息修改成驱动B即可。</p><p>我们在运用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>加载mysql驱动后，就会执行其中的静态代码把driver注册到<code>DriverManager</code>中，以便后续的使用。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，不同的驱动实现了相同的接口<code>java.sql.Driver</code>，然后通过<code>registerDriver</code>把当前driver加载到<code>DriverManager</code>中<br>这就体现了使用方提供规则，提供方根据规则把自己加载到使用方中的SPI思想。查看<code>DriverManager</code>的源码，可以看到其内部的静态代码块中有一个<code>loadInitialDrivers</code>方法，在注释中我们看到用到了上文提到的SPI工具类<code>ServiceLoader</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Load the initial JDBC drivers by checking the System property</span><br><span class="line">* jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism</span><br><span class="line">*/</span><br><span class="line">static &#123;</span><br><span class="line">loadInitialDrivers();</span><br><span class="line">println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进方法，看到方法里有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">Iterator&lt;Driver&gt; drivers = loadedDrivers.iterator();</span><br><span class="line">println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + loadedDrivers);</span><br></pre></td></tr></table></figure><p>可见，<code>DriverManager</code>初始化时也运用了SPI机制，使用<code>ServiceLoader</code>把写到配置文件里的Driver都加载了进来。我们打开mysql-connector-java的jar包，果然在<code>META-INF/services</code>下发现了上文中提到的接口路径，打开里面的内容，可以看到是<code>com.mysql.jdbc.Driver</code>。</p><h3 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h3><p>SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了<code>ExtensionLoader</code> 类中，通过 <code>ExtensionLoader</code>，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 <code>META-INF/dubbo</code>路径下，配置内容如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br></pre></td></tr></table></figure><p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注<code>@SPI</code>注解。下面来演示 Dubbo SPI 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DubboSPITest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sayHello() throws Exception &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        Robot optimusPrime = extensionLoader.getExtension(&quot;optimusPrime&quot;);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        Robot bumblebee = extensionLoader.getExtension(&quot;bumblebee&quot;);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章简单分别介绍了SPI机制的概念，以及Java SPI ，DriverManager SPI 与 Dubbo SPI 用法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/28909673" target="_blank" rel="noopener">Java SPI思想梳理</a></li><li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">Dubbo SPI</a></li><li><a href="https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html" target="_blank" rel="noopener">设计原则：小议 SPI 和 API</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SPI的概念&quot;&gt;&lt;a href=&quot;#SPI的概念&quot; class=&quot;headerlink&quot; title=&quot;SPI的概念&quot;&gt;&lt;/a&gt;SPI的概念&lt;/h3&gt;&lt;p&gt;面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现
      
    
    </summary>
    
    
  </entry>
  
</feed>
