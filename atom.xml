<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0ing&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-04T08:52:41.334Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zer0ing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>佛语几则</title>
    <link href="http://yoursite.com/2019/05/04/%E4%BD%9B%E8%AF%AD%E5%87%A0%E5%88%99/"/>
    <id>http://yoursite.com/2019/05/04/佛语几则/</id>
    <published>2019-05-04T08:36:24.000Z</published>
    <updated>2019-05-04T08:52:41.334Z</updated>
    
    <content type="html"><![CDATA[<p>譬如有人，一专为忆，一专为忘，如是二人，若逢不逢，遇见不见，二人相忆，二忆念深，如是乃至从生至生，同于形影，不相乖异。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;譬如有人，一专为忆，一专为忘，如是二人，若逢不逢，遇见不见，二人相忆，二忆念深，如是乃至从生至生，同于形影，不相乖异。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Netty入门与实战》学习笔记</title>
    <link href="http://yoursite.com/2019/04/12/%E3%80%8ANetty%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/12/《Netty入门与实战》学习笔记/</id>
    <published>2019-04-12T06:15:32.000Z</published>
    <updated>2019-04-28T03:30:45.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="仿微信-IM-系统简介"><a href="#仿微信-IM-系统简介" class="headerlink" title="仿微信 IM 系统简介"></a>仿微信 IM 系统简介</h3><h5 id="单聊流程及指令"><a href="#单聊流程及指令" class="headerlink" title="单聊流程及指令"></a>单聊流程及指令</h5><h5 id="多聊流程及指令"><a href="#多聊流程及指令" class="headerlink" title="多聊流程及指令"></a>多聊流程及指令</h5><h5 id="客户端基于Netty的程序逻辑结构"><a href="#客户端基于Netty的程序逻辑结构" class="headerlink" title="客户端基于Netty的程序逻辑结构"></a>客户端基于Netty的程序逻辑结构</h5><h5 id="服务端基于Netty的程序逻辑结构"><a href="#服务端基于Netty的程序逻辑结构" class="headerlink" title="服务端基于Netty的程序逻辑结构"></a>服务端基于Netty的程序逻辑结构</h5><h3 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h3><h5 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h5><p>阻塞型，以字节流为单位。</p><h5 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h5><p>//TODO</p><p><strong>为什么不建议使用NIO</strong>：</p><ul><li>JDK 的 NIO 编程需要了解很多的概念，编程复杂。</li><li>对 NIO 编程来说，一个比较合适的线程模型能充分发挥它的优势，而 JDK 没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现</li><li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li><li>项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高</li></ul><h3 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h3><h5 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h5><p><strong>代码</strong></p><h5 id="自动绑定递增端口"><a href="#自动绑定递增端口" class="headerlink" title="自动绑定递增端口"></a>自动绑定递增端口</h5><h5 id="其他函数介绍"><a href="#其他函数介绍" class="headerlink" title="其他函数介绍"></a>其他函数介绍</h5><h3 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h3><h5 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h5><p><strong>代码</strong></p><h5 id="失败重连"><a href="#失败重连" class="headerlink" title="失败重连"></a>失败重连</h5><h5 id="其他函数介绍-1"><a href="#其他函数介绍-1" class="headerlink" title="其他函数介绍"></a>其他函数介绍</h5><h3 id="实战：客户端与服务端双向通信"><a href="#实战：客户端与服务端双向通信" class="headerlink" title="实战：客户端与服务端双向通信"></a>实战：客户端与服务端双向通信</h3><p><strong>代码</strong></p><h3 id="数据传输载体ByteBuf介绍"><a href="#数据传输载体ByteBuf介绍" class="headerlink" title="数据传输载体ByteBuf介绍"></a>数据传输载体ByteBuf介绍</h3><h5 id="ByteBuf结构"><a href="#ByteBuf结构" class="headerlink" title="ByteBuf结构"></a>ByteBuf结构</h5><p><img src="en-resource://database/2553:1" alt="fc529c7b190961a6275965bdadec3a6f.jpeg"></p><p>Bytebuf是一个字节容器。本质是引用一段内存，可以是堆内或者堆外，然后使用引用计数来控制这段内存是否需要被释放，使用读写指针控制对ByteBuf的读写。</p><h5 id="ByteBuf-API"><a href="#ByteBuf-API" class="headerlink" title="ByteBuf API"></a>ByteBuf API</h5><ul><li>capacity()</li><li>maxCapacity()</li><li>readableBytes()</li><li>isReadable()</li><li>writableBytes()</li><li>isWritable()</li><li>maxWritableBytes()</li></ul><hr><ul><li>readerIndex() 与 readerIndex(int)</li><li>writeIndex() 与 writeIndex(int)</li><li>markReaderIndex() 与 resetReaderIndex()</li><li>markWriterIndex() 与 resetWriterIndex()</li></ul><hr><ul><li><strong>writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)</strong>  writeBytes() 表示把字节数组 src 里面的数据全部写到 ByteBuf，而 readBytes() 指的是把 ByteBuf 里面的数据全部读取到 dst</li><li>writeByte(byte b) 与 buffer.readByte()</li><li>getBytes、getByte() 与 setBytes()、setByte()  get/set不会改变读写指针，read/write会改变读写指针。</li><li><strong>release() 与 retain()</strong><br>Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。</li></ul><p><strong>在一个函数体里面，只要增加了引用计数（包括 ByteBuf 的创建和手动调用 retain() 方法），就必须调用 release() 方法</strong></p><ul><li><strong>slice()、duplicate()、copy()</strong></li></ul><p>slice() 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 readableBytes()<br>duplicate() 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息<br>slice() 方法与 duplicate() 方法的相同点是：<strong>底层内存以及引用计数与原始的 ByteBuf 共享</strong>，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和<strong>不同的读写指针</strong><br>slice() 方法与 duplicate() 不同点就是：slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享<br>slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此，往 copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf<br><strong>slice() 和 duplicate() 不会改变 ByteBuf 的引用计数</strong>，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存<br><strong>这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关</strong>，相互之间不受影响</p><h3 id="客户端与服务端通信协议编解码"><a href="#客户端与服务端通信协议编解码" class="headerlink" title="客户端与服务端通信协议编解码"></a>客户端与服务端通信协议编解码</h3><h5 id="通信协议的设计"><a href="#通信协议的设计" class="headerlink" title="通信协议的设计"></a>通信协议的设计</h5><p>// 图片</p><h5 id="通信协议的实现"><a href="#通信协议的实现" class="headerlink" title="通信协议的实现"></a>通信协议的实现</h5><h5 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h5><h5 id="编码：封装成二进制"><a href="#编码：封装成二进制" class="headerlink" title="编码：封装成二进制"></a>编码：封装成二进制</h5><ol><li>创建ByteBuf对象</li><li>序列化Java对象</li><li>实际编码过程<h5 id="解码：解析Java对象"><a href="#解码：解析Java对象" class="headerlink" title="解码：解析Java对象"></a>解码：解析Java对象</h5></li></ol><h3 id="实战：Netty实现客户端登录"><a href="#实战：Netty实现客户端登录" class="headerlink" title="实战：Netty实现客户端登录"></a>实战：Netty实现客户端登录</h3><h5 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h5><p>//图片</p><h5 id="逻辑处理器"><a href="#逻辑处理器" class="headerlink" title="逻辑处理器"></a>逻辑处理器</h5><h5 id="客户端-服务端发送登录请求"><a href="#客户端-服务端发送登录请求" class="headerlink" title="客户端/服务端发送登录请求"></a>客户端/服务端发送登录请求</h5><p>连接好服务端后，Netty会回调到ClientHandler的channelActive()方法。</p><p>我们向服务端引导类 ServerBootstrap 中添加了逻辑处理器 ServerHandler 之后，Netty 在收到数据之后，会回调 channelRead() 方法。</p><h3 id="实战：实现客户端与服务端收发消息"><a href="#实战：实现客户端与服务端收发消息" class="headerlink" title="实战：实现客户端与服务端收发消息"></a>实战：实现客户端与服务端收发消息</h3><h3 id="Pipeline与channelHandler"><a href="#Pipeline与channelHandler" class="headerlink" title="Pipeline与channelHandler"></a>Pipeline与channelHandler</h3><h5 id="pipeline与channelHandler的构成"><a href="#pipeline与channelHandler的构成" class="headerlink" title="pipeline与channelHandler的构成"></a>pipeline与channelHandler的构成</h5><p>在Netty中，一条连接对应着一个Channel，这条Channel的所有逻辑都在一个ChannelPipeline的对象里面，ChannelPipeline是一个双向链表结构，和Channel一一对应。ChannelPipeline里面每个节点都是一个ChannelHandlerContext对象，这个对象能拿到和Channel相关的所有上下文信息，每个对象中包着一个重要的对象，即逻辑处理器ChannelHandler。</p><h5 id="channelHandler的分类"><a href="#channelHandler的分类" class="headerlink" title="channelHandler的分类"></a>channelHandler的分类</h5><p>//图片</p><p>第一个子接口是 ChannelInboundHandler，是处理读数据的逻辑，它的一个最重要的方法就是 channelRead()。</p><p>第二个子接口ChannelOutBoundHandler，是处理写数据的逻辑，它是定义我们一端在组装完响应之后，把数据写到对端的逻辑，比如，我们封装好一个 response 对象，接下来我们有可能对这个 response 做一些其他的特殊逻辑，然后，再编码成 ByteBuf，最终写到对端，它里面最核心的一个方法就是 write()。</p><p>这两个子接口分别有对应的默认实现，ChannelInboundHandlerAdapter，和 ChanneloutBoundHandlerAdapter，它们分别实现了两大接口的所有功能，默认情况下会把读写事件传播到下一个 handler。</p><h5 id="ChannelOutboundHandler-的事件传播"><a href="#ChannelOutboundHandler-的事件传播" class="headerlink" title="ChannelOutboundHandler 的事件传播"></a>ChannelOutboundHandler 的事件传播</h5><p>//图片</p><h3 id="实战：构建客户端与服务端-pipeline"><a href="#实战：构建客户端与服务端-pipeline" class="headerlink" title="实战：构建客户端与服务端 pipeline"></a>实战：构建客户端与服务端 pipeline</h3><h3 id="粘包半包现象"><a href="#粘包半包现象" class="headerlink" title="粘包半包现象"></a>粘包半包现象</h3><h5 id="Netty自带的拆包器"><a href="#Netty自带的拆包器" class="headerlink" title="Netty自带的拆包器"></a>Netty自带的拆包器</h5><ol><li><p>固定长度的拆包器 FixedLengthFrameDecoder<br>如果你的应用层协议非常简单，每个数据包的长度都是固定的，比如 100，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 100 的数据包 (ByteBuf) 传递到下一个 channelHandler。</p></li><li><p>行拆包器 LineBasedFrameDecoder<br>从字面意思来看，发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过 LineBasedFrameDecoder 将粘过的 ByteBuf 拆分成一个个完整的应用层数据包。</p></li><li><p>分隔符拆包器 DelimiterBasedFrameDecoder<br>DelimiterBasedFrameDecoder 是行拆包器的通用版本，只不过我们可以自定义分隔符。</p></li><li><p>基于长度域拆包器 LengthFieldBasedFrameDecoder<br>最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</p></li></ol><h5 id="服务端和客户端的-pipeline-结构"><a href="#服务端和客户端的-pipeline-结构" class="headerlink" title="服务端和客户端的 pipeline 结构"></a>服务端和客户端的 pipeline 结构</h5><h3 id="channelHandler-的生命周期"><a href="#channelHandler-的生命周期" class="headerlink" title="channelHandler 的生命周期"></a>channelHandler 的生命周期</h3><p>服务端和客户端启动后，ChannelHandler 回调方法的执行顺序为:handlerAdded() -&gt; channelRegistered() -&gt; channelActive() -&gt; channelRead() -&gt; channelReadComplete()</p><p>下面，我们来逐个解释一下每个回调方法的含义:</p><ol><li>handlerAdded() ：指的是当检测到新连接之后，调用 ch.pipeline().addLast(new LifeCyCleTestHandler()); 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。</li><li>channelRegistered()：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，类似我们在Netty 是什么？这小节中 BIO 编程中，accept 到新的连接，然后创建一个线程来处理这条连接的读写，只不过 Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 NioEventLoop,不理解没关系，后面我们还会讲到。</li><li>channelActive()：当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。</li><li>channelRead()：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。</li><li>channelReadComplete()：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。</li></ol><p>客户端关闭后，对于服务端就是channel被关闭，ChannelHandler 回调方法的执行顺序为<br>channelInactive() -&gt; channelUnregistered() -&gt; handlerRemoved()。</p><p>回调方法的执行顺序是新连接建立时候的逆操作，下面我们还是来解释一下每个方法的含义</p><ol><li>channelInactive(): 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了</li><li>channelUnregistered(): 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理</li><li>handlerRemoved()：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</li></ol><h3 id="ChannelHandler-生命周期各回调方法用法举例"><a href="#ChannelHandler-生命周期各回调方法用法举例" class="headerlink" title="ChannelHandler 生命周期各回调方法用法举例"></a>ChannelHandler 生命周期各回调方法用法举例</h3><h5 id="ChannelInitializer-的实现原理"><a href="#ChannelInitializer-的实现原理" class="headerlink" title="ChannelInitializer 的实现原理"></a>ChannelInitializer 的实现原理</h5><blockquote><pre><code>protected abstract void initChannel(C ch) throws Exception;</code></pre></blockquote><pre><code>public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {    // ...    initChannel(ctx);    // ...}public void handlerAdded(ChannelHandlerContext ctx) throws Exception {    // ...    if (ctx.channel().isRegistered()) {        initChannel(ctx);    }    // ...}private boolean initChannel(ChannelHandlerContext ctx) throws Exception {    if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) {        initChannel((C) ctx.channel());        // ...        return true;    }    return false;}</code></pre><ol><li>ChannelInitializer 定义了一个抽象的方法 initChannel()，这个抽象方法由我们自行实现，我们在服务端启动的流程里面的实现逻辑就是往 pipeline 里面塞我们的handler 链.</li><li>handlerAdded() 和 channelRegistered() 方法，都会尝试去调用 initChannel() 方法，initChannel() 使用 putIfAbsent() 来防止 initChannel() 被调用多次</li><li>如果你 debug 了 ChannelInitializer 的上述两个方法，你会发现，在 handlerAdded() 方法被调用的时候，channel 其实已经和某个线程绑定上了，所以，就我们的应用程序来说，这里的 channelRegistered() 其实是多余的，那为什么这里还要尝试调用一次呢？我猜测应该是担心我们自己写了个类继承自 ChannelInitializer，然后覆盖掉了 handlerAdded() 方法，这样即使覆盖掉，在 channelRegistered() 方法里面还有机会再调一次 initChannel()，把我们自定义的 handler 都添加到 pipeline 中去。</li></ol><h5 id="handlerAdded-和handlerRemoved"><a href="#handlerAdded-和handlerRemoved" class="headerlink" title="handlerAdded()和handlerRemoved()"></a>handlerAdded()和handlerRemoved()</h5><p>用于资源申请和释放</p><h5 id="channelActive-和channelInActive"><a href="#channelActive-和channelInActive" class="headerlink" title="channelActive()和channelInActive()"></a>channelActive()和channelInActive()</h5><ol><li>表明TCP连接的建立和释放，在这两个回调里统计单机的连接数。</li><li>可以在channelActive()方法中实现对客户端连接IP黑白名单的过滤。</li></ol><h5 id="channelRead"><a href="#channelRead" class="headerlink" title="channelRead()"></a>channelRead()</h5><p>每读到一定的数据，都会加到一个容器里，然后判断是否能拆出来一个完整的数据包。</p><h5 id="channelReadComplete"><a href="#channelReadComplete" class="headerlink" title="channelReadComplete()"></a>channelReadComplete()</h5><p>每次向客户端写入数据时，都通过writeAndFlush()的方法写并刷新到底层，这种方法并不高效。可以在之前调用writeAndFlush()的时候调用write方法，然后在此方法中调用ctx.channel().flush()方法，相当于一个批量刷新机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;仿微信-IM-系统简介&quot;&gt;&lt;a href=&quot;#仿微信-IM-系统简介&quot; class=&quot;headerlink&quot; title=&quot;仿微信 IM 系统简介&quot;&gt;&lt;/a&gt;仿微信 IM 系统简介&lt;/h3&gt;&lt;h5 id=&quot;单聊流程及指令&quot;&gt;&lt;a href=&quot;#单聊流程及指令&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《趣谈Linux操作系统》学习笔记</title>
    <link href="http://yoursite.com/2019/04/09/%E3%80%8A%E8%B6%A3%E8%B0%88Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/09/《趣谈Linux操作系统》学习笔记/</id>
    <published>2019-04-09T08:27:50.000Z</published>
    <updated>2019-06-18T14:20:04.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、入门篇"><a href="#一、入门篇" class="headerlink" title="一、入门篇"></a>一、入门篇</h1><h2 id="01-Linux知识测验"><a href="#01-Linux知识测验" class="headerlink" title="01 Linux知识测验"></a>01 Linux知识测验</h2><h2 id="02-Linux学习路径"><a href="#02-Linux学习路径" class="headerlink" title="02 Linux学习路径"></a>02 Linux学习路径</h2><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/Linux学习路径.jpeg"><h1 id="二、核心原理篇：第一部分-Linux综述"><a href="#二、核心原理篇：第一部分-Linux综述" class="headerlink" title="二、核心原理篇：第一部分 Linux综述"></a>二、核心原理篇：第一部分 Linux综述</h1><h2 id="04-快速上手Linux命令"><a href="#04-快速上手Linux命令" class="headerlink" title="04 快速上手Linux命令"></a>04 快速上手Linux命令</h2><h3 id="用户和密码"><a href="#用户和密码" class="headerlink" title="用户和密码"></a>用户和密码</h3><ul><li>passwd 修改密码</li><li>useradd zeroing 添加用户 </li><li>cat /etc/passwd 查看通过命令创建的用户 </li><li>cat /etc/group 查看用户的组信息</li></ul><h3 id="浏览文件"><a href="#浏览文件" class="headerlink" title="浏览文件"></a>浏览文件</h3><blockquote><p>ls -l 使用列表列出文件</p></blockquote><blockquote><p>-rw-r–r– 1 root root 4096 Oct 20 2017 apt</p></blockquote><p>第一个字段：”-“表示普通文件，”d”表示目录；后面9个字符表示权限位，3个一组，每一组rwx表示”读””写””执行”。三组分别表示文件所属的用户权限、文件所属的组权限以及其他用户的权限。</p><p>第二个字段：硬链接数目。</p><p>第三个字段：所属用户。</p><p>第四个字段：所属组。</p><p>第五个字段：文件大小。</p><p>第六个字段：文件修改日期。</p><p>第七个字段：文件名。</p><p>可以通过chown改变所属用户，chgrp改变所属组。</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>Linux两大体系：一个是CentOS体系，一个是Ubuntu体系，前者使用rpm,后者使用deb。</p><ul><li>rpm -i XXX.rpm CentOS安装软件</li><li>dpkg -i XXX.deb Ubuntu安装软件</li><li>rpm -qa 查看安装软件</li><li>dpkg -l 查看安装软件</li><li>rpm -qa| grep jdk | 是管道，用于连接两个程序，前面 rpm -qa 的输出就放进管道，作为grep的输入，grep搜索带有关键字jdk的行并且输出。</li><li>rpm -qa | more和rpm -qa | less 结果分页展示 ，输入q返回命令行</li><li>rpm -e 删除</li><li>dpkg -r 删除</li></ul><p>Linux 也有自己的软件管家，CentOS 下面是 yum，Ubuntu下面是apt-get。</p><ul><li>yum install XXX (centos) </li><li>apt-get install XXX(ubuntu)</li><li>yum erase XXX 卸载</li><li>apt-get purge openjdk-9-jdk 卸载</li></ul><p>CentOS源文件/etc/yum.repos.d/CentOS-Base.repo<br>Ubuntu源文件/etc/apt/sources.list</p><ul><li><p>主执行文件会放在 /usr/bin 或者 /usr/sbin下面，其他库文件放在/var下面，配置文件放在/etc下面。</p></li><li><p>除上述方法外，还有一种简单粗暴的方式，就是将安装好的路径直接下载下来，解压缩成为一个整的路径。利用 <strong>wget + 链接</strong> 的方式。</p></li><li><p>/root 或者 /home/cliu8 下面，有一个.bashrc文件，用于配置环境变量。<br>export JAVA_HOME=/root/jdk-XXX_linux-x64<br>export PATH=$JAVA_HOME/bin:$PATH</p></li></ul><h4 id="VIM使用方式"><a href="#VIM使用方式" class="headerlink" title="VIM使用方式"></a>VIM使用方式</h4><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><ol><li><p>只要文件有x执行权限，都可以到文件所在目录下，通过<strong>./filename</strong>运行程序，当然，如果放在PATH里设置的路径下，就不用./，直接输入文件名即可。</p></li><li><p>Linux运行程序的第二种方式，后台运行。nohup command &gt;out.file 2&gt;&amp;1 &amp;，最后的&amp;表示后台运行。1”表示文件描述符1，表示标准输出，“2”表示文件描述符2,表示标准错误输出，“2&gt;&amp;1”表示标准输入和错误输出合并，合并到out.file。</p></li><li><p>Linux运行程序的第三种方式，以服务的方式运行。</p></li></ol><ul><li><p>systemctl start mysql启动 MySQL，systemctl enable mysql设置开机启动。</p></li><li><p>shutdown -h now 立即关机 reboot 重启</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/Linux命令行.jpg"><h2 id="05-系统调用"><a href="#05-系统调用" class="headerlink" title="05 系统调用"></a>05 系统调用</h2><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/Linux系统调用.jpg"><h1 id="三、核心原理篇：第二部分-系统初始化"><a href="#三、核心原理篇：第二部分-系统初始化" class="headerlink" title="三、核心原理篇：第二部分 系统初始化"></a>三、核心原理篇：第二部分 系统初始化</h1><h2 id="06-x86架构"><a href="#06-x86架构" class="headerlink" title="06 x86架构"></a>06 x86架构</h2><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/X86架构.jpeg"><h2 id="07-从BIOS到bootloader"><a href="#07-从BIOS到bootloader" class="headerlink" title="07 从BIOS到bootloader"></a>07 从BIOS到bootloader</h2><p>x86有两种模式，一种是实模式，只能寻址1M，每个段最多64K；另一种是保护模式，对于32位系统，能够寻址4G。当系统刚刚启动的时候，CPU是处于实模式的，当需要更多内存时，切换到保护模式。</p><p>系统主板有一块ROM，上面固化了一些初始化的程序，即BIOS（基本输入输出系统）。</p><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/1M地址空间.jpeg"><p>x86系统中，将1M空间最上面的0xF0000到0xFFFFF这64K映射给ROM.<br>电脑加电时，会做重置工作，将CS设置为0xFFFF，将IP设置为0x0000,所以第一条指令就会指向0xFFFF0,正是在ROM的范围内。</p><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/grub2.jpeg"><p>BIOS完成后，会找到一般位于第一个扇区的启动盘，占512字节，而且以0xAA55结束。512字节内存在代码，由Linux中的工具Grub2放置。grub2安装boot.img，从硬盘加载到内存中运行(boot.img加载grub2另一镜像core.img),core.img由lzma_decompress.img、diskboot.img和kernel.img（grub kernel，并不是linux kernel）和一系列的模块组成，功能丰富。</p><p>随着加载的程序越来越多，需要从实模式切换到保护模式——lzma_decompress.img调用real_to_prot，切换到保护模式。切换到保护模式需要做很多工作，大部分与内存访问方式有关：</p><ol><li>启用分段。</li><li>启动分页。</li><li>打开其他地址线。</li></ol><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/Linux启动过程.jpeg"><h2 id="08-内核初始化"><a href="#08-内核初始化" class="headerlink" title="08 内核初始化"></a>08 内核初始化</h2><ol><li>创建样板进程, 及各个模块初始化</li><li>创建管理/创建用户态进程的进程</li><li>创建管理/创建内核态进程的进程</li></ol><h3 id="创建样板进程-及各个模块初始化"><a href="#创建样板进程-及各个模块初始化" class="headerlink" title="创建样板进程, 及各个模块初始化"></a>创建样板进程, 及各个模块初始化</h3><ul><li><p>内核的启动从入口函数 start_kernel() 开始,在init/main.c文件中，start_kernel相当于内核的main函数。init_task 是系统创建的第一个进程，称为0号进程。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表中的第一个。</p></li><li><p>初始化中断, <code>trap_init()</code>. 系统调用也是通过发送中断进行, 由 <code>set_system_intr_gate()</code> 完成.</p></li><li>初始化内存管理模块, <code>mm_init()</code></li><li>初始化进程调度模块, <code>sched_init()</code></li><li>初始化基于内存的文件系统 rootfs, <code>vfs_caches_init()</code>  VFS(虚拟文件系统)将各种文件系统抽象成统一接口</li><li>调用 <code>rest_init()</code> 完成其他初始化工作</li></ul><h3 id="创建管理-创建用户态进程的进程——1号进程"><a href="#创建管理-创建用户态进程的进程——1号进程" class="headerlink" title="创建管理/创建用户态进程的进程——1号进程"></a>创建管理/创建用户态进程的进程——1号进程</h3><ul><li><code>rest_init()</code> 通过 <code>kernel_thread(kernel_init,...)</code> 创建 1号进程(工作在用户态).</li><li>权限管理<ul><li>x86 提供 4个 Ring 分层权限</li><li>操作系统利用: Ring0-内核态(访问核心资源); Ring3-用户态(普通程序)</li></ul></li><li>用户态调用系统调用:用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态</li><li>新进程执行 kernel_init 函数, 先运行 ramdisk 的 /init 程序(位于内存中)<ul><li>首先加载 ELF 文件</li><li>设置用于保存用户态寄存器的结构</li><li>返回进入用户态</li><li>/init 加载存储设备的驱动</li></ul></li><li>kernel_init 函数启动存储设备文件系统上的 init</li></ul><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/分层权限机制.jpg"><h3 id="创建管理-创建内核态进程的进程——2号进程"><a href="#创建管理-创建内核态进程的进程——2号进程" class="headerlink" title="创建管理/创建内核态进程的进程——2号进程"></a>创建管理/创建内核态进程的进程——2号进程</h3><ul><li><code>rest_init()</code> 通过 <code>kernel_thread(kthreadd,...)</code> 创建 2号进程(工作在内核态).</li><li><code>kthreadd</code> 负责所有内核态线程的调度和管理</li></ul><h2 id="09-系统调用"><a href="#09-系统调用" class="headerlink" title="09 系统调用"></a>09 系统调用</h2><h3 id="glibc-对系统调用的封装"><a href="#glibc-对系统调用的封装" class="headerlink" title="glibc 对系统调用的封装"></a>glibc 对系统调用的封装</h3><p>在 glibc 的源代码中，有个文件 syscalls.list,里面列着所有glibc的函数对应的系统调用。<br>对于任何一个系统调用，会调用 DO_CALL，这也是一个宏。</p><h3 id="32位系统调用执行过程"><a href="#32位系统调用执行过程" class="headerlink" title="32位系统调用执行过程"></a>32位系统调用执行过程</h3><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/32位系统调用执行.jpg"><p>我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器eax中，然后执行ENTER_KERNEL。</p><p><code># define ENTER_KERNEL int $0x80</code></p><p>int $0x80 就是触发一个软中断，通过它就可以陷入（trap)内核。</p><p>通过 push 和 SAVE_ALL 将当前用户态的寄存器，保存在pt_regs结构中。</p><p>进入内核前，保存所有寄存器，然后调用do_syscall_32_irqs_on。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">struct thread_info *ti = current_thread_info();</span><br><span class="line">unsigned int nr = (unsigned int)regs-&gt;orig_ax;</span><br><span class="line">......</span><br><span class="line">if (likely(nr &lt; IA32_NR_syscalls)) &#123;</span><br><span class="line">regs-&gt;ax = ia32_sys_call_table[nr](</span><br><span class="line">(unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx,</span><br><span class="line">(unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si,</span><br><span class="line">(unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp);</span><br><span class="line">&#125;</span><br><span class="line">syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将系统调用号从 eax 里面取出来，然后根据系统调用号，在系统调用表sys_call_table<br>中找到对应的函数调用，并将寄存器中的参数取出作为函数参数。<br>当系统调用结束之后，在 entry_INT80_32 之后，紧接着调用的是INTERRUPT_RETURN，我们能够找到它的定义，也就iret。</p><p><code>#define INTERRUPT_RETURN                iret</code></p><p>iret 指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等，此时用户态恢复执行。</p><h3 id="64位系统调用执行过程"><a href="#64位系统调用执行过程" class="headerlink" title="64位系统调用执行过程"></a>64位系统调用执行过程</h3><p>和32位系统类似，还是将系统调用名转换为系统调用号，放到寄存器rax。这里是真正的调用，不是采用中断，而是改用syscall指令。并且传递参数的寄存器也变了。syscall指令还使用一种特殊的寄存器，称为特殊模块寄存器（MSR），这种寄存器是CPU为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><h3 id="总结（64位）"><a href="#总结（64位）" class="headerlink" title="总结（64位）"></a>总结（64位）</h3><img src="/2019/04/09/《趣谈Linux操作系统》学习笔记/64位系统调用执行.jpg"><h1 id="四、核心原理篇：第三部分-进程管理"><a href="#四、核心原理篇：第三部分-进程管理" class="headerlink" title="四、核心原理篇：第三部分 进程管理"></a>四、核心原理篇：第三部分 进程管理</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、入门篇&quot;&gt;&lt;a href=&quot;#一、入门篇&quot; class=&quot;headerlink&quot; title=&quot;一、入门篇&quot;&gt;&lt;/a&gt;一、入门篇&lt;/h1&gt;&lt;h2 id=&quot;01-Linux知识测验&quot;&gt;&lt;a href=&quot;#01-Linux知识测验&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>无题190402</title>
    <link href="http://yoursite.com/2019/04/02/%E6%97%A0%E9%A2%98190402/"/>
    <id>http://yoursite.com/2019/04/02/无题190402/</id>
    <published>2019-04-01T16:37:04.000Z</published>
    <updated>2019-04-01T16:51:40.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><strong>我心永恒。</strong> </p></blockquote><img src="/2019/04/02/无题190402/wallhaven-753751.jpg" title="My heart will go on."><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;strong&gt;我心永恒。&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2019/04/02/无题190402/wallhaven-753751.jpg&quot; title=&quot;My heart will go on.&quot;&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>[转载]一个西二旗码农的自白</title>
    <link href="http://yoursite.com/2019/04/01/%E8%BD%AC%E8%BD%BD-%E4%B8%80%E4%B8%AA%E8%A5%BF%E4%BA%8C%E6%97%97%E7%A0%81%E5%86%9C%E7%9A%84%E8%87%AA%E7%99%BD/"/>
    <id>http://yoursite.com/2019/04/01/转载-一个西二旗码农的自白/</id>
    <published>2019-04-01T03:08:05.000Z</published>
    <updated>2019-04-01T11:00:49.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>凡不能毁灭我的，必使我强大。   ——尼采 </p></blockquote><p>朋友在 javaeye 老炮群转发寒门的状元一文时，我正从车水马龙的西二旗地铁站气喘吁吁地挤出来。北京这几天温度还不错，风不大，但没有太阳。我超级不喜欢地铁站门口的那个红绿灯。我扫开一辆摩拜，戴上手套，背好双肩包，骑车去上地三街。店里反馈有个订单系统掉单了，我微信给同事说查一下这个订单，同事回复说：“不可能。”我说人会犯错，机器是不会骗人的，于是看到了这篇文章。</p><p>我想起了王小波，他在《黄金时代》写过这样的句子：“那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”</p><a id="more"></a><h3 id="三次重锤：命运从来都不会手下留情"><a href="#三次重锤：命运从来都不会手下留情" class="headerlink" title="三次重锤：命运从来都不会手下留情"></a>三次重锤：命运从来都不会手下留情</h3><p>看到这个句子是在高三的时候，我怎么也不会想到，一年之后，我 17 岁，刚上大一，就挨了生活的重重一锤：由于出鼻血不止我被送到 304 医院，医生确诊为再生障碍性贫血。这是个很严重的病，我的黄金时代还没有开始就落幕了，而我当时考虑最多的却是如何能活着看到 18 岁的阳光。</p><p>住院一年，春天，我和妈妈走在 304 的路上；夏天，我和妈妈走在协和的路上；秋天，我和妈妈走在人民医院的路上；冬天，我和妈妈走在 301 的路上；而爸爸，一直走在借钱的路上。</p><p>每隔两个月，爸爸就要请假来北京看我一次，送来治病的钱。我现在依然能够清晰地记得，爸爸离开医院要回家的场景。我去一楼送他，他背着两个大大的包，弓着背，穿过长长的走廊。走到门口的时候，一阵风吹过来，他突然一个趔趄，我的眼泪跟着就流了下来。</p><p>七年后那个早上，刚在办公室坐下打开电脑，生活的第二锤突如其来。我接到电话说：“你妈妈在海淀医院，赶快过来！”脑袋顿时一片空白，不知道自己是如何走出嘉华大厦的。当时正值初夏，外边的景色甚好，一片郁郁葱葱，连小鸟都在唱歌，而唯独我却看不到半点颜色听不到半点声响，整个世界顿时变成了黑白无声。</p><p>我生病后，妈妈就留在了北京打工，给别人做保姆。她从楼梯上摔下来了，腿部粉碎性骨折。没有保险也没有合同，事主只拿了 2 万块钱，我的爸爸又走在借钱的路上了。前脚爸爸刚把之前我住院的钱还得七七八八，把妹妹送上大学，如今就又被债务压得抬不起头来。妈妈在北京做完手术后，爸爸和大舅从老家背了块床板，坐了一天火车赶到北京，把妈妈抬回去了。这一年，我 24 岁。白银时代，不存在的。</p><p>2016 年的时候，爸爸来北京，我陪爸爸去拍登记照片，他要从教师岗位退休了。妹妹刚刚出国留学，爸爸赶上了年初老师普涨工资，家里总算不再负债。拍好照片我们去超市买了颗白菜，爸爸照旧是从我手里抢过去帮我提着菜，我感到一阵阵羞愧，三十多岁的人了还要父亲帮着提东西。那天依然是北京的雾霾天，太阳特别大，红彤彤地挂在半空，却没有半点光芒。一路无言。第二天，生活的第三锤就砸下来了，这次它直接把爸爸给砸没了，他出了车祸。</p><p>有时候，我常常觉得命运极其不公，每当生活稍微有点点起色，它就冲过来，狠狠地抽我两耳光，然后把我按在地上使劲摩擦。我想，我能活到现在，是因为总是能够碰到善良的人吧。</p><h3 id="病痛时代：我不配拥有爱情！"><a href="#病痛时代：我不配拥有爱情！" class="headerlink" title="病痛时代：我不配拥有爱情！"></a>病痛时代：我不配拥有爱情！</h3><p>住院最无望的日子，血小板低到检测不到。站在外科楼 15 层的窗口，不止一次地想象纵身一跃的场景，一定像一只大鸟一样吧，只不过是被扯断翅膀的。赵海宁紧跟着我，他总是和我说：“我们还不能死对吧？我们还没女朋友呢。”赵海宁是从甘肃来京，当了两年的兵，和我是整个病房住院最长的二人组。我说，你不能说点别的吗，他眨眨眼睛，说：“我们还是处男啊。”<br>年底的时候，我的病竟然慢慢地好起来，连高中暗恋的女同学在校友录看到我的消息都给我寄来了新年贺卡。赵海宁的情况却一天天坏下去。若干年后，在看《我不是药神》的时候，我的眼前不断浮现出他那因为吃激素而肥胖的脸，他不停地说着，我还没女朋友呢还没女朋友呢……</p><p>回到大学复学后，每天还要去门诊部打针，在宿舍熬整栋楼都能闻到的中药。每三周去 304 复查，这种生活让我一天比一天厌恶起来。一天晚上，爸爸给我打电话，说我的一个高中女同学要了我的通信地址。于是，三天后我收到了她的来信，信中说，她高考的时候没有考好，只考取了专科，大一的时候她刻苦学习，获得了仅有的上华中师范本科的机会。</p><p>信的最后，她写道，我高中就喜欢你了，做我男朋友吧。你很难想象到一个自卑到尘埃里的男人看到这封信的感受，这个自卑的男人回信中写了自己生病的情况，信的最后一句话是，我不配。姑娘不再提男女朋友的事情，但是他们的通信却在随后 3 年以每周一封的频率固定下来。原有专业找工作变得渺茫，我想自学编程，她极力鼓励了我，不知道信中那些变量她是如何读懂的。</p><h3 id="职场历练：工作让我重燃生活的希望"><a href="#职场历练：工作让我重燃生活的希望" class="headerlink" title="职场历练：工作让我重燃生活的希望"></a>职场历练：工作让我重燃生活的希望</h3><p>毕业后我的第一份工作在亦庄，不是专业的软件公司，是在一家本地化公司做内部 IT 系统。拿到第一个月工资 3500 块钱的时候，我跑到电话超市里给爸爸打了很长时间的电话。他刚给读高中的妹妹送完饭回来，那天我们说了很多我都忘记了，我只记得我说：“爸，以后我的药费可以自己给了。”</p><p>如果说之前的苦难塑造了我这个人，那我工作中遇到的几位老大便成就了今天的我。好多计算机书籍都是在第一家公司的时候读的，那会儿公司不加班，我的老大把自己的图书卡借给我，鼓励我多读书，不要荒废时间。</p><p>第二家公司的老大不仅让我平日里多读一些源代码，他个人更是一个狂热的开源社区贡献者。在他的影响下，我通读了 Spring、WebWork、Hibernate 的代码。他写的代码一直影响着我，因为就算在 2001-2002 年没有使用框架的情况下，代码读起来竟然是那么愉快。</p><p>第三家公司是 ThoughtWorks。与之前的都不同，那里扁平化的管理方式，鼓励着我们每个人都去分享。在这里我和同事连续翻译了两本书，还写了一本书，而我也是第一次在《程序员》《软件世界》和 InfoQ 这些平台上发表文章。</p><p>后来，我来到了腾讯。在这儿，我发生了一个身份的转变，在我老大的鼓励下转成了一名产品经理。也在这里结识了好多清华北大的同事，身边同事都喜欢谈论和分享技术，总有问不完的问题。让我获益良多。</p><p>第五家公司是去哪儿。当时的老大是北大毕业的，思路特别特别清晰，对数字也特别敏感，一个问题能够一直刨到底，他有个特别的习惯就是总是会在凌晨 12 点问当天的数据并追查原因。</p><h3 id="创业时代：失败才是人生常态"><a href="#创业时代：失败才是人生常态" class="headerlink" title="创业时代：失败才是人生常态"></a>创业时代：失败才是人生常态</h3><p>后来我走上了创业的道路。拿到第一笔投资是在公司下边的咖啡厅。我的投资人是位干练的女士，整个过程似乎不能再简单，一人点了一杯咖啡，就把事情谈完了。我在腾讯时用业余时间做了一个应用，依靠口碑在几个互联网公司有了一些用户，朋友介绍她知道了，找过来，问了详细的数据和后续的发展思路，这个事情就敲定下来了。现在看过来，并不是我能力有多优秀，只不过是刚好赶上了时代的大潮而已。</p><p>很快，一年后，在寻找第二轮投资时，就立刻感到了市场的寒意，这时我也才真正理解到投资人反复给我讲的看大势。接触了很多投资人，其中也有好几位大佬。见面多在他们的会议室，无一例外，他们都思路清晰、对数字特别敏感，关心增长，没人说 VC，也没人说 PE，绿水鬼是个什么鬼，谁在意这个。</p><p>尽管我们最后还是找到了第二轮投资，但中间资金链断裂的两个月，再次让我深深地体会到了绝望。合伙人退出，同事离开。深夜的西二旗，只剩路灯和我！一圈又一圈地走在空无一人的街道上，整个世界好像都是我的，整个世界好像又都和我无关。</p><p>我很感激我的第一个投资人，是她让我体会和学习到很多之前接触不到的东西。当然，元旦时给她发消息时，发现她把我删除了。我的第一次创业最终还是失败了。</p><p>年中的时候，几个高中同学在北京聚了聚。大家聊了聊近况。曾婷这哥们是最晚到北京的，在火箭研究所做工程师。我们问了他之前在干什么，他说，在修车行修车啊。他高考进的大学并不好，大学毕业后没找到好工作，就去修车行修车。</p><p>“你们知道吗，那些配件有多重？那个冬天，天气非常冷，抬着一个配件，我的眼泪突然就流出来了你们知道吗？我一个大学毕业生，却在这里抬配件修车，我不服气啊！我最感激的人是我的老婆，那时候她已经到北京来了，却一直没有放弃我，鼓励我考研，干了一年修车行，我考上了华科研究生，然后才到北京找到了现在的工作。”</p><p>他给我们看了他老婆和孩子的照片，没有什么比一家人在一起更好的了。我想起了我另外一个同学，同样是高考没有考好，大学毕业后在广东做了两年协警，却始终没法转正，最后重新考了武汉大学的研究生，现在在一家上市公司做法务。</p><p>对我们这些人来说，读书真的是改变命运的唯一途径啊。要感谢这个时代，感谢我们的国家。曾婷说：“我突然强烈地感到，个人的奋斗固然重要，但个人的命运是完全和我们国家的命运紧密联系在一起的。”当然，感叹完了，我们又聊了聊我们班上的女同学。</p><h3 id="奋斗依旧：愿做父亲一样的人"><a href="#奋斗依旧：愿做父亲一样的人" class="headerlink" title="奋斗依旧：愿做父亲一样的人"></a>奋斗依旧：愿做父亲一样的人</h3><p>现在，坐在上地三街的办公室，我打开我的电脑，检查订单那块的代码。7 年过去了，我重新开始写代码，只要愿意，我想一直写到退休都是没有问题的。很多年过去，尽管身份不断变化，但我还是更愿意把自己称为码农。我们是一个小公司，做了一个很小的应用，付费用户在不断增长。</p><p>人到中年，生活本来就是这个样子的，父母年龄渐长，孩子读书操心，哪个人不是用力在活着呢。每当工作生活中遇到挫折，我都会想起我的爸爸，他才是挨生活最重锤的人：年轻时教师发不出工资，他放学了去勤工俭学，包鱼塘贩橘子；等到教师工资归于财政，我又大病一场，2000 年的时候欠下 20 万；一个人在家拉扯妹妹长大，终于把钱还得七七八八，妈妈又摔断了腿；等得妈妈能走路了，妹妹也出国了，正要退休过一过清闲无负担的日子，他却走了。但是他却从来没有抱怨过生活，每次过年回家，他总是说：“什么时候到家，我去把头发染一下。”</p><p>我愿意做一个像父亲那样的人。泰山崩于前而色不变，无论生活给我开了多么大的玩笑，我都会伸手推开它的阻挠，坚定地向前走。</p><blockquote><p><strong>编后语</strong>：2018 年下半年，各种悲观的预期不断传来。股市低迷，融资困难，贸易争端前景难料，一些企业在酝酿着裁员，以应对即将到来的寒冬。到年底，一些公司陆陆续续真的开始主动减员。黑云压城城欲摧，在人们的心头，未来的不确定性陡然上升。<br>恰好前些天，荣浩君发来这篇文章，讲述了自己过往的不幸与有幸。我们认识荣浩君有好些年了，他是我们的一个作者，因书结缘而相识。此前他从来没有对人讲起过这些。我们认识的他，是一个谦谦君子，平心静气，态度温和，从来没有见过他做出不悦的样子。他离开腾讯之后，就在创业，运营着一个农林特产的直销业务，虽然还够不上说风生水起，他却也兢兢业业，稳扎稳打，一步一个脚印地发展着。<br>看过这篇文章，方知荣浩君之不易。就像他在文中说的，“常常觉得命运极其不公，每当生活稍微有点点起色，它就冲过来，狠狠地抽我两耳光，然后把我按在地上使劲摩擦”，可谓备尝生活之艰辛。然而他竟一桩一件地挺了过来，顽强地生存着。<br>图灵君由此想到生活在帝都的许许多多的年轻人，他们走出校园，寻找工作，孤身漂泊在异乡的都市，任由昂贵的房租吞噬着菲薄的收入，依然勤勉地努力学习和工作，提升自己，捕捉机会。有的人可能也会遭遇类似或不类似的重锤打击，在他们原本艰难的生计里，再增添不堪的重负。<br>人固能有置之死地而后生，而天断无绝人之路。无论如何艰难困苦，也要咬紧牙关挺过去。这是图灵君看完这篇文章最想跟大家说的。面对未知的2019，大家坚强些，再坚强些。就像荣浩君最后说的那样，“无论生活给我开了多么大的玩笑，我都会伸手推开它的阻挠，坚定地向前走。” 是的，风雨之后，彩虹会更加美丽，请把目光放远一点，越过眼前的沟沟坎坎，你生活的目标和意义尽在后头。</p></blockquote><p><strong>本文授权转载自图灵教育公众号</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;凡不能毁灭我的，必使我强大。   ——尼采 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;朋友在 javaeye 老炮群转发寒门的状元一文时，我正从车水马龙的西二旗地铁站气喘吁吁地挤出来。北京这几天温度还不错，风不大，但没有太阳。我超级不喜欢地铁站门口的那个红绿灯。我扫开一辆摩拜，戴上手套，背好双肩包，骑车去上地三街。店里反馈有个订单系统掉单了，我微信给同事说查一下这个订单，同事回复说：“不可能。”我说人会犯错，机器是不会骗人的，于是看到了这篇文章。&lt;/p&gt;
&lt;p&gt;我想起了王小波，他在《黄金时代》写过这样的句子：“那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>无题190331</title>
    <link href="http://yoursite.com/2019/03/31/%E6%97%A0%E9%A2%98190331/"/>
    <id>http://yoursite.com/2019/03/31/无题190331/</id>
    <published>2019-03-31T15:41:03.000Z</published>
    <updated>2019-04-01T16:51:30.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><strong>念念不忘，必有回响。</strong> </p></blockquote><img src="/2019/03/31/无题190331/food.jpg" title="Never give up the faith."><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;strong&gt;念念不忘，必有回响。&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2019/03/31/无题190331/food.jpg&quot; title=&quot;Never give up the faith.&quot;&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>JVM 内存管理与垃圾回收</title>
    <link href="http://yoursite.com/2018/08/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2018/08/12/内存管理与垃圾回收/</id>
    <published>2018-08-12T05:15:08.000Z</published>
    <updated>2019-03-30T05:58:42.557Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《深入理解Java虚拟机：JVM高级特性与最佳实践》，对其中的重要知识点进行一个总结。</p><h2 id="运行时的数据区"><a href="#运行时的数据区" class="headerlink" title="运行时的数据区"></a>运行时的数据区</h2><p><img src="http://ojr4jzv5e.bkt.clouddn.com/vernJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg"></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Java内存的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就跟随着回收了。</p><p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分的内存。</p><a id="more"></a> <h3 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。当一个对象被创建时，将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加1（a=b，则b引用的对象实例的计数器加1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减1。任何引用计数为0的对象实例可以被当作垃圾收集。</p><p>引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种：</p><ol><li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象； </li><li>本地方法栈中Native方法引用的对象.</li></ol><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li><p><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p></li><li><p><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p></li><li><p><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p></li><li><p><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是使用可达性算法进行标记的。</p><p>主要缺点有两个：</p><ul><li>效率问题，标记和清除两个过程的效率都不高</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片</li></ul><p><img src="http://ojr4jzv5e.bkt.clouddn.com/vern%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/vern%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg"></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/vern%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg"></p><p>标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高JVM的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/Hotspot%20Heap%20Structure.png"></p><p>G1把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/G1%20Heap%20Allocation.png"></p><p>通过引入Region的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>每个Region都有一个Remembered Set，用来记录该Region对象的引用对象所在的Region。通过使用Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/G1.jpg"></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs的数据合并到 Remembered Set中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><p>当这三个分代的堆空间比较紧张或者没有足够的空间来为新到的请求分配的时候，垃圾回收机制就会起作用。有两种类型的垃圾回收方式：次收集和全收集。当新生代堆空间满了的时候，会触发次收集将还存活的对象移到年老代堆空间。当年老代堆空间满了的时候，会触发一个覆盖全范围的对象堆的全收集。</p><ul><li><p><strong>Minor GC</strong>：发生在新生代上，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。</p></li><li><p><strong>Full GC</strong>：发生在老年代上，老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。</p></li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ol><li><p>对象优先在Eden分配。大多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC。</p></li><li><p>大对象直接进入老年代。大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p></li><li><p>长期存活的对象将进入老年代。为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p></li><li><p>动态对象年龄判定。虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。</p></li><li><p>空间分配担保。在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p></li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）,7个阶段的发生顺序如下图所示。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><p>从Java虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分；</p></li><li><p>所有其他类的加载器，这些类由Java实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p></li></ul><p>从Java开发人员的角度看，类加载器有如下划分：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在&lt;JRE_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可。</p></li><li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt;JAVA_HOME&gt;/lib/ext或者被java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>应用程序都是由三种类加载相互配合进行加载的，如有必要，可以加入自定义的类加载器。</p><p>下图展示了类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都最终应该传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会自己尝试去加载。</p><p>当然，大部分的类加载都遵循这个模型，但也有例外。</p><p><strong>参考</strong></p><ol><li>《深入理解Java虚拟机：JVM高级特性与最佳实践》,周志明</li><li><a href="https://vernlium.github.io/2015/10/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">《深入理解Java虚拟机》读书笔记</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《深入理解Java虚拟机：JVM高级特性与最佳实践》，对其中的重要知识点进行一个总结。&lt;/p&gt;
&lt;h2 id=&quot;运行时的数据区&quot;&gt;&lt;a href=&quot;#运行时的数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时的数据区&quot;&gt;&lt;/a&gt;运行时的数据区&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ojr4jzv5e.bkt.clouddn.com/vernJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h2&gt;&lt;p&gt;Java内存的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就跟随着回收了。&lt;/p&gt;
&lt;p&gt;而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分的内存。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统中的重要的协议</title>
    <link href="http://yoursite.com/2018/08/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/08/06/分布式系统中的重要的协议/</id>
    <published>2018-08-06T08:21:47.000Z</published>
    <updated>2018-08-14T11:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。</p><h2 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h2><p>两阶段提交协议（Two-phase Commit,2PC）通常用来实现分布式事务。在该协议中，系统包含两类节点：一类为协调者，通常只有一个，另一类为事务参与者，一般包含多个。</p><p>在正常的执行过程中，两阶段提交协议包含以下两个过程：</p><p><strong>阶段1</strong>：请求阶段。在请求阶段，协调者通知事务参与者准备提交或者取消事务，然后进入表决过程。在表决过程中，参与者告知协调者自己的决策：同意（事务本地执行成功）或者取消（事务本地执行失败）。</p><p><strong>阶段2</strong>：提交阶段。在提交阶段，协调者基于第一阶段的投票结果进行决策：提交或者取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则通知所有参与者取消事务。参与者在接收到协调者的消息后执行相应操作。</p><p>二阶段提交协议看起来确实能够提供原子性的操作，但还是存在几个缺点：</p><ol><li><p>同步阻塞问题。执行过程中，所有参与者都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p></li><li><p>单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题。）</p></li><li><p>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p></li><li><p>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></li></ol><p>上述协议存在问题，在请求阶段，如果某一参与者迟迟不能回复，系统将一直处于等待状态，并且其他参与者持有的资源不能得到释放。不过协调者可以通过引入事务的超时机制防止资源一直不能得到释放的情况。但是若协调者出现故障，事务将被阻塞。故两阶段提交协议可能面临两种故障：</p><ol><li><p>事务参与者发生故障。给每个事务设置超时时间，若参与者不能及时响应，整个事务失败。</p></li><li><p>协调者发生故障。协调者需要将事务相关信息记录到操作日志并同步到备用协调者，假如协调者发生故障，备用协调者可以接替完成后续工作。</p></li></ol><p>总之，两阶段提交协议是阻塞协议，协议过程中需要锁住其它更新，且不能容错，并不适合高并发系统，大多数分布式系统都不采用，放弃对分布式事务的支持。</p><h2 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h2><p>三阶段提交协议（Three-phase Commit，3PC）是对二阶段提交协议的改进，改动点如下：</p><ol><li><p>引入超时机制。同时在协调者和参与者中都引入超时机制。</p></li><li><p>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。即3PC把2PC的准备阶段一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p></li></ol><p>在DoCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</p><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</p><p><a href="http://blog.jobbole.com/89140/" target="_blank" rel="noopener">使用消息队列来避免分布式事务</a></p><h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><p>Paxos协议用于解决多个节点之间的一致性问题。多个节点通过操作日志同步数据，如果只有一个节点为主节点，很容易确保多个节点之间操作日志的一致性。考虑主节点可能发生故障，系统需要选举新的主节点。Paxos协议正是用来实现此需求。只要保证多个节点之间操作日志的一致性，就能在这些节点上构建高可用的全局服务，例如分布式锁服务，全局命名和配置服务等。</p><p>为了实现高可用性，主节点把数据以操作日志的形式同步到备节点。若主节点发生故障，备节点会提议自己成为主节点。存在的一个问题是网络分区的时候，可能会存在多个备节点（Proposer,提议者）提议。Paxos协议保证，即使存在多个提议者，也能保证所有节点最终达成一致，即选举出唯一的主节点。</p><p>大多数情况下，系统只有一个提议节点，提议会很快被大多数节点接受。Paxos协议执行步骤如下：</p><ol><li><p>批准（accept）：提议者发送accept消息要求其他所有节点接受某个提议值，其它节点可以接受或者拒绝。</p></li><li><p>确认（acknowledge）：如果超过一半的其它节点接受，意味着提议值生效，提议者发送确认消息通知所有的节点提议生效。</p></li></ol><p>当网络或者其他异常时，系统中可能存在多个提议者，各自发起不同的提议。这里的提议可以是一个修改，也可以是自己成为主节点。如果提议者第一次发起的accept请求没有被其它节点的多数派批准，那么需要完整地执行一轮Paxos协议。过程如下:</p><ol><li><p>准备（prepare）：Proposer首先选择一个提议序号n给其他的acceptor节点发送prepare消息。Acceptor收到prepare消息后，如果提议的序号大于其已经回复的所有prepare消息，则acceptor将自己上次接受的提议回复给proposer，并承诺不再回复小于n的提议。</p></li><li><p>批准（accept）：Proposer收到了acceptor中的多数派对prepare的回复后，就进入批准阶段。如果在之前的prepare阶段acceptor回复了上次接受的提议，那么proposer选择其中序号最大的提议值发给acceptor批准；否则，proposer生成一个新的提议值发给acceptor批准。Acceptor在不违背他之前在prepare阶段的承诺的前提下，接受这个请求。</p></li><li><p>确认（acknowledge）：如果超过一半的acceptor接受，提议值生效。Proposer发送knowledge消息通知所有的acceptor提议生效。</p></li></ol><p>Paxos协议需要考虑两个问题：正确性，即只有一个提议值生效；可终止性，即最后总有一个提议值生效。</p><p><strong>参考</strong>：</p><ol><li>《大规模分布式存储系统：原理解析与架构实战》,杨传辉</li><li><a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议</a></li><li><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Paxos算法</a></li><li><a href="http://www.hollischuang.com/archives/693" target="_blank" rel="noopener">分布式一致性算法——paxos</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。&lt;/p&gt;
&lt;h2 id=&quot;两阶段提交协议&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式存储" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库主键、外键、索引</title>
    <link href="http://yoursite.com/2018/07/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E3%80%81%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/07/26/数据库主键、外键、索引/</id>
    <published>2018-07-26T08:36:09.000Z</published>
    <updated>2018-08-14T11:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>表通常具有包含唯一标识表中每一行的值的一列或一组列。这样的一列或多列称为表的主键(PK)，用于强制表的实体完整性。由于主键约束可保证数据的唯一性，因此经常对标识列定义这种约束。</p><p>如果为表指定了主键约束，数据库引擎将通过为主键列自动创建唯一索引来强制数据的唯一性。当在查询中使用主键时，此索引还允许对数据进行快速访问。如果对多列定义了主键约束，则一列中的值可能会重复，但来自主键约束定义中所有列的值的任何组合必须唯一。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>外键(FK)是用于在两个表中的数据之间建立和加强链接的一列或多列的组合，可控制可在外键表中存储的数据。在外键引用中，当包含一个表的主键值的一个或多个列被另一个表中的一个或多个列引用时，就在这两个表之间创建了链接。这个列就成为第二个表的外键。</p><blockquote><p>互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展。</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中，索引存储了指向表中某一行的指针。请记住记住这一点：<strong>索引是一种数据结构</strong>。</p><ul><li><p><strong>B-Tree</strong>是最常用的用于索引的数据结构。因为它们是时间复杂度低，查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。</p></li><li><p><strong>哈希表</strong>是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高。但只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的，这就是为什么哈希索引通常不是数据库索引的默认数据结构-因为在作为索引的数据结构时，其不像B-Tree那么灵活。</p></li></ul><h2 id="主键、外键和索引的对比"><a href="#主键、外键和索引的对比" class="headerlink" title="主键、外键和索引的对比"></a>主键、外键和索引的对比</h2><table><thead><tr><th></th><th>主键</th><th>外键</th><th>索引   </th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>唯一标识一条记录，不允许重复，不允许为空</td><td>表的外键是另一表的主键,外键可以重复, 可以为空</td><td>该字段没有重复值，但可以有一个空值</td></tr><tr><td><strong>作用</strong></td><td>保证数据完整性</td><td>和其他表建立联系</td><td>提高查询排序速度 </td></tr><tr><td><strong>个数</strong></td><td>唯一</td><td>可以有多个外键</td><td>可以有多个唯一索引 </td></tr></tbody></table><p><strong>参考</strong>：</p><ol><li><a href="https://blog.csdn.net/weiliangliang111/article/details/51333169" target="_blank" rel="noopener">数据库索引到底是什么，是怎样工作的？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主键&quot;&gt;&lt;a href=&quot;#主键&quot; class=&quot;headerlink&quot; title=&quot;主键&quot;&gt;&lt;/a&gt;主键&lt;/h2&gt;&lt;p&gt;表通常具有包含唯一标识表中每一行的值的一列或一组列。这样的一列或多列称为表的主键(PK)，用于强制表的实体完整性。由于主键约束可保证数据的唯
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>世界杯一二事</title>
    <link href="http://yoursite.com/2018/07/16/%E4%B8%96%E7%95%8C%E6%9D%AF%E4%B8%80%E4%BA%8C%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/07/16/世界杯一二事/</id>
    <published>2018-07-16T11:32:04.000Z</published>
    <updated>2018-08-14T11:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比赛前的选择"><a href="#比赛前的选择" class="headerlink" title="比赛前的选择"></a>比赛前的选择</h2><p>昨天熬夜看球到2点，见证了法国夺冠。兴奋，满足，那种感觉就是你一直坚信一件事情的结果，而结局如你所愿。</p><p>世界杯开始前，微博有一个活动，pick你认为的今年的冠军。对一个伪足球迷而言，很难讲自己最喜欢哪只球队，德国，巴西，法国，阿根廷，西班牙，实力强的队伍太多了，各有各的特点，从某种意义上讲都有夺冠的机会。但是冠军只有一个，你的选择也只有一个。最终选择了法国，没有太多的理由，大概是年轻有潜力吧。既然选择了，就仿佛是认定了一般，开始了解法国队，开始关注法国的每一场比赛，关注某些球星的表现。最终，法国也确实没有让球迷失望，时隔20年再次捧起大力神杯。</p><p>选择需要理性，但有时候也存在着感性。法国队球员身价最高，年轻，然而缺少经验，这是一直不被大家看好的一点。但没有一支球队是完美的，何况完美的球队也不一定能夺得最终的冠军，竞技比赛充满太多未知性。但是在选择的那一刻，你认准一点或许就足够了，足够你做出一个选择。</p><h2 id="直到有一天，世界杯成为记忆"><a href="#直到有一天，世界杯成为记忆" class="headerlink" title="直到有一天，世界杯成为记忆"></a>直到有一天，世界杯成为记忆</h2><p>翻看微信公众号，突然就看到了杨毅先生的文章《<a href="https://mp.weixin.qq.com/s/2oKKP4hVaFmGJsQpmXDNrg" target="_blank" rel="noopener">直到有一天，世界杯成为记忆</a>》，感触颇深。俄罗斯世界杯是我看的第三届世界杯，严格意义上我并不是足球迷，但是世界杯这样的体坛盛事，对每个热爱体育竞技的人都不容错过。很喜欢文中的几段话，“不夸张地说，对一个喜爱体育的男生来说，在一个更长的跨度里，没有什么能超过世界杯带来的仪式感。这是体育世界里最大的，最富有世界影响力的品牌，四年才一度。既体现它的稀有，又映衬着你生活里不同的时代。你会轻易地记起，哪一届世界杯你有多大，你正在经历什么。每一届时的你都截然不同，因为每一个四年都是你成长的刻度。”</p><p><img src="http://ojr4jzv5e.bkt.clouddn.com/worldcup_02.jpg"></p><p>的确，每一届世界杯都是一个阶段，世界杯结束一个阶段结束了。10年第一次看世界杯，那会儿刚初中毕业，印象最深的是德国阿根廷那场；14年在大学，凌晨4点和室友看德国巴西，以及自己一个人在车站附近网吧看了德国阿根廷；18年读研，在家看法国阿根廷，在宾馆看法国比利时，在寝室看法国克罗地亚。4年时间说长不长，但也不短，不知道还能看几届世界杯，只希望今后日子里心怀热情，但行好事，莫问前程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比赛前的选择&quot;&gt;&lt;a href=&quot;#比赛前的选择&quot; class=&quot;headerlink&quot; title=&quot;比赛前的选择&quot;&gt;&lt;/a&gt;比赛前的选择&lt;/h2&gt;&lt;p&gt;昨天熬夜看球到2点，见证了法国夺冠。兴奋，满足，那种感觉就是你一直坚信一件事情的结果，而结局如你所愿。&lt;/p
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》总结</title>
    <link href="http://yoursite.com/2018/07/13/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/13/《统计学习方法》总结/</id>
    <published>2018-07-13T04:58:50.000Z</published>
    <updated>2018-08-14T12:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本书主要介绍了感知机、K近邻法、朴素贝叶斯法、决策树、Logistic回归与最大熵模型、支持向量机、提升方法、EM算法、隐马尔可夫模型、条件随机场。</p><h2 id="各种统计学习方法特点总结"><a href="#各种统计学习方法特点总结" class="headerlink" title="各种统计学习方法特点总结"></a>各种统计学习方法特点总结</h2><center><strong>表1 10种统计学习方法特点的概括总结</strong></center><p><br></p><table><thead><tr><th>方法</th><th>适用问题</th><th>模型特点</th><th>模型类型</th><th>学习策略</th><th>学习的损失函数</th><th>学习算法 </th></tr></thead><tbody><tr><td>感知机</td><td>二类分类</td><td>分离超平面</td><td>判别模型</td><td>极小化误分点到超平面的距离</td><td>误分点到超平面的距离</td><td>随机梯度下降</td></tr><tr><td>k临近法</td><td>多类分类，回归</td><td>特征空间，样本点</td><td>判别模型</td><td></td><td></td><td></td></tr><tr><td>朴素贝叶斯法</td><td>多类分类</td><td>特征与类别的联合概率分布，条件独立假设</td><td>生成模型</td><td>极大似然估计，极大后验概率估计</td><td>对数似然损失</td><td>概率计算公式，EM算法</td></tr><tr><td>决策树</td><td>多类分类，回归</td><td>分类树，回归树</td><td>判别模型</td><td>正则化的极大似然估计</td><td>对数似然损失</td><td>特征选择，生成，剪枝</td></tr><tr><td>Logistic回归与最大熵模型</td><td>多类分类</td><td>特征条件下类别的条件概率分布，对数线性模型</td><td>判别模型</td><td>极大似然估计，正则化的极大似然估计</td><td>logistic损失</td><td>改进的迭代尺度算法，梯度下降，拟牛顿法</td></tr><tr><td>支持向量机</td><td>二类分类</td><td>分离超平面，核技巧</td><td>判别模型</td><td>极小化正则化合页损失，软间隔最大化</td><td>合页损失</td><td>序列最小最优化算法（SMO）</td></tr><tr><td>提升方法</td><td>二类分类</td><td>弱分类器的线性组合</td><td>判别模型</td><td>极小化加法模型的指数损失</td><td>指数损失</td><td>前向分步加法算法</td></tr><tr><td>EM算法</td><td>概率模型参数估计</td><td>含隐变量概率模型</td><td></td><td>极大似然估计，极大后验概率估计</td><td>对数似然损失</td><td>迭代算法</td></tr><tr><td>隐马尔可夫模型</td><td>标注</td><td>观测序列与状态序列的联合概率分布模型</td><td>生成模型</td><td>极大似然估计，极大后验概率估计</td><td>对数似然损失</td><td>概率计算公式，EM算法</td></tr><tr><td>条件随机场</td><td>标注</td><td>状态序列条件下观测序列的条件概率分布，对数线性模型</td><td>判别模型</td><td>极大似然估计，正则化极大似然估计</td><td>对数似然损失</td><td>改进的迭代尺度算法，梯度下降，拟牛顿法</td></tr></tbody></table><p><strong>Relevant Link</strong></p><ol><li><a href="https://zhuanlan.zhihu.com/p/25327755" target="_blank" rel="noopener">机器学习算法集锦：从贝叶斯到深度学习及各自优缺点</a></li><li><a href="https://www.zhihu.com/question/26726794" target="_blank" rel="noopener">各种机器学习算法的应用场景分别是什么（比如朴素贝叶斯、决策树、K 近邻、SVM、逻辑回归最大熵模型）？</a></li></ol><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>感知机（perceptron）是<strong>二类分类</strong>的<strong>线性分类</strong>模型，其输入为样本实例的特征向量，输出为实例的类别，是一种<strong>判别模型</strong>。感知机的目的是求出将训练数据进行线性划分的超平面，为此，导入基于误分类的损失函数，利用梯度下降法对损失函数进行最小化，以求得感知机模型。感知机学习算法具有简单易实现的优点，分为<strong>原始形式</strong>和<strong>对偶形式</strong>。</p><h3 id="感知机模型与学习策略"><a href="#感知机模型与学习策略" class="headerlink" title="感知机模型与学习策略"></a>感知机模型与学习策略</h3><h4 id="数据集的线性可分性"><a href="#数据集的线性可分性" class="headerlink" title="数据集的线性可分性"></a>数据集的线性可分性</h4><p>存在一个超平面将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，则称该数据集线性可分。$2*w=12$</p><h4 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h4><p>定义（经验）损失函数并将损失函数最小化，损失函数的一个自然选择是误分类的点数，但是这样的损失函数不是参数w，b的连续可导函数，不易优化。因此选择误分类点到超平面S的总距离。<br>定义感知机 $ [sign(w*x+b)] $ 学习的损失函数为</p><p><img src="https://latex.codecogs.com/gif.latex?\small&space;L(w,b)=-\sum_{x_{i}\in&space;M}y_{i}(w*x_{i}&plus;b)" title="\small L(w,b)=-\sum_{x_{i}\in M}y_{i}(w*x_{i}+b)"></p><h3 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h3><p>感知机学习问题转化为求解损失函数的最优化问题，最优化问题的方法是随机梯度下降法。首先，任意选取一个超平面，然后采用梯度下降法不断地极小化目标函数，极小化过程不是一次使所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。</p><h4 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h4><h4 id="算法的收敛性"><a href="#算法的收敛性" class="headerlink" title="算法的收敛性"></a>算法的收敛性</h4><p>Novikoff定理表明误分类的次数是有上界的，经过有限次搜索可以找到将训练数据完全分开的分离超平面。<br>感知机学习算法存在许多解，这些解既依赖于初值的选择，也依赖于迭代过程中误分类点的选择顺序。</p><h4 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a>感知机学习算法的对偶形式</h4><h2 id="K近邻法"><a href="#K近邻法" class="headerlink" title="K近邻法"></a>K近邻法</h2><p>K近邻法是一种基本分类与回归方法，K近邻法输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。分类时，对新的实例，根据其k个最邻近的训练实例的类别，通过多数表决方式进行预测。K近邻法不具有显式的学习过程，本质上是利用训练数据对特征向量空间进行划分，并作为其分类的“模型”。K值的选择、距离度量以及分类决策规则是K近邻法的三个基本要素。</p><h3 id="K近邻模型"><a href="#K近邻模型" class="headerlink" title="K近邻模型"></a>K近邻模型</h3><h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><p>采用不同的距离度量，如欧氏距离、Minkowski距离等，所确定的最近邻点也是不同的。</p><h4 id="K值选择"><a href="#K值选择" class="headerlink" title="K值选择"></a>K值选择</h4><p>K值的选择影响近似误差和估计误差。K值一般选择一个比较小的数值，通常采用交叉验证法选取最优的K值。</p><h4 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h4><p>多数表决。对数表决规则等价于经验风险最小化。</p><h3 id="K近邻法的实现：kd树"><a href="#K近邻法的实现：kd树" class="headerlink" title="K近邻法的实现：kd树"></a>K近邻法的实现：kd树</h3><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯法是基于<strong>贝叶斯原理</strong>与<strong>特征条件独立假设</strong>的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的<strong>联合概率分布</strong>；然后基于此模型，对给定的输入x,利用贝叶斯原理求出后验概率最大的输出y。</p><h3 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h3><h3 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h3><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><h4 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h4><p>用极大似然估计可能会出现所要估计的概率值为0的情况，会影响后验概率的计算结果，使分类产生偏差。条件概率的贝叶斯估计如下：<br><img src="https://latex.codecogs.com/gif.latex?P_{\lambda&space;}(X^{(j)}=a_{jl}|Y=c_{k})=\frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=a_{jl},y_{i}=c_{k})&plus;\lambda}{\sum_{i=1}^{N}I(y_{i}=c_{k})&plus;S_{j}\lambda&space;}" title="P_{\lambda }(X^{(j)}=a_{jl}|Y=c_{k})=\frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=a_{jl},y_{i}=c_{k})+\lambda}{\sum_{i=1}^{N}I(y_{i}=c_{k})+S_{j}\lambda }"><br>式中$[\lambda]$&gt;=0.等价于在随机变量各个取值的频数上赋予一个正数$[\lambda]$&gt;=0。当$[\lambda]$=0时就是极大似然估计。常取$[\lambda]$=1，此时称为拉普拉斯平滑。</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h3 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h3><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><h3 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h3><h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h3><h2 id="Logistic回归与最大熵模型"><a href="#Logistic回归与最大熵模型" class="headerlink" title="Logistic回归与最大熵模型"></a>Logistic回归与最大熵模型</h2><h3 id="Logistic回归模型"><a href="#Logistic回归模型" class="headerlink" title="Logistic回归模型"></a>Logistic回归模型</h3><h3 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h3><h3 id="模型学习的最优化算法"><a href="#模型学习的最优化算法" class="headerlink" title="模型学习的最优化算法"></a>模型学习的最优化算法</h3><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="线性可分向量机与硬间隔最大化"><a href="#线性可分向量机与硬间隔最大化" class="headerlink" title="线性可分向量机与硬间隔最大化"></a>线性可分向量机与硬间隔最大化</h3><h3 id="线性支持向量机与软间隔最大化"><a href="#线性支持向量机与软间隔最大化" class="headerlink" title="线性支持向量机与软间隔最大化"></a>线性支持向量机与软间隔最大化</h3><h3 id="非线性支持向量机与核函数"><a href="#非线性支持向量机与核函数" class="headerlink" title="非线性支持向量机与核函数"></a>非线性支持向量机与核函数</h3><h3 id="序列最小最优化算法"><a href="#序列最小最优化算法" class="headerlink" title="序列最小最优化算法"></a>序列最小最优化算法</h3><h2 id="提升方法"><a href="#提升方法" class="headerlink" title="提升方法"></a>提升方法</h2><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><h2 id="隐马尔科夫模型"><a href="#隐马尔科夫模型" class="headerlink" title="隐马尔科夫模型"></a>隐马尔科夫模型</h2><h2 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h2><p><strong>值得思考的问题</strong></p><ol><li><a href="https://www.zhihu.com/question/26726794" target="_blank" rel="noopener">各种机器学习算法的应用场景分别是什么（比如朴素贝叶斯、决策树、K 近邻、SVM、逻辑回归最大熵模型）？</a></li><li><a href="https://www.zhihu.com/question/51500780" target="_blank" rel="noopener">感知机（perceptron）和支持向量机（svm）是一种东西吗？如果不是那他们的区别和关系是什么？</a></li><li><a href="https://www.zhihu.com/question/49805962" target="_blank" rel="noopener">如何用简单易懂的例子解释格拉姆矩阵/Gram matrix？</a></li><li><a href="https://www.zhihu.com/question/60793482" target="_blank" rel="noopener">如何理解和区分近似误差和估计误差?</a></li><li><a href="https://www.zhihu.com/question/20507061" target="_blank" rel="noopener">线性代数中，特征值与特征向量在代数和几何层面的实际意义是什么？</a></li><li><a href="https://www.zhihu.com/question/20447622" target="_blank" rel="noopener">最大似然估计和最小二乘法怎么理解？</a></li><li><a href="https://www.zhihu.com/question/20852004" target="_blank" rel="noopener">如何通俗易懂地解释「协方差」与「相关系数」的概念？</a></li><li><a href="https://www.zhihu.com/question/263672028" target="_blank" rel="noopener">为什么都说神经网络是个黑箱？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本书主要介绍了感知机、K近邻法、朴素贝叶斯法、决策树、Logistic回归与最大熵模型、支持向量机、提升方法、EM算法、隐马尔可夫模型、条件随机场。&lt;/p&gt;
&lt;h2 id=&quot;各种统计学习方法特点总结&quot;&gt;&lt;a href=&quot;#各种统计学习方法特点总结&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
