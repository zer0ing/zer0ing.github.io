<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring系列——IoC之Bean的装载和注册]]></title>
    <url>%2F2019%2F10%2F20%2FSpring%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94IoC%E4%B9%8BBean%E7%9A%84%E8%A3%85%E8%BD%BD%E5%92%8C%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Bean在容器中从发现到使用有以下过程：定位、装载、注册。 定位：一般使用外部资源描述 Bean 对象，定位资源是指找到资源的过程。 装载：解析 Resource 资源，将用户定义的 Bean 表示成IoC容器的内部数据结构：BeanDefinition。 在IoC容器内部维护着一个BeanDefinition Map的数据结构。 在配置文件中每一个&lt;bean&gt;都对应着一个 BeanDefinition 对象。 注册：向IoC容器注册在第二步解析好的 BeanDefinition ，这个过程是通过 BeanDefinitionRegistry 接口来实现的。 了解上述过程后，我们再来看一段代码： 1234567ClassPathResource resource = new ClassPathResource("bean.xml"); // &lt;1&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // &lt;2&gt;XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); // &lt;3&gt;reader.loadBeanDefinitions(resource); // &lt;4&gt; 获取 xml 资源 创建 BeanFactory 容器 根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的解析器 装载资源 从上述代码可知，资源装载主要在发生，即 loadBeanDefinitions(resource) 方法，我们从这个方法入手，逐步分析资源装载的流程。 loadBeanDefinitions()loadBeanDefinitions(Resource) 方法在 org.springframework.beans.factory.support.BeanDefinitionReader 接口中定义，该接口的具体子类实现该方法，如上面 XmlBeanDefinitionReader 。下面显示 XmlBeanDefinitionReader 中 loadBeanDefinitions(Resource) 代码： 12345@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; //将 Resource 封装为 EncodedResource ,以方便实现编码 return loadBeanDefinitions(new EncodedResource(resource));&#125; 首先将 Resource 封装为 EncodedResource ,以方便实现编码，然后再调用 loadBeanDefinitions(EncodedResource) 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, "EncodedResource must not be null"); if (logger.isTraceEnabled()) &#123; logger.trace("Loading XML bean definitions from " + encodedResource); &#125;// &lt;1&gt; 获取已装载的 EncodeResource集合 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; // 将当前资源加入记录中。如果已存在，抛出异常 throw new BeanDefinitionStoreException( "Detected cyclic loading of " + encodedResource + " - check your import definitions!"); &#125; try &#123; // &lt;2&gt; 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; //设置编码 inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 核心逻辑部分，执行加载 BeanDefinition return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( "IOException parsing XML document from " + encodedResource.getResource(),ex); &#125; finally &#123; // &lt;3&gt; 从缓存中剔除该资源 currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 通过 resourcesCurrentlyBeingLoaded.get() 代码，来获取已经加载过的资源，然后将 encodedResource 加入其中，如果 resourcesCurrentlyBeingLoaded 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。 resourcesCurrentlyBeingLoaded 是一个 ThreadLocal&lt;Set&gt; 实例。 通过这种方式来避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，从而导致死循环。 同样，处，当一个 EncodedResource 加载完成后，需要从缓存中剔除。 从 encodedResource 获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream，然后将 InputStream 封装为 InputSource，最后调用 doLoadBeanDefinitions(InputSource inputSource, Resource resource) 方法，执行加载 BeanDefinition 的真正逻辑。 doLoadBeanDefinitions()123456789101112131415161718192021222324252627282930313233343536protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123;// 获取 XML Document 实例 Document doc = doLoadDocument(inputSource, resource);// 注册 Bean 信息 int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) &#123; logger.debug("Loaded " + count + " bean definitions from " + resource); &#125; return count; &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), "XML document from " + resource + " is invalid", ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), "Parser configuration exception parsing XML from " + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), "IOException parsing XML document from " + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), "Unexpected exception parsing XML document from " + resource, ex); &#125;&#125; 分析上述代码： 调用 doLoadDocument(inputSource, resource) 获取 XML Document 实例。 调用 registerBeanDefinitions(Document doc, Resource resource) 方法，根据获取的 Document 实例，注册 Bean 信息。 doLoadDocument()12345678protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123;// 调用 DocumentLoader.loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) 方法，// 获取 XML Document 实例 // 调用 getValidationModeForResource(Resource resource) 方法， // 获取指定资源（xml）的验证模式 return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; 分析上述代码： 调用 getValidationModeForResource(Resource resource) 方法，获取指定资源(XML)的验证模式。 调用 DocumentLoader.loadDocument(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, int validationMode, boolean namespaceAware) 方法，获取 XML Document 实例。 getValidationModeForResource()getValidationModeForResource(Resource resource) 可以获取资源的验证模式，通过验证模式我们可以验证资源文件的准确性。 123456789101112131415161718192021222324252627282930// 四种验证默认//禁用验证模式 public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;//自动获取验证模式public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;//DTDpublic static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;//XSDpublic static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;// 默认是VALIDATION_AUTOprivate int validationMode = VALIDATION_AUTO;protected int getValidationModeForResource(Resource resource) &#123;// 获取验证模式 int validationModeToUse = getValidationMode();// 如果手动指定，则直接返回 if (validationModeToUse != VALIDATION_AUTO) &#123; return validationModeToUse; &#125;// 自动获取验证模式 int detectedMode = detectValidationMode(resource); if (detectedMode != VALIDATION_AUTO) &#123; return detectedMode; &#125; // 最后，使用 VALIDATION_XSD 做为默认 return VALIDATION_XSD;&#125; 分析上述代码： 通过 int validationModeToUse = getValidationMode() 直接获取验证模式，如果手动指定验证模式，则直接返回；若未手动指定验证模式，则自动获取。 通过 detectValidationMode() 自动获取验证模式。 最后使用 VALIDATION_XSD 作为默认验证模式。 我们接下来看一下自动获取验证模式的语句 detectValidationMode() ： 1234567891011121314151617181920212223242526protected int detectValidationMode(Resource resource) &#123; //资源不可读，抛出异常 if (resource.isOpen()) &#123; throw new BeanDefinitionStoreException( "Passed-in Resource [" + resource + "] contains an open stream: " + "cannot determine validation mode automatically. Either pass in a Resource " + "that is able to create fresh streams, or explicitly specify the validationMode " + "on your XmlBeanDefinitionReader instance."); &#125; //打开输入流 InputStream inputStream; try &#123; inputStream = resource.getInputStream(); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( "Unable to determine validation mode for [" + resource + "]: cannot open InputStream. " + "Did you attempt to load directly from a SAX InputSource without specifying the " + "validationMode on your XmlBeanDefinitionReader instance?", ex); &#125; try &#123; //核心语句 ，调用 XmlValidationModeDetector.detectValidationMode(InputStream inputStream) 方法获取相应的验证模式 return this.validationModeDetector.detectValidationMode(inputStream); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException("Unable to determine validation mode for [" + resource + "]: an error occurred whilst reading from the InputStream.", ex); &#125;&#125; XmlValidationModeDetector 类org.springframework.util.xml.XmlValidationModeDetector ，XML 验证模式探测器。该类核心方法是 detectValidationMode() ,主要功能是判断 XML 文件验证方式是 XSD 还是 DTD 。这里贴出一张判断流程图，来源于 spring源码（六）–XmlValidationModeDetector（获取xml文档校验模式）。 DocumentLoader.loadDocument()DocumentLoaderorg.springframework.beans.factory.xml.DocumentLoader 是一个接口，定义从资源文件加载到转换为 Document 的功能。 1234567public interface DocumentLoader &#123; Document loadDocument( InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception;&#125; inputSource: 方法参数，加载 Document 的 Resource 资源。 entityResolver: 方法参数，解析文件的解析器。 errorHandler: 方法参数，处理加载 Document 对象的过程的错误。 validationMode: 方法参数，验证模式。 namespaceAware: 方法参数，命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为 true 。 DefaultDocumentLoaderorg.springframework.beans.factory.xml.DefaultDocumentLoader 是 DefaultDocumentLoader 的默认实现类。 123456789101112@Overridepublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exceptio&#123;// 创建 DocumentBuilderFactory DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isTraceEnabled()) &#123; logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]"); &#125;// 创建 DocumentBuilder DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);// 解析InputSource 返回 Document 对象 return builder.parse(inputSource);&#125; EntityResolverDocumentLoader.loadDocument() 方法中有一个参数 EntityResolver ，该参数通过 XmlBeanDefinitionReader.getEntityResolver() 方法来获取的。 EntityResolver 的作用: 通过实现它，应用可以自定义如何寻找【验证文件】的逻辑。 EntityResolver 有四个子类，分别是： org.springframework.beans.factory.xm.BeansDtdResolver ：实现 EntityResolver 接口，Spring Bean dtd 解码器，用来从 classpath 或者 jar 文件中加载 dtd 。 org.springframework.beans.factory.xml.PluggableSchemaResolver ，实现 EntityResolver 接口，读取 classpath 下的所有 &quot;META-INF/spring.schemas&quot; 成一个 namespaceURI 与 Schema 文件地址的 map 。 org.springframework.beans.factory.xml.DelegatingEntityResolver ：实现 EntityResolver 接口，分别代理 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver 。 org.springframework.beans.factory.xml.ResourceEntityResolver：继承自 DelegatingEntityResolver 类，通过 ResourceLoader 来解析实体的引用。 getEntityResolver() 方法作用是返回指定的文件解析器，如果没有指定，则构造一个未指定的默认解析器。 1234567891011121314protected EntityResolver getEntityResolver() &#123; if (this.entityResolver == null) &#123; ResourceLoader resourceLoader = getResourceLoader();// 如果 ResourceLoader 不为 null，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver 对象 if (resourceLoader != null) &#123; this.entityResolver = new ResourceEntityResolver(resourceLoader); &#125;// 如果 ResourceLoader 为 null ，则创建 一个 DelegatingEntityResolver 对象。该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver else &#123; this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader()); &#125; &#125; return this.entityResolver;&#125; registerBeanDefinitions()获取 XML Document 对象后，会根据该对象和 Resource 资源对象调用 XmlBeanDefinitionReader.registerBeanDefinitions(Document doc, Resource resource) 方法，开始注册 BeanDefinitions 。 12345678910111213// XmlBeanDefinitionReader.java// 注册BeanDefinitionpublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; // &lt;1&gt; 创建 BeanDefinitionDocumentReader 对象 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // &lt;2&gt; 获取已注册的 BeanDefinition 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // &lt;3&gt; 创建 XmlReaderContext 对象 // &lt;4&gt; 注册 BeanDefinition documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // &lt;5&gt; 计算新注册的 BeanDefinition 数量 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 分析上述代码： 处，调用 createBeanDefinitionDocumentReader() 方法，实例化 BeanDefinitionDocumentReader 对象。 处，调用 BeanDefinitionRegistry.getBeanDefinitionCount() 方法，获取已注册的 BeanDefinition 数量。 处，调用 createReaderContext(Resource resource)方法，创建XmlReaderContext对象。 处，调用 BeanDefinitionDocumentReader.registerBeanDefinitions(Document doc, XmlReaderContext readerContext) 方法，读取 XML 元素，注册 BeanDefinition 。 处，计算新注册的 BeanDefinition 数量。 createBeanDefinitionDocumentReader()123protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123; return BeanUtils.instantiateClass(this.documentReaderClass);&#125; 其中，documentReaderClass 的默认值为 DefaultBeanDefinitionDocumentReader.class 。 BeanDefinitionDocumentReader.registerBeanDefinitions()DefaultBeanDefinitionDocumentReader 是 BeanDefinitionDocumentReader 接口的唯一默认实现类。 首先先来看下 BeanDefinitionDocumentReader 接口： 1234567// BeanDefinitionDocumentReader接口定义public interface BeanDefinitionDocumentReader &#123; void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) throws BeanDefinitionStoreException;&#125; 从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中。方法接收两个参数： doc：待解析的 Document 对象。 readerContext:解析器的当前上下文，包括目标注册表和被解析的资源。它是根据 Resource 来创建的。 接下来继续看下 DefaultBeanDefinitionDocumentReader 类，我们重点关注 registerBeanDefinitions() 方法： 1234567891011// org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader 类@Nullableprivate XmlReaderContext readerContext;@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; // 获得 XML Document Root Element // 执行注册 BeanDefinition doRegisterBeanDefinitions(doc.getDocumentElement());&#125; BeanDefinitionDocumentReader.doRegisterBeanDefinitions()12345678910111213141516171819202122232425262728293031323334353637protected void doRegisterBeanDefinitions(Element root) &#123; // 记录老的 BeanDefinitionParserDelegate 对象 BeanDefinitionParserDelegate parent = this.delegate; // &lt;1&gt; 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate this.delegate = createDelegate(getReaderContext(), root, parent); // &lt;2&gt; 检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) &#123; // &lt;2.1&gt; 处理 profile 属性。可参见《Spring3自定义环境配置 &lt;beans profile=""&gt;》http://nassir.iteye.com/blog/1535799 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; // &lt;2.2&gt; 使用分隔符切分，可能有多个 profile String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // &lt;2.3&gt; 如果所有 profile 都无效，则不进行注册 if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec + "] not matching: " + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125;// 解析前处理 preProcessXml(root);// 解析处理 parseBeanDefinitions(root, this.delegate);// 解析后处理 postProcessXml(root);// 设置 delegate 回老的 BeanDefinitionParserDelegate 对象 this.delegate = parent;&#125; 分析上面代码： 处，创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate 。BeanDefinitionParserDelegate 是一个重要的类，它负责解析 BeanDefinition 。 处，检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans。 &lt;2.1&gt;处，判断是否 &lt;beans /&gt; 上配置了 profile 属性。 &lt;2.2&gt;处，使用分隔符切分，可能有多个 profile。 &lt;2.3&gt;处，判断，如果所有 profile 都无效，则 return 不进行注册。 处，调用 parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) 方法，进行解析逻辑。 /处，解析前后的处理，目前这两个方法都是空实现，交由子类来实现。代码如下： 123protected void preProcessXml(Element root) &#123;&#125;protected void postProcessXml(Element root) &#123;&#125; 我们再重点看一下 parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) 的代码，如下： 12345678910111213141516171819202122232425protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // &lt;1&gt; 如果根节点使用默认命名空间，执行默认解析 if (delegate.isDefaultNamespace(root)) &#123; //遍历根节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; // &lt;1&gt; 如果该节点使用默认命名空间，执行默认解析 if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; // 如果该节点非默认命名空间，执行自定义解析 else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; // &lt;2&gt; 如果根节点非默认命名空间，执行自定义解析 else &#123; delegate.parseCustomElement(root); &#125;&#125; Spring 有两种 Bean 声明方式： 配置文件式声明： &lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot; /&gt; ，对应处。 自定义注解方式： &lt;tx:annotation-driven&gt; ,对应处。 处，如果根节点或子节点使用默认命名空间，调用 parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) 方法，执行默认解析。 处，如果根节点或子节点不使用默认命名空间，调用 BeanDefinitionParserDelegate.parseCustomElement(Element ele) 方法，执行自定义解析。 createReaderContextcreateReaderContext(Resource resource) 方法，创建 XmlReaderContext 对象。代码如下： 123456789101112131415// XmlBeanDefinitionReader.javaprivate ProblemReporter problemReporter = new FailFastProblemReporter();private ReaderEventListener eventListener = new EmptyReaderEventListener(); private SourceExtractor sourceExtractor = new NullSourceExtractor();@Nullableprivate NamespaceHandlerResolver namespaceHandlerResolver;//根据 Resource 创建 XmlReaderContextpublic XmlReaderContext createReaderContext(Resource resource) &#123; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver());&#125; 总结本文重点介绍了 XmlBeanDefinitionReader 类中的重点方法，涉及 Bean 在容器中的装载、注册过程，其中装载过程对应着 loadBeanDefinitions() 、 doLoadBeanDefinitions() 、 doLoadDocument() ，注册过程对应着 registerBeanDefinitions() 。下面是流程图： // todo 参考 【死磕 Spring】—— IoC 之加载 BeanDefinition 【死磕 Spring】—— IoC 之获取验证模型 【死磕 Spring】—— IoC 之获取 Document 对象 【死磕 Spring】—— IoC 之注册 BeanDefinitions]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring系列——IoC之Resource和ResourceLoader]]></title>
    <url>%2F2019%2F10%2F13%2FSpring%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94IoC%E4%B9%8BResource%E5%92%8CResourceLoader%2F</url>
    <content type="text"><![CDATA[Java SE中有一个标准类 java.net.URL，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道其实现基本只限于网络形式发布的资源的查找和定位。然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 java.net.URL 的局限性迫使Spring必须实现自己的资源加载策略，该资源加载策略需要满足如下要求： 职能划分清楚。资源的定义和资源的加载应该要有一个清晰的界限； 统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。 统一资源：Resource体系 Resource 接口org.springframework.core.io.Resource 为 Spring 框架所有资源的抽象和访问接口，它继承 org.springframework.core.io.InputStreamSource接口。作为所有资源的统一抽象，Resource 定义了一些通用的方法，由子类 AbstractResource 提供统一的默认实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Resource extends InputStreamSource &#123;// 判断资源是否存在 boolean exists();// 判断资源是否可读 default boolean isReadable() &#123; return exists(); &#125;// 资源是否已被打开 default boolean isOpen() &#123; return false; &#125;// 判断是否是文件 default boolean isFile() &#123; return false; &#125;// 返回资源的URL句柄 URL getURL() throws IOException;// 返回资源的URI句柄 URI getURI() throws IOException;// 返回资源的File句柄 File getFile() throws IOException;// 获取资源的可读字节管道 default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125;// 获取资源的内容长度 long contentLength() throws IOException;// 获取最后修改时间 long lastModified() throws IOException;// 根据资源的相对路径创建新资源 Resource createRelative(String relativePath) throws IOException;// 获取资源的文件名 @Nullable String getFilename();// 获取资源描述 String getDescription();&#125; 子接口：ContextResource和WritableResourceContextResource和WritableResource均是Resource的子接口，除拥有Resource的全部方法外，ContextResource接口还有下列方法： 12// 从关闭的上下文Context中获取资源的路径 String getPathWithinContext(); getPathWithContext() 方法返回相对于Context的路径，如ServletContext、PortletContext、classpath、FileSystem等，在Spring core中它有两个实现类FileSystemContextResource、ClassPathContextResource，分别是FileSystemResourceLoader和DefaultResourceLoader中的内部类，他们对getPathWithContext()方法的实现只是简单的返回path值。 另外，在Spring Web模块中，有一个ServletContextResource实现类，它使用ServletContext和path作为参数构造，getInputStream、getURL、getURI、getFile等方法中将实现代理给ServletContext，其中getPathWithContext方法依然返回path字符串。 WritableResource接口新增三个方法： 123456789101112// 判断是否可写,默认可写default boolean isWritable() &#123; return true;&#125;// 获取输出流OutputStream getOutputStream() throws IOException;// 获取写入字节管道default WritableByteChannel writableChannel() throws IOException &#123; return Channels.newChannel(getOutputStream());&#125; 因此WritableResource的实现类拥有了写资源的功能。 抽象类：AbstractResourceorg.springframework.core.io.AbstractResource ，为 Resource 接口的默认抽象实现。它实现了Resource接口的大部分的公共实现。当我们自定义资源时，只需继承AbstractResource抽象类，然后覆盖相应的方法即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public abstract class AbstractResource implements Resource &#123;// 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流 @Override public boolean exists() &#123; // Try file existence: can we find the file in the file system? if (isFile()) &#123; try &#123; return getFile().exists(); &#125; catch (IOException ex) &#123; Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug("Could not retrieve File for existence check of " + getDescription(), ex); &#125; &#125; &#125; // 产生异常,关闭输入流 try &#123; getInputStream().close(); return true; &#125; catch (Throwable ex) &#123; Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug("Could not retrieve InputStream for existence check of " + getDescription(), ex); &#125; return false; &#125; &#125;// 是否可读 @Override public boolean isReadable() &#123; return exists(); &#125;// 是否打开,返回false,未打开 @Override public boolean isOpen() &#123; return false; &#125;// 是否是文件,返回false,不是文件 @Override public boolean isFile() &#123; return false; &#125;// 抛出 FileNotFoundException 异常，交给子类实现 @Override public URL getURL() throws IOException &#123; throw new FileNotFoundException(getDescription() + " cannot be resolved to URL"); &#125;// 基于 getURL() 返回的 URL 构建 URI @Override public URI getURI() throws IOException &#123; URL url = getURL(); try &#123; //URL格式化后返回 return ResourceUtils.toURI(url); &#125; catch (URISyntaxException ex) &#123; throw new NestedIOException("Invalid URI [" + url + "]", ex); &#125; &#125;// 抛出 FileNotFoundException 异常，交给子类实现 @Override public File getFile() throws IOException &#123; throw new FileNotFoundException(getDescription() + " cannot be resolved to absolute file path"); &#125;// 根据 getInputStream() 的返回结果构建 ReadableByteChannel @Override public ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125;// 获取资源的长度// 资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断// 一般在子类中重写 @Override public long contentLength() throws IOException &#123; InputStream is = getInputStream(); try &#123; long size = 0;// 一次最多读取256字节 byte[] buf = new byte[256]; int read; while ((read = is.read(buf)) != -1) &#123; size += read; &#125; return size; &#125; finally &#123; try &#123; is.close(); &#125; catch (IOException ex) &#123; Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug("Could not close content-length InputStream for " + getDescription(), ex); &#125; &#125; &#125; &#125;// 返回资源最后修改时间 @Override public long lastModified() throws IOException &#123; File fileToCheck = getFileForLastModifiedCheck(); long lastModified = fileToCheck.lastModified(); if (lastModified == 0L &amp;&amp; !fileToCheck.exists()) &#123; throw new FileNotFoundException(getDescription() + " cannot be resolved in the file system for checking its last-modified timestamp"); &#125; return lastModified; &#125;// 交给子类重写// 子类没有实现则返回文件 protected File getFileForLastModifiedCheck() throws IOException &#123; return getFile(); &#125;// 抛出 FileNotFoundException 异常，交给子类实现 @Override public Resource createRelative(String relativePath) throws IOException &#123; throw new FileNotFoundException("Cannot create a relative resource for " + getDescription()); &#125;// 获取资源名称,默认返回null,交给子类实现 @Override @Nullable public String getFilename() &#123; return null; &#125; @Override public boolean equals(@Nullable Object other) &#123; return (this == other || (other instanceof Resource &amp;&amp; ((Resource) other).getDescription().equals(getDescription()))); &#125; @Override public int hashCode() &#123; return getDescription().hashCode(); &#125; @Override public String toString() &#123; return getDescription(); &#125;&#125; 抽象子类：AbstractFileResolvingResource这个抽象类继承自AbstractResource，重写了AbstractResource的大部分方法，主要作用是将URL解析为File引用，其具体实现的子类有 UrlResource 和 ClassPathResource 。 AbstractResource的实现子类从上面 Resource 体系图可知，AbstractResource 有多种实现类，分别对应着不同的资源。 ByteArrayResourceByteArrayResource是对二进制数组提供的数据的封装,每次调用getInputStream方法时都会以这个二进制数组作为源创建一个ByteArrayInputStream。 1234@Overridepublic InputStream getInputStream() throws IOException &#123; return new ByteArrayInputStream(this.byteArray);&#125; FileSystemResourceFileSystemResource是对 java.io.File 类型资源的封装，在构建FileSystemResource时可以传入File对象或路径字符串（这里的路径可以是相对路径，相对路径是相对于System.getProperty(“user.dir”)的值所在的路径，也可以是绝对路径，也可以是“file:”开头的路径值），实现 了WritableResource 接口。从 Spring Framework 5.0 开始，FileSystemResource 使用 NIO2 API进行读/写交互。 123456789101112131415@Overridepublic OutputStream getOutputStream() throws IOException &#123; return Files.newOutputStream(this.filePath);&#125;// 利用相对路径返回Resource对象,注意相对路径的计算方法// StringUtils.applyRelativePath()@Overridepublic Resource createRelative(String relativePath) &#123; String pathToUse = StringUtils.applyRelativePath(this.path, relativePath); return (this.file != null ? new FileSystemResource(pathToUse) : new FileSystemResource(this.filePath.getFileSystem(), pathToUse));&#125; UrlResourceUrlResource是对 URL和URI 类型资源的封装。 123456789101112131415161718192021//从URL中获取二进制输入流@Overridepublic InputStream getInputStream() throws IOException &#123; //使用URL.openConnection()方法获取URLConnection URLConnection con = this.url.openConnection(); //设置是否使用缓存 ResourceUtils.useCachesIfNecessary(con); try &#123; //获取二进制输入流 return con.getInputStream(); &#125; catch (IOException ex) &#123; // 如果打开了资源,需要关闭http连接 if (con instanceof HttpURLConnection) &#123; ((HttpURLConnection) con).disconnect(); &#125; throw ex; &#125;&#125; ClassPathResourceClassPathResource 是对 classpath 下资源的封装，资源从系统的类路径中加载。使用路径名、 ClassLoader 或者 Class 来创建资源。 123456789101112131415161718// 获取类路径下的资源的二进制流@Overridepublic InputStream getInputStream() throws IOException &#123; InputStream is; if (this.clazz != null) &#123; is = this.clazz.getResourceAsStream(this.path); &#125; else if (this.classLoader != null) &#123; is = this.classLoader.getResourceAsStream(this.path); &#125; else &#123; is = ClassLoader.getSystemResourceAsStream(this.path); &#125; if (is == null) &#123; throw new FileNotFoundException(getDescription() + " cannot be opened because it does not exist"); &#125; return is;&#125; InputStreamResourceInputStreamResource 是对 InputStream 的封装，接收 InputStream 作为构造方法参数，它的 isOpen 总是返回 true，并且只能被读取一次（即 getInputStream 方法只能被调用一次），exists、 isReadable 方法也总是返回 true。由于不能被多次读取，只有当不用多次读取的时候才使用该类，并且只有当没有其他可用 Resource 类时才使用该类。 12345678910//只能读取一次，读取多次时会抛出异常@Overridepublic InputStream getInputStream() throws IOException, IllegalStateException &#123; if (this.read) &#123; throw new IllegalStateException("InputStream has already been read - " + "do not use InputStreamResource if a stream needs to be read multiple times"); &#125; this.read = true; return this.inputStream;&#125; VfsResourceVfsResource 代表 Jboss 虚拟文件系统资源。Jboss VFS(Virtual File System) 框架是一个文件系统资源访问的抽象层，它能一致的访问物理文件系统、jar资源、zip资源、war资源等，VFS 能把这些资源一致的映射到一个目录上，访问它们就像访问物理文件资源一样，而其实这些资源不存在于物理文件系统。 DescriptiveResourceDescriptiveResource 是对非物理资源的 Description 的封装。它实现了 getDescription() 方法。Resource 中 Description 属性主要用于错误处理时能更加准确的打印出错位置的信息。DescriptiveResource 提供对那些需要提供 Resource 接口中的 Description 属性作为错误打印信息的方法自定义的描述信息。比如在 BeanDefinitionReader 中，在仅仅使用 InputSource 作为源加载 BeanDefinition 时，就可以使用 DescriptiveResource 定义自己的 Description，从而在出错信息中可以方便知道问题源的位置。 统一资源加载：ResourceLoader体系 ResourceLoader接口Spring 将资源的定义和资源的加载区分开，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。 org.springframework.core.io.ResourceLoader 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成。 1234567891011public interface ResourceLoader &#123; String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;// 根据路径返回资源 Resource getResource(String location);// 返回ClassLoader @Nullable ClassLoader getClassLoader();&#125; getResource(String location) 通过给定的 location 参数获取 Resource 实例，该实例可以是 ClassPathResource 、 FileSystemResource 、 UrlResource 等，但该方法返回的 Resource 实例并不能保证一定存在，必须通过 exists() 方法进行判断。该方法支持以下模式的资源加载： URL 位置资源，如 &quot;file:C:/test.dat&quot; 。 ClassPath 位置资源，如 &quot;classpath:test.dat 。 相对路径资源，如 &quot;WEB-INF/test.dat&quot; ，此时返回的 Resource 实例，根据实现不同而不同。 getClassLoader() 方法返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。 DefaultResourceLoader 类构造方法DefaultResourceLoader 类有两个构造方法： 不带参数的构造方法：使用的 ClassLoader 为默认的 ClassLoader（一般为Thread.currentThread().getContextClassLoader() ）。 带参数的构造方法：ClassLoader可以通过 ClassUtils.getDefaultClassLoader()获取。 123456789101112131415161718192021// 不带参数的构造方法public DefaultResourceLoader() &#123; this.classLoader = ClassUtils.getDefaultClassLoader();&#125;// 带参数的构造方法public DefaultResourceLoader(@Nullable ClassLoader classLoader) &#123; this.classLoader = classLoader;&#125;// 可自行设置ClassLoaderpublic void setClassLoader(@Nullable ClassLoader classLoader) &#123; this.classLoader = classLoader;&#125;@Override@Nullablepublic ClassLoader getClassLoader() &#123; return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());&#125; getResource 方法getResource 方法根据给定的 location 获得对应的资源，注意此方法返回的资源类型只有：ClassPathContextResource、ClassPathResource、FileUrlResource、 UrlResource。 123456789101112131415161718192021222324252627282930313233@Overridepublic Resource getResource(String location) &#123;Assert.notNull(location, "Location must not be null");// 首先，通过 ProtocolResolver 加载资源 for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123; Resource resource = protocolResolver.resolve(location, this); if (resource != null) &#123; return resource; &#125; &#125;// 其次，以 / 开头，返回 ClassPathContextResource 类型的资源 if (location.startsWith("/")) &#123; return getResourceByPath(location); &#125;// 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源 else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()),getClassLoader()); &#125;// 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源 else &#123; try &#123; // Try to parse the location as a URL... URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); &#125;// 最后，返回 ClassPathContextResource 类型的资源 catch (MalformedURLException ex) &#123; // No URL -&gt; resolve as resource path. return getResourceByPath(location); &#125; &#125;&#125; ProtocolResolverorg.springframework.core.io.ProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI：它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 AbstractResource 即可；而对ResourceLoader而言，有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口即可实现自定义的 ResourceLoader。 ProtocolResolver 接口，仅有一个方法 Resource resolve(String location, ResourceLoader resourceLoader) 。代码如下： 12345678910// 通过实现ProtocolResolver接口，可以实现自定义的 ResourceLoader@FunctionalInterfacepublic interface ProtocolResolver &#123;// 使用指定的 ResourceLoader ，解析指定的 location// 若成功，则返回对应的 Resource @Nullable Resource resolve(String location, ResourceLoader resourceLoader);&#125; 当自定义实现 ProtocolResolver 接口后，只需调用 DefaultResourceLoader.addProtocolResolver(ProtocolResolver) 方法即可将自定义的 Resolver 加入工作区。代码如下： 12345678// ProtocolResolver 集合 private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);// 将自定义实现的ProtocolResolver类加入工作区public void addProtocolResolver(ProtocolResolver resolver) &#123; Assert.notNull(resolver, "ProtocolResolver must not be null"); this.protocolResolvers.add(resolver);&#125; FileSystemResourceLoaderFileSystemResourceLoader 继承 DefaultResourceLoader ，且覆写了 getResourceByPath(String) 方法，使之从文件系统加载资源并以 FileSystemResource 类型返回。 12345678910@Overrideprotected Resource getResourceByPath(String path) &#123; if (path.startsWith("/")) &#123;// 截取字符串 path = path.substring(1); &#125;// 创建 FileSystemContextResource 类型的资源 return new FileSystemContextResource(path);&#125; FileSystemContextResource 内部类FileSystemContextResource ，为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource 类，实现 ContextResource 接口。该内部类出现的原因主要是实现 getPathWithinContext() 方法。代码如下： 123456789101112private static class FileSystemContextResource extends FileSystemResource implements ContextResource &#123; public FileSystemContextResource(String path) &#123;// 调用父类 FileSystemResource 构造方法 super(path); &#125; @Override public String getPathWithinContext() &#123; return getPath(); &#125;&#125; ClassRelativeResourceLoaderorg.springframework.core.io.ClassRelativeResourceLoader，是 DefaultResourceLoader 的另一个子类的实现。和 FileSystemResourceLoader 类似，在实现代码的结构上类似，也是覆写 getResourceByPath(String path) 方法，并返回其对应的 ClassRelativeContextResource 的资源类型。ClassRelativeResourceLoader 扩展的功能是可以根据给定的class所在包或者所在包的子包下加载资源。 ResourcePatternResolver 接口ResourceLoader 的 Resource getResource(String location) 方法，每次只能根据 location 返回一个 Resource 。当需要加载多个资源时，只能多次调用 getResource(String location) 方法。org.springframework.core.io.support.ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下： 123456789//支持根据指定的资源路径匹配模式每次返回多个 Resource 实例public interface ResourcePatternResolver extends ResourceLoader &#123;//新增了一种新的协议前缀 "classpath*:"，该协议前缀由其子类负责实现 String CLASSPATH_ALL_URL_PREFIX = "classpath*:"; Resource[] getResources(String locationPattern) throws IOException;&#125; PathMatchingResourcePatternResolver 类org.springframework.core.io.support.PathMatchingResourcePatternResolver 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 &quot;classpath*:&quot; 前缀外，还支持Ant风格的路径匹配模式（类似于 &quot;**/*.xml&quot;）。 123// 支持 Ant 类型的路径匹配private PathMatcher pathMatcher = new AntPathMatcher(); 构造方法PathMatchingResourcePatternResolver 类有三个构造方法： 12345678910111213141516 // PathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader public PathMatchingResourcePatternResolver() &#123; this.resourceLoader = new DefaultResourceLoader();&#125; public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) &#123; Assert.notNull(resourceLoader, "ResourceLoader must not be null"); this.resourceLoader = resourceLoader;&#125; public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) &#123; this.resourceLoader = new DefaultResourceLoader(classLoader);&#125; getResource12345678910// 委托给相应的 ResourceLoader 来实现// 未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是使用 DefaultResourceLoader 的过程public ResourceLoader getResourceLoader() &#123; return this.resourceLoader;&#125;@Overridepublic Resource getResource(String location) &#123; return getResourceLoader().getResource(location);&#125; getResources12345678910111213141516171819202122232425262728293031323334@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, "Location pattern must not be null");// 路径以 classpath* 开头: if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // a class path resource (multiple resources for same name possible)// 路径包含通配符 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125;// 路径不包含通配符 else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125;// 路径不以classpath*:开头 else &#123; // Generally only look for a pattern after a prefix here, // and on Tomcat only after the "*/" separator for its "war:" protocol. int prefixEnd = (locationPattern.startsWith("war:") ? locationPattern.indexOf("*/") + 1 : locationPattern.indexOf(':') + 1); // 路径包含通配符 if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; // 路径不包含通配符 else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 非 &quot;classpath*:&quot; 开头，且路径不包含通配符，直接委托给相应的 ResourceLoader 来实现。 其他情况，调用 findAllClassPathResources()或 findPathMatchingResources() 方法，返回多个 Resource 。 findAllClassPathResources当 locationPattern 以 &quot;classpath*:&quot; 开头但是不包含通配符，则调用 findAllClassPathResources() 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。 12345678910111213protected Resource[] findAllClassPathResources(String location) throws IOException &#123; String path = location; if (path.startsWith("/")) &#123; path = path.substring(1); &#125;// 调用doFindAllClassPathResources方法，真正执行加载所有 classpath 资源 Set&lt;Resource&gt; result = doFindAllClassPathResources(path); if (logger.isTraceEnabled()) &#123; logger.trace("Resolved classpath location [" + location + "] to resources " + result); &#125;// 返回Resource数组 return result.toArray(new Resource[0]);&#125; 真正执行加载的是在 doFindAllClassPathResources() 方法，代码如下： 1234567891011121314151617protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException &#123; Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); ClassLoader cl = getClassLoader(); // &lt;1&gt; 根据 ClassLoader 加载路径下的所有资源 Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path)); // &lt;2&gt; 遍历 URL 集合，调用 convertClassLoaderURL(URL url) 方法，将 URL 转换成 UrlResource 对象 while (resourceUrls.hasMoreElements()) &#123; URL url = resourceUrls.nextElement(); result.add(convertClassLoaderURL(url)); &#125; // &lt;3&gt; 加载路径下得所有 jar 包 if ("".equals(path)) &#123; addAllClassLoaderJarRoots(cl, result); &#125; return result;&#125; &lt;1&gt;处，根据 ClassLoader 加载路径下的所有资源。在加载资源过程时，如果在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader ，则调用该 ClassLoader 的 getResources() 方法，否则调用 ClassLoader.getSystemResources(path) 方法。ClassLoader.getResources() 方法代码如下: 如果当前父类加载器不为null，则通过父类向上迭代获取资源，否则调用 getBootstrapResources()。 123456789101112131415// java.lang.ClassLoader类public Enumeration&lt;URL&gt; getResources(String name) throws IOException &#123; @SuppressWarnings("unchecked") Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2]; if (parent != null) &#123; tmp[0] = parent.getResources(name); &#125; else &#123; tmp[0] = getBootstrapResources(name); &#125; tmp[1] = findResources(name); return new CompoundEnumeration&lt;&gt;(tmp);&#125; &lt;2&gt;处，遍历 URL 集合，调用 convertClassLoaderURL(URL url) 方法，将 URL 转换成 UrlResource 对象。 &lt;3&gt;处，若 path 为空时，则调用 addAllClassLoaderJarRoots 方法，该方法主要是加载路径下所有 jar 包。 由上述分析可知，findAllClassPathResources() 方法，其实就是利用 ClassLoader 来加载指定路径下的资源，不论它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 /，则会调用 addAllClassLoaderJarRoots() 方法，加载所有的 jar 包。 findPathMatchingResources当 locationPattern 中包含了通配符，则调用该方法进行资源加载。代码如下: 主要以下两个过程： 确定目录，获取该目录下得所有资源。 在所获得的所有资源后，进行迭代匹配获取我们想要的资源。 1234567891011121314151617181920212223242526272829303132333435363738//当 locationPattern 中包含了通配符，则调用该方法进行资源加载protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123;//确定根路径、子路径 String rootDirPath = determineRootDir(locationPattern); String subPattern = locationPattern.substring(rootDirPath.length());// 获取根据路径下的资源 Resource[] rootDirResources = getResources(rootDirPath);// 遍历、迭代 Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); URL rootDirUrl = rootDirResource.getURL(); // bundle 资源类型 if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith("bundle")) &#123; URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; // vfs 资源类型 if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; // jar 资源类型 else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; // 其他资源类型 else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace("Resolved location pattern [" + locationPattern + "] to resources " + result); &#125; return result.toArray(new Resource[0]);&#125; determineRootDirdetermineRootDir(String location) 方法，主要是用于确定根路径。代码如下: 123456789101112131415161718// 确定根路径protected String determineRootDir(String location) &#123; // 找到冒号的后一位 int prefixEnd = location.indexOf(':') + 1; // 根目录结束位置 int rootDirEnd = location.length(); // 在从冒号开始到最后的字符串中，循环判断是否包含通配符，如果包含，则截断最后一个由”/”分割的部分。 // 例如：在我们路径中，就是最后的ap?-context.xml这一段。再循环判断剩下的部分，直到剩下的路径中都不包含通配符。 while (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123; rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1; &#125; // 如果查找完成后，rootDirEnd = 0 了，则将之前赋值的 prefixEnd 的值赋给 rootDirEnd ，也就是冒号的后一位 if (rootDirEnd == 0) &#123; rootDirEnd = prefixEnd; &#125; // 截取根目录 return location.substring(0, rootDirEnd);&#125; 总结 Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其加载。使得资源与资源加载有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。 AbstractResource 为 Resource 的默认抽象实现，其对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 也需继承该类。 DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外，还可以实现 ProtocolResolver 接口来实现自定资源加载协议。 DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它不但实现了 Resource getResource(String location) 方法，也实现了 Resource[] getResources(String locationPattern) 方法。 参考 【死磕 Spring】—— IoC 之 Spring 统一资源加载策略 深入Spring IOC源码之Resource 深入Spring IOC源码之ResourceLoader Spring资源抽象Resource]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring系列——理解IoC]]></title>
    <url>%2F2019%2F10%2F07%2FSpring%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%90%86%E8%A7%A3IoC%2F</url>
    <content type="text"><![CDATA[Spring IoC概述IoC 全称为 Inversion of Control ，翻译为 “控制反转”。 如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题： 谁控制谁 控制什么 为何是反转 哪些方面反转 通过一个例子可以更方便理解IoC。假设一个人想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机和橙子，自己动手制作。值得注意的是：这个过程是自己“主动”创造的过程，也就是说一杯橙汁需要自己创造。这种方法就对应在程序代码中直接 new 一个橙汁对象，橙汁全程由自己制作管理。 然而到了今时今日，由于饮品店的盛行，当想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。在该过程中并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。这个过程饮品店相当于Spring容器，我们获取橙汁对象并不是自己在程序代码中 new 一个对象，而是直接在Spring容器（饮品店）直接获取，饮品店管理橙汁的制作过程。 现在在看上面那四个问题，答案就显得非常明显了: 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己代码中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转：所依赖对象的获取被反转。 注入方式IoC Service Provider为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入。 构造方法注入构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123Consumer(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice;&#125; setter方法注入对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下： 12345678public class Consumer &#123; private OrangeJuice orangeJuice; public void setOrangeJuice(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice; &#125;&#125; 相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前）， 接口注入接口方式注入带有侵入性，因为它需要被依赖的对象实现不必要的接口，一般都不推荐这种方式。 Spring 体系结构Resource 体系org.springframework.core.io.Resource 是对资源的抽象, 不同实现类代表了对不同资源的访问策略，如 ClassPathResource、RLResource、FileSystemResource 等。 ResourceLoader 体系有了资源，就应该有资源加载，Spring 利用org.springframework.core.io.ResourceLoader来进行统一资源加载，类图如下： BeanFactory 体系org.springframework.beans.factory.BeanFactory，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。 BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。 DefaultListableBeanFactory 为默认实现，它实现了所有接口。 BeanDefinition 体系org.springframework.beans.factory.config.BeanDefinition ，用来描述 Spring 中的 Bean 对象。 BeanDefinitionReader 体系org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。 ApplicationContext 体系org.springframework.context.ApplicationContext，它叫做应用上下文，是应用层容器。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。 继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。 扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。 对 Web 应用的支持。 总结本文主要介绍 IoC 的概念，以及 IoC 的三种注入方式，然后介绍了Spring的六大体系，包括Resource、ResourceLoader、BeanFactory、BeanDefinition、BeanDefinitionReader以及ApplicationContext，后续将详细介绍这些体系的相关源码。 参考 【死磕 Spring】—— IoC 之深入理解 Spring IoC]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈SPI机制]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%B5%85%E8%B0%88SPI%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SPI的概念面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。 SPI 全称为 Service Provider Interface ，是一种服务发现机制。 SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。 SPI对比API API: 概念上更接近实现方 组织上位于实现方所在的包中 实现和接口在一个包中 SPI: 概念上更依赖调用方 组织上位于调用方所在的包中 实现位于独立的包中（也可认为在提供方中） Java SPI在JDK6里面引进的一个新的特性 ServiceLoader，它主要是用来装载一系列的 service provider 。而且 ServiceLoader 可以通过 service provider 的配置文件来装载指定的 service provider 。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的 META-INF/services/ 目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包 META-INF/services/ 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 Java SPI 示例前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。 123public interface Robot &#123; void sayHello();&#125; 接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。 123456789101112131415public class OptimusPrime implements Robot &#123; @Override public void sayHello() &#123; System.out.println("Hello, I am Optimus Prime."); &#125;&#125;public class Bumblebee implements Robot &#123; @Override public void sayHello() &#123; System.out.println("Hello, I am Bumblebee."); &#125;&#125; 接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot 。文件内容为实现类的全限定的类名，如下： 12org.apache.spi.OptimusPrimeorg.apache.spi.Bumblebee 做好所需的准备工作，接下来编写代码进行测试。 123456789public class JavaSPITest &#123; @Test public void sayHello() throws Exception &#123; ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class); System.out.println("Java SPI"); serviceLoader.forEach(Robot::sayHello); &#125;&#125; 最后来看一下测试结果，从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。 DriverManager SPIDriverManager 是JDBC里管理和注册不同数据库driver的工具类。针对一个数据库 可能会存在着不同的数据库驱动实现，我们在使用特定的驱动实现时不希望修改现有的代码才能达到目的，而希望通过一个简单的配置就可以达到效果。比如，我们现在有一个数据库的驱动A，我们希望在程序里使用它而不修改代码。一种理想的选择就是我们将驱动A的信息加入到一个配置文件中，程序通过读取配置文件信息将A加载进来。而以后如果我们希望改用另外一个驱动B的时候，我们只需要将配置文件里的信息修改成驱动B即可。 我们在运用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 加载mysql驱动后，就会执行其中的静态代码把driver注册到 DriverManager 中，以便后续的使用。代码如下： 1234567891011121314package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;&#125; 这里可以看到，不同的驱动实现了相同的接口 java.sql.Driver ，然后通过 registerDriver 把当前driver加载到 DriverManager 中这就体现了使用方提供规则，提供方根据规则把自己加载到使用方中的SPI思想。查看 DriverManager 的源码，可以看到其内部的静态代码块中有一个 loadInitialDrivers 方法，在注释中我们看到用到了上文提到的SPI工具类 ServiceLoader 。 12345678/*** Load the initial JDBC drivers by checking the System property* jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism*/static &#123; loadInitialDrivers(); println("JDBC DriverManager initialized");&#125; 点进方法，看到方法里有如下代码： 123ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);Iterator&lt;Driver&gt; drivers = loadedDrivers.iterator();println("DriverManager.initialize: jdbc.drivers = " + loadedDrivers); 可见，DriverManager 初始化时也运用了SPI机制，使用 ServiceLoader 把写到配置文件里的 Driver 都加载了进来。我们打开 mysql-connector-java 的 jar 包，果然在 META-INF/services 下发现了上文中提到的接口路径，打开里面的内容，可以看到是 com.mysql.jdbc.Driver 。 Dubbo SPISPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader ，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo路径下，配置内容如下。 12optimusPrime = org.apache.spi.OptimusPrimebumblebee = org.apache.spi.Bumblebee 与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注@SPI注解。下面来演示 Dubbo SPI 的用法： 123456789101112public class DubboSPITest &#123; @Test public void sayHello() throws Exception &#123; ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class); Robot optimusPrime = extensionLoader.getExtension("optimusPrime"); optimusPrime.sayHello(); Robot bumblebee = extensionLoader.getExtension("bumblebee"); bumblebee.sayHello(); &#125;&#125; 测试结果如下： 总结本篇文章简单分别介绍了SPI机制的概念，以及Java SPI ，DriverManager SPI 与 Dubbo SPI 用法。 参考 Java SPI思想梳理 Dubbo SPI 设计原则：小议 SPI 和 API]]></content>
  </entry>
</search>
