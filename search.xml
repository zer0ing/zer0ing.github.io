<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[转载]一个西二旗码农的自白]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%BD%AC%E8%BD%BD-%E4%B8%80%E4%B8%AA%E8%A5%BF%E4%BA%8C%E6%97%97%E7%A0%81%E5%86%9C%E7%9A%84%E8%87%AA%E7%99%BD%2F</url>
    <content type="text"><![CDATA[凡不能毁灭我的，必使我强大。 ——尼采 朋友在 javaeye 老炮群转发寒门的状元一文时，我正从车水马龙的西二旗地铁站气喘吁吁地挤出来。北京这几天温度还不错，风不大，但没有太阳。我超级不喜欢地铁站门口的那个红绿灯。我扫开一辆摩拜，戴上手套，背好双肩包，骑车去上地三街。店里反馈有个订单系统掉单了，我微信给同事说查一下这个订单，同事回复说：“不可能。”我说人会犯错，机器是不会骗人的，于是看到了这篇文章。 我想起了王小波，他在《黄金时代》写过这样的句子：“那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。” 三次重锤：命运从来都不会手下留情看到这个句子是在高三的时候，我怎么也不会想到，一年之后，我 17 岁，刚上大一，就挨了生活的重重一锤：由于出鼻血不止我被送到 304 医院，医生确诊为再生障碍性贫血。这是个很严重的病，我的黄金时代还没有开始就落幕了，而我当时考虑最多的却是如何能活着看到 18 岁的阳光。 住院一年，春天，我和妈妈走在 304 的路上；夏天，我和妈妈走在协和的路上；秋天，我和妈妈走在人民医院的路上；冬天，我和妈妈走在 301 的路上；而爸爸，一直走在借钱的路上。 每隔两个月，爸爸就要请假来北京看我一次，送来治病的钱。我现在依然能够清晰地记得，爸爸离开医院要回家的场景。我去一楼送他，他背着两个大大的包，弓着背，穿过长长的走廊。走到门口的时候，一阵风吹过来，他突然一个趔趄，我的眼泪跟着就流了下来。 七年后那个早上，刚在办公室坐下打开电脑，生活的第二锤突如其来。我接到电话说：“你妈妈在海淀医院，赶快过来！”脑袋顿时一片空白，不知道自己是如何走出嘉华大厦的。当时正值初夏，外边的景色甚好，一片郁郁葱葱，连小鸟都在唱歌，而唯独我却看不到半点颜色听不到半点声响，整个世界顿时变成了黑白无声。 我生病后，妈妈就留在了北京打工，给别人做保姆。她从楼梯上摔下来了，腿部粉碎性骨折。没有保险也没有合同，事主只拿了 2 万块钱，我的爸爸又走在借钱的路上了。前脚爸爸刚把之前我住院的钱还得七七八八，把妹妹送上大学，如今就又被债务压得抬不起头来。妈妈在北京做完手术后，爸爸和大舅从老家背了块床板，坐了一天火车赶到北京，把妈妈抬回去了。这一年，我 24 岁。白银时代，不存在的。 2016 年的时候，爸爸来北京，我陪爸爸去拍登记照片，他要从教师岗位退休了。妹妹刚刚出国留学，爸爸赶上了年初老师普涨工资，家里总算不再负债。拍好照片我们去超市买了颗白菜，爸爸照旧是从我手里抢过去帮我提着菜，我感到一阵阵羞愧，三十多岁的人了还要父亲帮着提东西。那天依然是北京的雾霾天，太阳特别大，红彤彤地挂在半空，却没有半点光芒。一路无言。第二天，生活的第三锤就砸下来了，这次它直接把爸爸给砸没了，他出了车祸。 有时候，我常常觉得命运极其不公，每当生活稍微有点点起色，它就冲过来，狠狠地抽我两耳光，然后把我按在地上使劲摩擦。我想，我能活到现在，是因为总是能够碰到善良的人吧。 病痛时代：我不配拥有爱情！住院最无望的日子，血小板低到检测不到。站在外科楼 15 层的窗口，不止一次地想象纵身一跃的场景，一定像一只大鸟一样吧，只不过是被扯断翅膀的。赵海宁紧跟着我，他总是和我说：“我们还不能死对吧？我们还没女朋友呢。”赵海宁是从甘肃来京，当了两年的兵，和我是整个病房住院最长的二人组。我说，你不能说点别的吗，他眨眨眼睛，说：“我们还是处男啊。”年底的时候，我的病竟然慢慢地好起来，连高中暗恋的女同学在校友录看到我的消息都给我寄来了新年贺卡。赵海宁的情况却一天天坏下去。若干年后，在看《我不是药神》的时候，我的眼前不断浮现出他那因为吃激素而肥胖的脸，他不停地说着，我还没女朋友呢还没女朋友呢…… 回到大学复学后，每天还要去门诊部打针，在宿舍熬整栋楼都能闻到的中药。每三周去 304 复查，这种生活让我一天比一天厌恶起来。一天晚上，爸爸给我打电话，说我的一个高中女同学要了我的通信地址。于是，三天后我收到了她的来信，信中说，她高考的时候没有考好，只考取了专科，大一的时候她刻苦学习，获得了仅有的上华中师范本科的机会。 信的最后，她写道，我高中就喜欢你了，做我男朋友吧。你很难想象到一个自卑到尘埃里的男人看到这封信的感受，这个自卑的男人回信中写了自己生病的情况，信的最后一句话是，我不配。姑娘不再提男女朋友的事情，但是他们的通信却在随后 3 年以每周一封的频率固定下来。原有专业找工作变得渺茫，我想自学编程，她极力鼓励了我，不知道信中那些变量她是如何读懂的。 职场历练：工作让我重燃生活的希望毕业后我的第一份工作在亦庄，不是专业的软件公司，是在一家本地化公司做内部 IT 系统。拿到第一个月工资 3500 块钱的时候，我跑到电话超市里给爸爸打了很长时间的电话。他刚给读高中的妹妹送完饭回来，那天我们说了很多我都忘记了，我只记得我说：“爸，以后我的药费可以自己给了。” 如果说之前的苦难塑造了我这个人，那我工作中遇到的几位老大便成就了今天的我。好多计算机书籍都是在第一家公司的时候读的，那会儿公司不加班，我的老大把自己的图书卡借给我，鼓励我多读书，不要荒废时间。 第二家公司的老大不仅让我平日里多读一些源代码，他个人更是一个狂热的开源社区贡献者。在他的影响下，我通读了 Spring、WebWork、Hibernate 的代码。他写的代码一直影响着我，因为就算在 2001-2002 年没有使用框架的情况下，代码读起来竟然是那么愉快。 第三家公司是 ThoughtWorks。与之前的都不同，那里扁平化的管理方式，鼓励着我们每个人都去分享。在这里我和同事连续翻译了两本书，还写了一本书，而我也是第一次在《程序员》《软件世界》和 InfoQ 这些平台上发表文章。 后来，我来到了腾讯。在这儿，我发生了一个身份的转变，在我老大的鼓励下转成了一名产品经理。也在这里结识了好多清华北大的同事，身边同事都喜欢谈论和分享技术，总有问不完的问题。让我获益良多。 第五家公司是去哪儿。当时的老大是北大毕业的，思路特别特别清晰，对数字也特别敏感，一个问题能够一直刨到底，他有个特别的习惯就是总是会在凌晨 12 点问当天的数据并追查原因。 创业时代：失败才是人生常态后来我走上了创业的道路。拿到第一笔投资是在公司下边的咖啡厅。我的投资人是位干练的女士，整个过程似乎不能再简单，一人点了一杯咖啡，就把事情谈完了。我在腾讯时用业余时间做了一个应用，依靠口碑在几个互联网公司有了一些用户，朋友介绍她知道了，找过来，问了详细的数据和后续的发展思路，这个事情就敲定下来了。现在看过来，并不是我能力有多优秀，只不过是刚好赶上了时代的大潮而已。 很快，一年后，在寻找第二轮投资时，就立刻感到了市场的寒意，这时我也才真正理解到投资人反复给我讲的看大势。接触了很多投资人，其中也有好几位大佬。见面多在他们的会议室，无一例外，他们都思路清晰、对数字特别敏感，关心增长，没人说 VC，也没人说 PE，绿水鬼是个什么鬼，谁在意这个。 尽管我们最后还是找到了第二轮投资，但中间资金链断裂的两个月，再次让我深深地体会到了绝望。合伙人退出，同事离开。深夜的西二旗，只剩路灯和我！一圈又一圈地走在空无一人的街道上，整个世界好像都是我的，整个世界好像又都和我无关。 我很感激我的第一个投资人，是她让我体会和学习到很多之前接触不到的东西。当然，元旦时给她发消息时，发现她把我删除了。我的第一次创业最终还是失败了。 年中的时候，几个高中同学在北京聚了聚。大家聊了聊近况。曾婷这哥们是最晚到北京的，在火箭研究所做工程师。我们问了他之前在干什么，他说，在修车行修车啊。他高考进的大学并不好，大学毕业后没找到好工作，就去修车行修车。 “你们知道吗，那些配件有多重？那个冬天，天气非常冷，抬着一个配件，我的眼泪突然就流出来了你们知道吗？我一个大学毕业生，却在这里抬配件修车，我不服气啊！我最感激的人是我的老婆，那时候她已经到北京来了，却一直没有放弃我，鼓励我考研，干了一年修车行，我考上了华科研究生，然后才到北京找到了现在的工作。” 他给我们看了他老婆和孩子的照片，没有什么比一家人在一起更好的了。我想起了我另外一个同学，同样是高考没有考好，大学毕业后在广东做了两年协警，却始终没法转正，最后重新考了武汉大学的研究生，现在在一家上市公司做法务。 对我们这些人来说，读书真的是改变命运的唯一途径啊。要感谢这个时代，感谢我们的国家。曾婷说：“我突然强烈地感到，个人的奋斗固然重要，但个人的命运是完全和我们国家的命运紧密联系在一起的。”当然，感叹完了，我们又聊了聊我们班上的女同学。 奋斗依旧：愿做父亲一样的人现在，坐在上地三街的办公室，我打开我的电脑，检查订单那块的代码。7 年过去了，我重新开始写代码，只要愿意，我想一直写到退休都是没有问题的。很多年过去，尽管身份不断变化，但我还是更愿意把自己称为码农。我们是一个小公司，做了一个很小的应用，付费用户在不断增长。 人到中年，生活本来就是这个样子的，父母年龄渐长，孩子读书操心，哪个人不是用力在活着呢。每当工作生活中遇到挫折，我都会想起我的爸爸，他才是挨生活最重锤的人：年轻时教师发不出工资，他放学了去勤工俭学，包鱼塘贩橘子；等到教师工资归于财政，我又大病一场，2000 年的时候欠下 20 万；一个人在家拉扯妹妹长大，终于把钱还得七七八八，妈妈又摔断了腿；等得妈妈能走路了，妹妹也出国了，正要退休过一过清闲无负担的日子，他却走了。但是他却从来没有抱怨过生活，每次过年回家，他总是说：“什么时候到家，我去把头发染一下。” 我愿意做一个像父亲那样的人。泰山崩于前而色不变，无论生活给我开了多么大的玩笑，我都会伸手推开它的阻挠，坚定地向前走。 编后语：2018 年下半年，各种悲观的预期不断传来。股市低迷，融资困难，贸易争端前景难料，一些企业在酝酿着裁员，以应对即将到来的寒冬。到年底，一些公司陆陆续续真的开始主动减员。黑云压城城欲摧，在人们的心头，未来的不确定性陡然上升。恰好前些天，荣浩君发来这篇文章，讲述了自己过往的不幸与有幸。我们认识荣浩君有好些年了，他是我们的一个作者，因书结缘而相识。此前他从来没有对人讲起过这些。我们认识的他，是一个谦谦君子，平心静气，态度温和，从来没有见过他做出不悦的样子。他离开腾讯之后，就在创业，运营着一个农林特产的直销业务，虽然还够不上说风生水起，他却也兢兢业业，稳扎稳打，一步一个脚印地发展着。看过这篇文章，方知荣浩君之不易。就像他在文中说的，“常常觉得命运极其不公，每当生活稍微有点点起色，它就冲过来，狠狠地抽我两耳光，然后把我按在地上使劲摩擦”，可谓备尝生活之艰辛。然而他竟一桩一件地挺了过来，顽强地生存着。图灵君由此想到生活在帝都的许许多多的年轻人，他们走出校园，寻找工作，孤身漂泊在异乡的都市，任由昂贵的房租吞噬着菲薄的收入，依然勤勉地努力学习和工作，提升自己，捕捉机会。有的人可能也会遭遇类似或不类似的重锤打击，在他们原本艰难的生计里，再增添不堪的重负。人固能有置之死地而后生，而天断无绝人之路。无论如何艰难困苦，也要咬紧牙关挺过去。这是图灵君看完这篇文章最想跟大家说的。面对未知的2019，大家坚强些，再坚强些。就像荣浩君最后说的那样，“无论生活给我开了多么大的玩笑，我都会伸手推开它的阻挠，坚定地向前走。” 是的，风雨之后，彩虹会更加美丽，请把目光放远一点，越过眼前的沟沟坎坎，你生活的目标和意义尽在后头。 本文授权转载自图灵教育公众号]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题-190331]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%97%A0%E9%A2%98-190331%2F</url>
    <content type="text"><![CDATA[念念不忘，必有回响。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 内存管理与垃圾回收]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[最近在看《深入理解Java虚拟机：JVM高级特性与最佳实践》，对其中的重要知识点进行一个总结。 运行时的数据区 垃圾收集器Java内存的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就跟随着回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分的内存。 如何判断对象已死引用计数算法引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。当一个对象被创建时，将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加1（a=b，则b引用的对象实例的计数器加1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减1。任何引用计数为0的对象实例可以被当作垃圾收集。 引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题。 可达性分析算法可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种： 虚拟机栈(栈帧中的局部变量表)中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中Native方法引用的对象. 再谈引用Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。 垃圾收集算法标记-清除算法算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是使用可达性算法进行标记的。 主要缺点有两个： 效率问题，标记和清除两个过程的效率都不高 空间问题，标记清除之后会产生大量不连续的内存碎片 复制算法复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 标记-整理算法复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。 标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。 分代收集算法对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高JVM的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。 G1收集器G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。 G1把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入Region的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 每个Region都有一个Remembered Set，用来记录该Region对象的引用对象所在的Region。通过使用Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs的数据合并到 Remembered Set中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 内存分配与回收策略Minor GC 和 Full GC当这三个分代的堆空间比较紧张或者没有足够的空间来为新到的请求分配的时候，垃圾回收机制就会起作用。有两种类型的垃圾回收方式：次收集和全收集。当新生代堆空间满了的时候，会触发次收集将还存活的对象移到年老代堆空间。当年老代堆空间满了的时候，会触发一个覆盖全范围的对象堆的全收集。 Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。 内存分配策略 对象优先在Eden分配。大多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC。 大对象直接进入老年代。大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 长期存活的对象将进入老年代。为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 动态对象年龄判定。虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。 空间分配担保。在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。 类加载机制类加载过程类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）,7个阶段的发生顺序如下图所示。 类与类加载器类加载器的分类从Java虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分； 所有其他类的加载器，这些类由Java实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度看，类加载器有如下划分： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在&lt;JRE_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt;JAVA_HOME&gt;/lib/ext或者被java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序都是由三种类加载相互配合进行加载的，如有必要，可以加入自定义的类加载器。 下图展示了类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都最终应该传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会自己尝试去加载。 当然，大部分的类加载都遵循这个模型，但也有例外。 参考 《深入理解Java虚拟机：JVM高级特性与最佳实践》,周志明 《深入理解Java虚拟机》读书笔记]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统中的重要的协议]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E7%9A%84%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。 两阶段提交协议两阶段提交协议（Two-phase Commit,2PC）通常用来实现分布式事务。在该协议中，系统包含两类节点：一类为协调者，通常只有一个，另一类为事务参与者，一般包含多个。 在正常的执行过程中，两阶段提交协议包含以下两个过程： 阶段1：请求阶段。在请求阶段，协调者通知事务参与者准备提交或者取消事务，然后进入表决过程。在表决过程中，参与者告知协调者自己的决策：同意（事务本地执行成功）或者取消（事务本地执行失败）。 阶段2：提交阶段。在提交阶段，协调者基于第一阶段的投票结果进行决策：提交或者取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则通知所有参与者取消事务。参与者在接收到协调者的消息后执行相应操作。 二阶段提交协议看起来确实能够提供原子性的操作，但还是存在几个缺点： 同步阻塞问题。执行过程中，所有参与者都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。 单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题。） 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。 上述协议存在问题，在请求阶段，如果某一参与者迟迟不能回复，系统将一直处于等待状态，并且其他参与者持有的资源不能得到释放。不过协调者可以通过引入事务的超时机制防止资源一直不能得到释放的情况。但是若协调者出现故障，事务将被阻塞。故两阶段提交协议可能面临两种故障： 事务参与者发生故障。给每个事务设置超时时间，若参与者不能及时响应，整个事务失败。 协调者发生故障。协调者需要将事务相关信息记录到操作日志并同步到备用协调者，假如协调者发生故障，备用协调者可以接替完成后续工作。 总之，两阶段提交协议是阻塞协议，协议过程中需要锁住其它更新，且不能容错，并不适合高并发系统，大多数分布式系统都不采用，放弃对分布式事务的支持。 三阶段提交协议三阶段提交协议（Three-phase Commit，3PC）是对二阶段提交协议的改进，改动点如下： 引入超时机制。同时在协调者和参与者中都引入超时机制。 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。即3PC把2PC的准备阶段一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。 在DoCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ） 相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。 使用消息队列来避免分布式事务 Paxos协议Paxos协议用于解决多个节点之间的一致性问题。多个节点通过操作日志同步数据，如果只有一个节点为主节点，很容易确保多个节点之间操作日志的一致性。考虑主节点可能发生故障，系统需要选举新的主节点。Paxos协议正是用来实现此需求。只要保证多个节点之间操作日志的一致性，就能在这些节点上构建高可用的全局服务，例如分布式锁服务，全局命名和配置服务等。 为了实现高可用性，主节点把数据以操作日志的形式同步到备节点。若主节点发生故障，备节点会提议自己成为主节点。存在的一个问题是网络分区的时候，可能会存在多个备节点（Proposer,提议者）提议。Paxos协议保证，即使存在多个提议者，也能保证所有节点最终达成一致，即选举出唯一的主节点。 大多数情况下，系统只有一个提议节点，提议会很快被大多数节点接受。Paxos协议执行步骤如下： 批准（accept）：提议者发送accept消息要求其他所有节点接受某个提议值，其它节点可以接受或者拒绝。 确认（acknowledge）：如果超过一半的其它节点接受，意味着提议值生效，提议者发送确认消息通知所有的节点提议生效。 当网络或者其他异常时，系统中可能存在多个提议者，各自发起不同的提议。这里的提议可以是一个修改，也可以是自己成为主节点。如果提议者第一次发起的accept请求没有被其它节点的多数派批准，那么需要完整地执行一轮Paxos协议。过程如下: 准备（prepare）：Proposer首先选择一个提议序号n给其他的acceptor节点发送prepare消息。Acceptor收到prepare消息后，如果提议的序号大于其已经回复的所有prepare消息，则acceptor将自己上次接受的提议回复给proposer，并承诺不再回复小于n的提议。 批准（accept）：Proposer收到了acceptor中的多数派对prepare的回复后，就进入批准阶段。如果在之前的prepare阶段acceptor回复了上次接受的提议，那么proposer选择其中序号最大的提议值发给acceptor批准；否则，proposer生成一个新的提议值发给acceptor批准。Acceptor在不违背他之前在prepare阶段的承诺的前提下，接受这个请求。 确认（acknowledge）：如果超过一半的acceptor接受，提议值生效。Proposer发送knowledge消息通知所有的acceptor提议生效。 Paxos协议需要考虑两个问题：正确性，即只有一个提议值生效；可终止性，即最后总有一个提议值生效。 参考： 《大规模分布式存储系统：原理解析与架构实战》,杨传辉 关于分布式事务、两阶段提交协议、三阶提交协议 Paxos算法 分布式一致性算法——paxos]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库主键、外键、索引]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E3%80%81%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[主键表通常具有包含唯一标识表中每一行的值的一列或一组列。这样的一列或多列称为表的主键(PK)，用于强制表的实体完整性。由于主键约束可保证数据的唯一性，因此经常对标识列定义这种约束。 如果为表指定了主键约束，数据库引擎将通过为主键列自动创建唯一索引来强制数据的唯一性。当在查询中使用主键时，此索引还允许对数据进行快速访问。如果对多列定义了主键约束，则一列中的值可能会重复，但来自主键约束定义中所有列的值的任何组合必须唯一。 外键外键(FK)是用于在两个表中的数据之间建立和加强链接的一列或多列的组合，可控制可在外键表中存储的数据。在外键引用中，当包含一个表的主键值的一个或多个列被另一个表中的一个或多个列引用时，就在这两个表之间创建了链接。这个列就成为第二个表的外键。 互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展。 索引一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中，索引存储了指向表中某一行的指针。请记住记住这一点：索引是一种数据结构。 B-Tree是最常用的用于索引的数据结构。因为它们是时间复杂度低，查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。 哈希表是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高。但只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的，这就是为什么哈希索引通常不是数据库索引的默认数据结构-因为在作为索引的数据结构时，其不像B-Tree那么灵活。 主键、外键和索引的对比 主键 外键 索引 定义 唯一标识一条记录，不允许重复，不允许为空 表的外键是另一表的主键,外键可以重复, 可以为空 该字段没有重复值，但可以有一个空值 作用 保证数据完整性 和其他表建立联系 提高查询排序速度 个数 唯一 可以有多个外键 可以有多个唯一索引 参考： 数据库索引到底是什么，是怎样工作的？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界杯一二事]]></title>
    <url>%2F2018%2F07%2F16%2F%E4%B8%96%E7%95%8C%E6%9D%AF%E4%B8%80%E4%BA%8C%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[比赛前的选择昨天熬夜看球到2点，见证了法国夺冠。兴奋，满足，那种感觉就是你一直坚信一件事情的结果，而结局如你所愿。 世界杯开始前，微博有一个活动，pick你认为的今年的冠军。对一个伪足球迷而言，很难讲自己最喜欢哪只球队，德国，巴西，法国，阿根廷，西班牙，实力强的队伍太多了，各有各的特点，从某种意义上讲都有夺冠的机会。但是冠军只有一个，你的选择也只有一个。最终选择了法国，没有太多的理由，大概是年轻有潜力吧。既然选择了，就仿佛是认定了一般，开始了解法国队，开始关注法国的每一场比赛，关注某些球星的表现。最终，法国也确实没有让球迷失望，时隔20年再次捧起大力神杯。 选择需要理性，但有时候也存在着感性。法国队球员身价最高，年轻，然而缺少经验，这是一直不被大家看好的一点。但没有一支球队是完美的，何况完美的球队也不一定能夺得最终的冠军，竞技比赛充满太多未知性。但是在选择的那一刻，你认准一点或许就足够了，足够你做出一个选择。 直到有一天，世界杯成为记忆翻看微信公众号，突然就看到了杨毅先生的文章《直到有一天，世界杯成为记忆》，感触颇深。俄罗斯世界杯是我看的第三届世界杯，严格意义上我并不是足球迷，但是世界杯这样的体坛盛事，对每个热爱体育竞技的人都不容错过。很喜欢文中的几段话，“不夸张地说，对一个喜爱体育的男生来说，在一个更长的跨度里，没有什么能超过世界杯带来的仪式感。这是体育世界里最大的，最富有世界影响力的品牌，四年才一度。既体现它的稀有，又映衬着你生活里不同的时代。你会轻易地记起，哪一届世界杯你有多大，你正在经历什么。每一届时的你都截然不同，因为每一个四年都是你成长的刻度。” 的确，每一届世界杯都是一个阶段，世界杯结束一个阶段结束了。10年第一次看世界杯，那会儿刚初中毕业，印象最深的是德国阿根廷那场；14年在大学，凌晨4点和室友看德国巴西，以及自己一个人在车站附近网吧看了德国阿根廷；18年读研，在家看法国阿根廷，在宾馆看法国比利时，在寝室看法国克罗地亚。4年时间说长不长，但也不短，不知道还能看几届世界杯，只希望今后日子里心怀热情，但行好事，莫问前程。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》总结]]></title>
    <url>%2F2018%2F07%2F13%2F%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本书主要介绍了感知机、K近邻法、朴素贝叶斯法、决策树、Logistic回归与最大熵模型、支持向量机、提升方法、EM算法、隐马尔可夫模型、条件随机场。 各种统计学习方法特点总结表1 10种统计学习方法特点的概括总结 方法 适用问题 模型特点 模型类型 学习策略 学习的损失函数 学习算法 感知机 二类分类 分离超平面 判别模型 极小化误分点到超平面的距离 误分点到超平面的距离 随机梯度下降 k临近法 多类分类，回归 特征空间，样本点 判别模型 朴素贝叶斯法 多类分类 特征与类别的联合概率分布，条件独立假设 生成模型 极大似然估计，极大后验概率估计 对数似然损失 概率计算公式，EM算法 决策树 多类分类，回归 分类树，回归树 判别模型 正则化的极大似然估计 对数似然损失 特征选择，生成，剪枝 Logistic回归与最大熵模型 多类分类 特征条件下类别的条件概率分布，对数线性模型 判别模型 极大似然估计，正则化的极大似然估计 logistic损失 改进的迭代尺度算法，梯度下降，拟牛顿法 支持向量机 二类分类 分离超平面，核技巧 判别模型 极小化正则化合页损失，软间隔最大化 合页损失 序列最小最优化算法（SMO） 提升方法 二类分类 弱分类器的线性组合 判别模型 极小化加法模型的指数损失 指数损失 前向分步加法算法 EM算法 概率模型参数估计 含隐变量概率模型 极大似然估计，极大后验概率估计 对数似然损失 迭代算法 隐马尔可夫模型 标注 观测序列与状态序列的联合概率分布模型 生成模型 极大似然估计，极大后验概率估计 对数似然损失 概率计算公式，EM算法 条件随机场 标注 状态序列条件下观测序列的条件概率分布，对数线性模型 判别模型 极大似然估计，正则化极大似然估计 对数似然损失 改进的迭代尺度算法，梯度下降，拟牛顿法 Relevant Link 机器学习算法集锦：从贝叶斯到深度学习及各自优缺点 各种机器学习算法的应用场景分别是什么（比如朴素贝叶斯、决策树、K 近邻、SVM、逻辑回归最大熵模型）？ 感知机感知机（perceptron）是二类分类的线性分类模型，其输入为样本实例的特征向量，输出为实例的类别，是一种判别模型。感知机的目的是求出将训练数据进行线性划分的超平面，为此，导入基于误分类的损失函数，利用梯度下降法对损失函数进行最小化，以求得感知机模型。感知机学习算法具有简单易实现的优点，分为原始形式和对偶形式。 感知机模型与学习策略数据集的线性可分性存在一个超平面将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，则称该数据集线性可分。$2*w=12$ 感知机学习策略定义（经验）损失函数并将损失函数最小化，损失函数的一个自然选择是误分类的点数，但是这样的损失函数不是参数w，b的连续可导函数，不易优化。因此选择误分类点到超平面S的总距离。定义感知机 $ [sign(w*x+b)] $ 学习的损失函数为 感知机学习算法感知机学习问题转化为求解损失函数的最优化问题，最优化问题的方法是随机梯度下降法。首先，任意选取一个超平面，然后采用梯度下降法不断地极小化目标函数，极小化过程不是一次使所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。 感知机学习算法的原始形式算法的收敛性Novikoff定理表明误分类的次数是有上界的，经过有限次搜索可以找到将训练数据完全分开的分离超平面。感知机学习算法存在许多解，这些解既依赖于初值的选择，也依赖于迭代过程中误分类点的选择顺序。 感知机学习算法的对偶形式K近邻法K近邻法是一种基本分类与回归方法，K近邻法输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。分类时，对新的实例，根据其k个最邻近的训练实例的类别，通过多数表决方式进行预测。K近邻法不具有显式的学习过程，本质上是利用训练数据对特征向量空间进行划分，并作为其分类的“模型”。K值的选择、距离度量以及分类决策规则是K近邻法的三个基本要素。 K近邻模型距离度量采用不同的距离度量，如欧氏距离、Minkowski距离等，所确定的最近邻点也是不同的。 K值选择K值的选择影响近似误差和估计误差。K值一般选择一个比较小的数值，通常采用交叉验证法选取最优的K值。 分类决策规则多数表决。对数表决规则等价于经验风险最小化。 K近邻法的实现：kd树朴素贝叶斯朴素贝叶斯法是基于贝叶斯原理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布；然后基于此模型，对给定的输入x,利用贝叶斯原理求出后验概率最大的输出y。 朴素贝叶斯法的学习与分类朴素贝叶斯法的参数估计极大似然估计贝叶斯估计用极大似然估计可能会出现所要估计的概率值为0的情况，会影响后验概率的计算结果，使分类产生偏差。条件概率的贝叶斯估计如下：式中$[\lambda]$&gt;=0.等价于在随机变量各个取值的频数上赋予一个正数$[\lambda]$&gt;=0。当$[\lambda]$=0时就是极大似然估计。常取$[\lambda]$=1，此时称为拉普拉斯平滑。 决策树决策树模型与学习特征选择决策树的生成决策树的剪枝CART算法Logistic回归与最大熵模型Logistic回归模型最大熵模型模型学习的最优化算法支持向量机线性可分向量机与硬间隔最大化线性支持向量机与软间隔最大化非线性支持向量机与核函数序列最小最优化算法提升方法EM算法隐马尔科夫模型条件随机场值得思考的问题 各种机器学习算法的应用场景分别是什么（比如朴素贝叶斯、决策树、K 近邻、SVM、逻辑回归最大熵模型）？ 感知机（perceptron）和支持向量机（svm）是一种东西吗？如果不是那他们的区别和关系是什么？ 如何用简单易懂的例子解释格拉姆矩阵/Gram matrix？ 如何理解和区分近似误差和估计误差? 线性代数中，特征值与特征向量在代数和几何层面的实际意义是什么？ 最大似然估计和最小二乘法怎么理解？ 如何通俗易懂地解释「协方差」与「相关系数」的概念？ 为什么都说神经网络是个黑箱？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
