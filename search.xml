<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Spring】——深入理解IoC]]></title>
    <url>%2F2019%2F11%2F13%2F%E3%80%90Spring%E3%80%91%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3IoC%2F</url>
    <content type="text"><![CDATA[Spring IoC概述IoC 全称为 Inversion of Control ，翻译为 “控制反转”。 如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题： 谁控制谁 控制什么 为何是反转 哪些方面反转 通过一个例子可以更方便理解IoC。假设一个人想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机和橙子，自己动手制作。值得注意的是：这个过程是自己“主动”创造的过程，也就是说一杯橙汁需要自己创造。这种方法就对应在程序代码中直接 new 一个橙汁对象，橙汁全程由自己制作管理。 然而到了今时今日，由于饮品店的盛行，当想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。在该过程中并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。这个过程饮品店相当于Spring容器，我们获取橙汁对象并不是自己在程序代码中 new 一个对象，而是直接在Spring容器（饮品店）直接获取，饮品店管理橙汁的制作过程。 现在在看上面那四个问题，答案就显得非常明显了: 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己代码中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转：所依赖对象的获取被反转。 注入形式IoC Service Provider为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入。 构造方法注入构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123Consumer(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice;&#125; setter方法注入 对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下： 12345678public class Consumer &#123; private OrangeJuice orangeJuice; public void setOrangeJuice(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice; &#125;&#125; 相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前）， 接口注入 接口方式注入带有侵入性，因为它需要被依赖的对象实现不必要的接口，一般都不推荐这种方式。 Spring 体系结构Resource 体系org.springframework.core.io.Resource 是对资源的抽象, 不同实现类代表了对不同资源的访问策略，如 ClassPathResource、RLResource、FileSystemResource 等。 ResourceLoader 体系有了资源，就应该有资源加载，Spring 利用org.springframework.core.io.ResourceLoader来进行统一资源加载，类图如下： BeanFactory 体系org.springframework.beans.factory.BeanFactory，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。 BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。 DefaultListableBeanFactory 为默认实现，它实现了所有接口。 BeanDefinition 体系org.springframework.beans.factory.config.BeanDefinition ，用来描述 Spring 中的 Bean 对象。 BeanDefinitionReader 体系org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。 ApplicationContext 体系org.springframework.context.ApplicationContext，它叫做应用上下文，是应用层容器。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。 继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。 扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。 对 Web 应用的支持。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈SPI机制]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%B5%85%E8%B0%88SPI%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SPI的概念面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。 SPI 全称为Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。 SPI对比API API: 概念上更接近实现方 组织上位于实现方所在的包中 实现和接口在一个包中 SPI: 概念上更依赖调用方 组织上位于调用方所在的包中 实现位于独立的包中（也可认为在提供方中） Java SPI在JDK6里面引进的一个新的特性ServiceLoader，它主要是用来装载一系列的service provider。而且ServiceLoader可以通过service provider的配置文件来装载指定的service provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 Java SPI 示例前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。 123public interface Robot &#123; void sayHello();&#125; 接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。 123456789101112131415public class OptimusPrime implements Robot &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello, I am Optimus Prime.&quot;); &#125;&#125;public class Bumblebee implements Robot &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello, I am Bumblebee.&quot;); &#125;&#125; 接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下： 12org.apache.spi.OptimusPrimeorg.apache.spi.Bumblebee 做好所需的准备工作，接下来编写代码进行测试。 123456789public class JavaSPITest &#123; @Test public void sayHello() throws Exception &#123; ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class); System.out.println(&quot;Java SPI&quot;); serviceLoader.forEach(Robot::sayHello); &#125;&#125; 最后来看一下测试结果，从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。 DriverManagerDriverManager 是JDBC里管理和注册不同数据库driver的工具类。针对一个数据库 可能会存在着不同的数据库驱动实现，我们在使用特定的驱动实现时不希望修改现有的代码才能达到目的，而希望通过一个简单的配置就可以达到效果。比如，我们现在有一个数据库的驱动A，我们希望在程序里使用它而不修改代码。一种理想的选择就是我们将驱动A的信息加入到一个配置文件中，程序通过读取配置文件信息将A加载进来。而以后如果我们希望改用另外一个驱动B的时候，我们只需要将配置文件里的信息修改成驱动B即可。 我们在运用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;)加载mysql驱动后，就会执行其中的静态代码把driver注册到DriverManager中，以便后续的使用。代码如下： 1234567891011121314package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125;&#125; 这里可以看到，不同的驱动实现了相同的接口java.sql.Driver，然后通过registerDriver把当前driver加载到DriverManager中这就体现了使用方提供规则，提供方根据规则把自己加载到使用方中的SPI思想。查看DriverManager的源码，可以看到其内部的静态代码块中有一个loadInitialDrivers方法，在注释中我们看到用到了上文提到的SPI工具类ServiceLoader。 12345678/*** Load the initial JDBC drivers by checking the System property* jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism*/static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;);&#125; 点进方法，看到方法里有如下代码： 123ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);Iterator&lt;Driver&gt; drivers = loadedDrivers.iterator();println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + loadedDrivers); 可见，DriverManager初始化时也运用了SPI机制，使用ServiceLoader把写到配置文件里的Driver都加载了进来。我们打开mysql-connector-java的jar包，果然在META-INF/services下发现了上文中提到的接口路径，打开里面的内容，可以看到是com.mysql.jdbc.Driver。 Dubbo SPISPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo路径下，配置内容如下。 12optimusPrime = org.apache.spi.OptimusPrimebumblebee = org.apache.spi.Bumblebee 与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注@SPI注解。下面来演示 Dubbo SPI 的用法： 123456789101112public class DubboSPITest &#123; @Test public void sayHello() throws Exception &#123; ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class); Robot optimusPrime = extensionLoader.getExtension(&quot;optimusPrime&quot;); optimusPrime.sayHello(); Robot bumblebee = extensionLoader.getExtension(&quot;bumblebee&quot;); bumblebee.sayHello(); &#125;&#125; 测试结果如下： 总结本篇文章简单分别介绍了SPI机制的概念，以及Java SPI ，DriverManager SPI 与 Dubbo SPI 用法。 参考 Java SPI思想梳理 Dubbo SPI 设计原则：小议 SPI 和 API]]></content>
  </entry>
</search>
