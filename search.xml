<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈SPI机制]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%B5%85%E8%B0%88SPI%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SPI的概念面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。 SPI 全称为Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。 SPI对比API API: 概念上更接近实现方 组织上位于实现方所在的包中 实现和接口在一个包中 SPI: 概念上更依赖调用方 组织上位于调用方所在的包中 实现位于独立的包中（也可认为在提供方中） Java SPI在JDK6里面引进的一个新的特性ServiceLoader，它主要是用来装载一系列的service provider。而且ServiceLoader可以通过service provider的配置文件来装载指定的service provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 Java SPI 示例前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。 123public interface Robot &#123; void sayHello();&#125; 接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。 123456789101112131415public class OptimusPrime implements Robot &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello, I am Optimus Prime.&quot;); &#125;&#125;public class Bumblebee implements Robot &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello, I am Bumblebee.&quot;); &#125;&#125; 接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下： 12org.apache.spi.OptimusPrimeorg.apache.spi.Bumblebee 做好所需的准备工作，接下来编写代码进行测试。 123456789public class JavaSPITest &#123; @Test public void sayHello() throws Exception &#123; ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class); System.out.println(&quot;Java SPI&quot;); serviceLoader.forEach(Robot::sayHello); &#125;&#125; 最后来看一下测试结果，从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。 DriverManagerDriverManager 是JDBC里管理和注册不同数据库driver的工具类。针对一个数据库 可能会存在着不同的数据库驱动实现，我们在使用特定的驱动实现时不希望修改现有的代码才能达到目的，而希望通过一个简单的配置就可以达到效果。比如，我们现在有一个数据库的驱动A，我们希望在程序里使用它而不修改代码。一种理想的选择就是我们将驱动A的信息加入到一个配置文件中，程序通过读取配置文件信息将A加载进来。而以后如果我们希望改用另外一个驱动B的时候，我们只需要将配置文件里的信息修改成驱动B即可。 我们在运用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;)加载mysql驱动后，就会执行其中的静态代码把driver注册到DriverManager中，以便后续的使用。代码如下： 1234567891011121314package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125;&#125; 这里可以看到，不同的驱动实现了相同的接口java.sql.Driver，然后通过registerDriver把当前driver加载到DriverManager中这就体现了使用方提供规则，提供方根据规则把自己加载到使用方中的SPI思想。查看DriverManager的源码，可以看到其内部的静态代码块中有一个loadInitialDrivers方法，在注释中我们看到用到了上文提到的SPI工具类ServiceLoader。 12345678/*** Load the initial JDBC drivers by checking the System property* jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism*/static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;);&#125; 点进方法，看到方法里有如下代码： 123ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);Iterator&lt;Driver&gt; drivers = loadedDrivers.iterator();println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + loadedDrivers); 可见，DriverManager初始化时也运用了SPI机制，使用ServiceLoader把写到配置文件里的Driver都加载了进来。我们打开mysql-connector-java的jar包，果然在META-INF/services下发现了上文中提到的接口路径，打开里面的内容，可以看到是com.mysql.jdbc.Driver。 Dubbo SPISPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo路径下，配置内容如下。 12optimusPrime = org.apache.spi.OptimusPrimebumblebee = org.apache.spi.Bumblebee 与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注@SPI注解。下面来演示 Dubbo SPI 的用法： 123456789101112public class DubboSPITest &#123; @Test public void sayHello() throws Exception &#123; ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class); Robot optimusPrime = extensionLoader.getExtension(&quot;optimusPrime&quot;); optimusPrime.sayHello(); Robot bumblebee = extensionLoader.getExtension(&quot;bumblebee&quot;); bumblebee.sayHello(); &#125;&#125; 测试结果如下： 总结本篇文章简单分别介绍了SPI机制的概念，以及Java SPI ，DriverManager SPI 与 Dubbo SPI 用法。 参考 Java SPI思想梳理 Dubbo SPI 设计原则：小议 SPI 和 API]]></content>
  </entry>
</search>
