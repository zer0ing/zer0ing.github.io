[{"title":"深入分析 ThreadLocal","url":"http://yoursite.com/2020/03/28/深入分析ThreadLocal/","content":"<p>直接进入 ThreadLocal 源码。</p>\n<p>ThreadLocal 源码中有几个比较重要的方法：<code>get()</code>，<code>set()</code>，<code>remove()</code>，<code>initialValue()</code>，<code>setInitialValue()</code>。</p>\n<h4 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get 方法\"></a>get 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ThreadLocal.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 线程首先获取自身的 ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"comment\">// ThreadLocalMap 是位于 ThreadLocal 类的静态内部类</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 map 不是null，获取在 ThreadLocalMap 中 ThreadlLocal 对象作为 key 获取对应的值</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//  Entry 不为 null，则 Entry 中的值即为所访问的本线程对应的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回该 ThreadLocal 变量在该线程中对应值的初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先在当前线程中获取 ThreadLocalMap 对象（map 中 key 是 ThreadLocal 对象，value 则是设置的值）。如果 map 存在，则获取当前ThreadLocal 对象的值，并返回。如果 map 不存在，则从<code>setInitialValue()</code>  方法中获取。</p>\n<h4 id=\"setInitialValue-方法\"><a href=\"#setInitialValue-方法\" class=\"headerlink\" title=\"setInitialValue 方法\"></a>setInitialValue 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ThreadLocal.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">setInitialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// initialValue() 默认返回值为 null </span></span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `initialValue()` 方法在实际应用中被重写</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ThreadLocalMap 初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"set-方法\"><a href=\"#set-方法\" class=\"headerlink\" title=\"set 方法\"></a>set 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ThreadLocal.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取该线程的 ThreadLocalMap</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 调用 ThreadLocalMap.set() 方法</span></span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">//map</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>set()</code> 方法将 ThreadLocalMap 中该 ThreadLocal 对应的值设置为指定值。</p>\n<h4 id=\"remove-方法\"><a href=\"#remove-方法\" class=\"headerlink\" title=\"remove 方法\"></a>remove 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ThreadLocal.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用 ThreadLocalMap.remove() 方法</span></span><br><span class=\"line\">    m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h4><p>可以发现，ThreadLocal 中的 <code>set()</code> 和 <code>remove()</code> 方法都是借助 Thread LocalMap 的 <code>set()</code> 和 <code>remove()</code> 方法实现，下面具体看一下这些方法源码，并了解内存泄漏的问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ThreadLocal.ThreadLocalMap</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocalMap 是 ThreadLocal  中的一个静态内部类，默认容量为16，Map 的键是 ThreadLocal 对象，值是 Object 对象。ThreadLocalMap 维护着一个哈希表，即 Entry 数组，并且通过 <code>setThreshold()</code> 方法可知哈希表里存储的对象达到容量的 2/3 时就需要扩容。</p>\n<p>值得注意的是，ThreadLocalMap 的每个 Entry 的 key 是一个弱引用，从<code>super(k)</code> 可知。使用弱引用的原因是，当没有强引用指向 ThreadLocal 变量时，它可被回收，从而避免 ThreadLocal 不能被回收而造成的内存泄漏的问题。</p>\n<blockquote>\n<p>每个线程访问某 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLocal 变量与具体实例（value）的映射，如果不删除这些引用（映射），则这些 ThreadLocal 不能被回收，可能会造成内存泄漏。</p>\n</blockquote>\n<p>解决上述问题后，仍然存在问题，ThreadLocalMap 的 value 仍存在强引用，该映射的键变为 null，该 Entry 无法被移除，从而使得 value 被该 Entry 引用而无法被回收造成内存泄漏。 </p>\n<p>针对该问题，ThreadLocalMap 的 <code>set()</code> 方法中，通过 <code>replaceStaleEntry()</code> 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 <code>rehash()</code> 方法中通过 <code>expungeStaleEntry()</code> 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏。</p>\n<h5 id=\"set-方法-1\"><a href=\"#set-方法-1\" class=\"headerlink\" title=\"set 方法\"></a>set 方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ThreadLocal.ThreadLocalMap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// 根据 ThreadLocal 的 HashCode 得到对应的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 线性探测</span></span><br><span class=\"line\">    <span class=\"comment\">// 首先通过下标找对应的 Entry 对象，若不存在则创建一个新的 Entry 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 若存在，但 key 冲突或者 key 是 null，则将下标加一（加一后如果小于数组长度则使用该值，否则使用 0），</span></span><br><span class=\"line\">    <span class=\"comment\">// 再次尝试获取对应的 Entry，如果不为 null，则在循环中继续判断 key 是否重复或者 k 是否是 null</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i]; e != <span class=\"keyword\">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"comment\">// key相同则覆盖value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// key 被回收，为 null ，将 value 变为 null  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//用新元素替换陈旧的元素</span></span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// key不存在且value不存在，创建新的 Entry</span></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"comment\">// 长度加一</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// cleanSomeSlots 清理陈旧的 Entry（key == null）</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有清理陈旧的 Entry 并且数组中的元素大于阈值，则进行 rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">    \trehash();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>replaceStaleEntry()</code> 将所有 key 为 null 的 Entry 的 value 设置为 null ，从而使得 value 被回收。而在 <code>rehash()</code> 方法中， 通过<code>expungeStaleEntry()</code> 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。和 <code>cleanSomeSlots()</code>，这两个方法可以清除掉 key == null 的实例，防止内存泄漏。</p>\n<h5 id=\"replaceStaleEntry-方法\"><a href=\"#replaceStaleEntry-方法\" class=\"headerlink\" title=\"replaceStaleEntry 方法\"></a>replaceStaleEntry 方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Back up to check for prior stale entry in current run.</span></span><br><span class=\"line\">    <span class=\"comment\">// We clean out whole runs at a time to avoid continual</span></span><br><span class=\"line\">    <span class=\"comment\">// incremental rehashing due to garbage collector freeing</span></span><br><span class=\"line\">    <span class=\"comment\">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = prevIndex(i, len))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find either the key or trailing null slot of run, whichever</span></span><br><span class=\"line\">    <span class=\"comment\">// occurs first</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If we find key, then we need to swap it</span></span><br><span class=\"line\">        <span class=\"comment\">// with the stale entry to maintain hash table order.</span></span><br><span class=\"line\">        <span class=\"comment\">// The newly stale slot, or any other stale slot</span></span><br><span class=\"line\">        <span class=\"comment\">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class=\"line\">        <span class=\"comment\">// to remove or rehash all of the other entries in run.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">            tab[i] = tab[staleSlot];</span><br><span class=\"line\">            tab[staleSlot] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start expunge at preceding stale entry if it exists</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If we didn't find stale entry on backward scan, the</span></span><br><span class=\"line\">        <span class=\"comment\">// first stale entry seen while scanning for key is the</span></span><br><span class=\"line\">        <span class=\"comment\">// first still present in the run.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If key not found, put new entry in stale slot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If there are any other stale entries in run, expunge them</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ol>\n<li><a href=\"http://www.jasongj.com/java/threadlocal/\" target=\"_blank\" rel=\"noopener\">Java进阶（七）正确理解Thread Local的原理与适用场景</a></li>\n<li><a href=\"[https://juejin.im/post/5aeeb3e8518825672f19c52c#heading-0]\">Netty 高性能之道 FastThreadLocal 源码分析（快且安全）</a></li>\n</ol>\n","categories":["Java"],"tags":["Java"]},{"title":"深入分析 Synchronized","url":"http://yoursite.com/2020/03/12/深入分析Synchronized/","content":"<h3 id=\"Synchronized-用法\"><a href=\"#Synchronized-用法\" class=\"headerlink\" title=\"Synchronized 用法\"></a>Synchronized 用法</h3><p><code>Synchronized</code> 是 Java 提供的一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。</p>\n<p>通过编译可以发现，被 Synchronized 关键字修饰的同步块前后分别生成 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令。<code>monitorenter</code> 和 <code>monitorexit</code> 指令是对 <code>lock</code> 和 <code>unlock</code> 指令的高层次实现。</p>\n<p>这两个字节码指令都需要一个 <strong>引用类型的参数</strong> 来指明要锁定和解锁的对象。</p>\n<h4 id=\"lock-unlock-规则\"><a href=\"#lock-unlock-规则\" class=\"headerlink\" title=\"lock/unlock 规则\"></a>lock/unlock 规则</h4><ol>\n<li>一个变量同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一个线程执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才能被解锁。</li>\n<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值；</li>\n<li>如果一个变量没有被 lock 操作锁定，则不允许对其执行 unlock 操作，也不允许 unlock 一个其它线程锁定的变量；</li>\n<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中，即执行 store 和 write 操作。</li>\n</ol>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p><strong>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行</strong>。</p>\n<p>线程是 CPU 调度的基本单位。CPU 有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去 CPU 使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。原子性问题是由于<strong>时间片切换</strong>导致的。</p>\n<p>通过上述规则 1，即<strong>被 Synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到</strong>。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong>。</p>\n<p>Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程 A 改了某个变量的值，但是线程 B 不可见的情况。可见性问题是由于<strong>工作内存和主内存不一致</strong>导致的。</p>\n<p>通过上述介绍的规则 1、2、4可知，synchronized 关键字锁住的对象，其值是具有可见性的。</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p><strong>有序性即程序执行的顺序按照代码的先后顺序执行</strong>。</p>\n<p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU 还可能对输入代码进行乱序执行，比如 load-&gt;add-&gt;save 有可能被优化成 load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p>\n<p>这里需要注意的是，synchronized 是无法禁止指令重排和处理器优化的。也就是说，synchronized 无法避免上述提到的问题。那么，为什么还说 synchronized 也提供了有序性保证呢？<strong>如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</strong></p>\n<p><code>as-if-serial</code> 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守 <code>as-if-serial</code> 语义。</p>\n<p>再由于上述规则 1、3，同一时间只能被同一线程访问，那么也就是单线程执行的。所以，可以保证其有序性。</p>\n<h3 id=\"Synchronized的实现原理\"><a href=\"#Synchronized的实现原理\" class=\"headerlink\" title=\"Synchronized的实现原理\"></a>Synchronized的实现原理</h3><p>通过反编译可以发现：synchronized 同步代码块是使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，同步方法可以看到 <code>flags: ACC_SYNCHRONIZED</code> 字段，JVM 采用 ACC_SYNCHRONIZED 标记符来实现同步。</p>\n<p>无论是 <code>ACC_SYNCHRONIZED</code> 还是 <code>monitorenter</code>、<code>monitorexit</code> 都是基于 Monitor 实现的，在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++ 实现的，由 ObjectMonitor 实现。ObjectMonitor 类中提供了几个方法，如 <code>enter</code>、<code>exit</code>、<code>wait</code>、<code>notify</code>、<code>notifyAll</code>等。Sychronized 加锁的时候，会调用 objectMonitor 的 <code>enter</code> 方法，解锁的时候会调用 <code>exit</code> 方法。</p>\n<h4 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h4><p>方法级的同步是隐式的。同步方法的常量池中会有一个 <code>ACC_SYNCHRONIZED</code> 标志。当某个线程要访问某个方法的时候，会检查是否有 <code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，<strong>发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放</strong>。</p>\n<h4 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h4><p>同步代码块使用 <code>monitorenter</code> 和 <code>monitorexit</code> 两个指令实现。<code>monitorenter</code> 指令插入到同步代码块的开始位置，<code>monitorexit</code> 指令插入到同步代码块的结束位置，JVM 需要保证每一个 <code>monitorenter</code> 都有一个 <code>monitorexit</code> 与之相对应。</p>\n<p>我们通过 <code>javap</code> 命令反编译同步代码后，发现有两个 <code>monitorexit</code> 指令。原因是：为了保证抛异常的情况下也能释放锁，所以 <code>javac</code> 为同步代码块添加了一个隐式的 try-finally，在 finally 中会调用 <code>monitorexit</code> 命令释放锁。</p>\n<p><strong>每个对象维护着一个记录着被锁次数的计数器</strong>。未被锁定的对象的该计数器为0，当一个线程获得锁（执行 <code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行 <code>monitorexit</code> 指令）的时候，计数器再自减。当计数器为 0 的时候。锁将被释放，其他线程便可以获得锁。</p>\n<h3 id=\"Java-对象模型\"><a href=\"#Java-对象模型\" class=\"headerlink\" title=\"Java 对象模型\"></a>Java 对象模型</h3><p>Java 对象保存在堆内存中。在内存中，一个 Java 对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有的锁等标志。</p>\n<h4 id=\"OOP-Klass-Model\"><a href=\"#OOP-Klass-Model\" class=\"headerlink\" title=\"OOP-Klass Model\"></a>OOP-Klass Model</h4><p>HotSpot 是基于 C++ 实现，C++ 具备面向对象基本特征的，所以 Java 中的对象表示，最简单的做法是为每个 Java 类生成一个 C++ 类与之对应。</p>\n<p>HotSpot JVM 没有根据 Java 实例对象直接通过虚拟机映射到新建的 C++ 对象，而是设计了一个 <strong>OOP-Klass Model</strong>。OOP 指的是 Ordinary Object Pointer（普通对象指针），用来<strong>表示对象的实例信息</strong>；而 Klass 则包含元数据和方法信息，用来<strong>描述 Java 类</strong>。</p>\n<p>为什么 HotSpot 要设计 OOP-Klass Model 呢？答案是：HotSopt JVM 的设计者不想让每个对象中都含有一个 virtual table（虚函数表），所以就把对象模型拆成 Klass 和 OOP，其中 OOP 中不含有任何虚函数，而 Klass 就含有虚函数表。</p>\n<blockquote>\n<p>为了实现 C++ 的多态，C++ 使用了一种动态绑定的技术，这个技术的核心是虚函数表。虚函数表属于类，然后类的所有对象通过虚函数表指针共享类的虚函数表。虚函数表的作用是当使用父类指针来操作子类对象时，虚函数表可以指明实际所应该调用的函数。</p>\n</blockquote>\n<h4 id=\"OOP-体系\"><a href=\"#OOP-体系\" class=\"headerlink\" title=\"OOP 体系\"></a>OOP 体系</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义了oops共同基类</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">oopDesc</span>*                            <span class=\"title\">oop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示一个Java类型实例</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">instanceOopDesc</span>*            <span class=\"title\">instanceOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示一个Java方法</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodOopDesc</span>*                    <span class=\"title\">methodOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示一个Java方法中的不变信息</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constMethodOopDesc</span>*            <span class=\"title\">constMethodOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//记录性能信息的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodDataOopDesc</span>*            <span class=\"title\">methodDataOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//定义了数组OOPS的抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">arrayOopDesc</span>*                    <span class=\"title\">arrayOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示持有一个OOPS数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">objArrayOopDesc</span>*            <span class=\"title\">objArrayOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示容纳基本类型的数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">typeArrayOopDesc</span>*            <span class=\"title\">typeArrayOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示在Class文件中描述的常量池</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolOopDesc</span>*            <span class=\"title\">constantPoolOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//常量池缓存</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolCacheOopDesc</span>*   <span class=\"title\">constantPoolCacheOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//描述一个与Java类对等的C++类</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">klassOopDesc</span>*                    <span class=\"title\">klassOop</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示对象头</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">markOopDesc</span>*                    <span class=\"title\">markOop</span>;</span></span><br></pre></td></tr></table></figure>\n<p>上面列出的是整个 OOP 模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的 OOP 都代表一个在 JVM 内部使用的特定对象的类型。</p>\n<p>第一个变量 oop 的类型是 oppDesc ，其是OOPS 类的共同基类型。除此之外，还有很多 instanceOopDesc、arrayOopDesc 等类型的实例，都是 oopDesc 的子类。</p>\n<img src=\"/2020/03/12/深入分析Synchronized/OOP结构.png\">\n<p>这些模块在 JVM 内部有着不同的用途，例如，<code>instanceOopDesc</code> 表示类实例，<code>arrayOopDesc</code> 表示数组。也就是说，当我们使用 <code>new</code> 创建一个 Java 对象实例的时候，JVM 会创建一个 <code>instanceOopDesc</code> 对象来表示这个 Java 对象。同理，当我们使用 <code>new</code> 创建一个 Java 数组实例的时候，JVM 会创建一个 <code>arrayOopDesc</code> 对象来表示这个数组对象。</p>\n<h5 id=\"oopDesc\"><a href=\"#oopDesc\" class=\"headerlink\" title=\"oopDesc\"></a>oopDesc</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VMStructs</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">volatile</span> markOop  _mark;</span><br><span class=\"line\">      <span class=\"keyword\">union</span> _metadata &#123;</span><br><span class=\"line\">        wideKlassOop    _klass;</span><br><span class=\"line\">        narrowOop       _compressed_klass;</span><br><span class=\"line\">      &#125; _metadata;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// field addresses in oop</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span>*     <span class=\"title\">field_base</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>        <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">jbyte*    <span class=\"title\">byte_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>   <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jchar*    <span class=\"title\">char_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>   <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jboolean* <span class=\"title\">bool_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>   <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jint*     <span class=\"title\">int_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>    <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jshort*   <span class=\"title\">short_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>  <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jlong*    <span class=\"title\">long_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>   <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jfloat*   <span class=\"title\">float_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span>  <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">jdouble*  <span class=\"title\">double_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">      <span class=\"function\">address*  <span class=\"title\">address_field_addr</span><span class=\"params\">(<span class=\"keyword\">int</span> offset)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在虚拟机内部，一个 Java 对象对应一个 <code>instanceOopDesc</code> 的对象。再来看一下 instanceOopDesc 源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">instanceOopDesc</span> :</span> <span class=\"keyword\">public</span> oopDesc &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的源码，可知 HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。其中<strong>对象头包含了两部分内容：<code>_mark</code> 和 <code>_metadata</code></strong> ，而实例数据则保存在 oopDesc 中定义的各种 <code>field</code> 中。</p>\n<img src=\"/2020/03/12/深入分析Synchronized/Java对象模型.jpg\">\n<ul>\n<li><strong>_mark</strong>：<code>instanceOopDesc</code> 中的 <code>_mark</code> 成员，允许压缩。它用于存储对象的运行时记录信息，如哈希值、GC 分代年龄(Age)、锁状态标志（偏向锁、轻量级锁、重量级锁）、线程持有的锁、偏向线程 ID、偏向时间戳等。</li>\n<li><strong>_metadata</strong>：<code>_metadata</code> 是一个共用体，其中 <code>_klass</code> 是普通指针，<code>_compressed_klass</code>  是压缩类指针。这两个指针都指向 <code>instanceKlass</code> 对象，它用来描述对象的具体类型。</li>\n<li><strong>实例数据</strong>：实例数据就是在程序代码中所定义的各种类型的字段，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中定义顺序的影响。</li>\n<li><strong>对齐填充</strong>：由于 HotSpot 的自动内存管理要求对象的起始地址必须是 8 字节的整数倍，即对象的大小必须是 8 字节的整数倍，对象头的数据正好是 8 的整数倍，所以当实例数据不够 8 字节整数倍时，需要通过对齐填充进行补全。</li>\n<li>数组长度：只有数组对象包含此部分。</li>\n</ul>\n<h4 id=\"Klass体系\"><a href=\"#Klass体系\" class=\"headerlink\" title=\"Klass体系\"></a>Klass体系</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//klassOop的一部分，用来描述语言层的类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Klass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//在虚拟机层面描述一个Java类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">instanceKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//专有instantKlass，表示java.lang.Class的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">instanceMirrorKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//专有instantKlass，表示java.lang.ref.Reference的子类的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">instanceRefKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示methodOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示constMethodOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constMethodKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示methodDataOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodDataKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//最为klass链的端点，klassKlass的Klass就是它自身</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">klassKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示instanceKlass的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">instanceKlassKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示arrayKlass的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">arrayKlassKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示objArrayKlass的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>       <span class=\"title\">objArrayKlassKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示typeArrayKlass的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>       <span class=\"title\">typeArrayKlassKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示array类型的抽象基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">arrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示objArrayOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">objArrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示typeArrayOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">typeArrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示constantPoolOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolKlass</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//表示constantPoolCacheOop的Klass</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolCacheKlass</span>;</span></span><br></pre></td></tr></table></figure>\n<p>和 <code>oopDesc</code> 是其他 OOP 类型的父类一样，Klass 类是其他 Klass 类型的父类。</p>\n<img src=\"/2020/03/12/深入分析Synchronized/klass.png\">\n<p>Klass 向 JVM 提供两个功能：</p>\n<ul>\n<li>实现语言层面的 Java 类（在 Klass 基类中已经实现）;</li>\n<li>实现 Java 对象的分发功能（由 Klass 的子类提供虚函数实现）。</li>\n</ul>\n<p>总之，HotSopt JVM 的设计者把对象一拆为二，分为 Klass 和 OOP，其中 OOP 的职能主要在于<strong>表示对象的实例数据</strong>，所以其中不含有任何虚函数。而 Klass 为了<strong>实现虚函数多态</strong>，所以提供了虚函数表。（这样避免了每个对象中都含有一个虚函数表）</p>\n<h4 id=\"instanceKlass\"><a href=\"#instanceKlass\" class=\"headerlink\" title=\"instanceKlass\"></a>instanceKlass</h4><p>JVM 在运行时，需要一种用来标识 Java 内部类型的机制。在 HotSpot 中的解决方案是：<strong>为每一个已加载的 Java 类创建一个 <code>instanceKlass</code> 对象，用来在 JVM 层面表示 Java 类</strong>。<code>instanceKlass</code> 内部结构如下，从中可以看出，一个类含有的东西，其内部都包含有对应内容。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类拥有的方法列表</span></span><br><span class=\"line\"> objArrayOop     _methods;</span><br><span class=\"line\"> <span class=\"comment\">//描述方法顺序</span></span><br><span class=\"line\"> typeArrayOop    _method_ordering;</span><br><span class=\"line\"> <span class=\"comment\">//实现的接口</span></span><br><span class=\"line\"> objArrayOop     _local_interfaces;</span><br><span class=\"line\"> <span class=\"comment\">//继承的接口</span></span><br><span class=\"line\"> objArrayOop     _transitive_interfaces;</span><br><span class=\"line\"> <span class=\"comment\">//域</span></span><br><span class=\"line\"> typeArrayOop    _fields;</span><br><span class=\"line\"> <span class=\"comment\">//常量</span></span><br><span class=\"line\"> constantPoolOop _constants;</span><br><span class=\"line\"> <span class=\"comment\">//类加载器</span></span><br><span class=\"line\"> oop             _class_loader;</span><br><span class=\"line\"> <span class=\"comment\">//protected域</span></span><br><span class=\"line\"> oop             _protection_domain;</span><br><span class=\"line\">     ....</span><br></pre></td></tr></table></figure></p>\n<p>（<strong>重点理解</strong>）在 JVM 中，对象在内存中的基本存在形式就是 Oop。那么，对象所属的类，在 JVM 中也是一种对象，因此它们实际上也会被组织成一种 Oop，即 klassOop。同样的，对于 <code>klassOop</code>，也有对应的一个 klass 来描述，它就是 <code>klassKlass</code>，也是 klass 的一个子类。<code>klassKlass</code> 作为 oop 的 klass 链的端点。关于对象和数组的 klass 链大致如下图：</p>\n<img src=\"/2020/03/12/深入分析Synchronized/klass链.jpg\">\n<p>在这种设计下，JVM 对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass 关系如图：</p>\n<img src=\"/2020/03/12/深入分析Synchronized/oop-klass-klassKlass关系.png\">\n<h4 id=\"内存存储\"><a href=\"#内存存储\" class=\"headerlink\" title=\"内存存储\"></a>内存存储</h4><blockquote>\n<p>元数据—— <code>instanceKlass</code> 对象会存在元空间（方法区），而对象实例—— <code>instanceOopDesc</code> 会存在 Java 堆，Java 虚拟机栈中会存有这个对象实例的引用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Model</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Model</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">10</span>;</span><br><span class=\"line\">    Model modelA = <span class=\"keyword\">new</span> Model(<span class=\"number\">2</span>);</span><br><span class=\"line\">    Model modelB = <span class=\"keyword\">new</span> Model(<span class=\"number\">3</span>);&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2020/03/12/深入分析Synchronized/实例存储结构.jpeg\">\n<p>从上图中可以看到，在方法区的 <code>instantKlass</code> 中有一个 <code>int a=1</code> 的数据存储。在堆内存中的两个对象的oop中，分别维护着 <code>int b=3,int b=2</code> 的实例数据。和 <code>oopDesc</code> 一样，instantKlass也维护着一些 <code>fields</code>，用来保存类中定义的类数据，比如<code>int a=1</code>。</p>\n<p>问题：JVM 中，InstanceKlass、java.lang.Class 的关系？<br>ClassFileParser 将 class 文件在 runtime 解析成一个个 InstanceKlass 对象，这个对象是静态字节码文件在运行时 Metaspace 空间的一个映射。Java支持反射，为了能在 Java 层实现对定义类型的解构，JVM 实现了 InstanceKlass 的一个 java mirror 的概念—— java.lang.Class 对象。<br>InstanceKlass类继承自Klass类，在Klass类中有一个成员变量，并且提供了相应的Setter/Getter函数实现：</p>\n<p>在 java.lang.Class 类中，也提供了 Class 对象与 Klass 对象的转化函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Klass* <span class=\"title\">as_Klass</span><span class=\"params\">(oop java_class)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">set_klass</span><span class=\"params\">(oop java_class, Klass* klass)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Class 类所提供的反射机制，最终都是通过 JNI 接口，调用相应的 native 方法，然后通过 as_Klass 函数转换成 InstanceKlass 对象，得到定义类型的元数据信息。</p>\n<h4 id=\"JDK-1-8-变化部分\"><a href=\"#JDK-1-8-变化部分\" class=\"headerlink\" title=\"JDK 1.8 变化部分\"></a>JDK 1.8 变化部分</h4><p>注意，由于 Java 8 引入了元空间（Metaspace），OpenJDK 1.8 里对象模型的实现与 1.7 有很大的不同。原先存于永久代的类信息移至元空间，因此它们的 C++ 类型都继承于 <code>MetaspaceObj</code> 类(定义见 <code>vm/memory/allocation.hpp</code>)，表示元空间的数据。</p>\n<p>OOP 体系也发生变化，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span>* <span class=\"title\">oop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">instanceOopDesc</span>* <span class=\"title\">instanceOop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">arrayOopDesc</span>* <span class=\"title\">arrayOop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">objArrayOopDesc</span>* <span class=\"title\">objArrayOop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">typeArrayOopDesc</span>* <span class=\"title\">typeArrayOop</span>;</span></span><br></pre></td></tr></table></figure>\n<p> MetaspaceObj 体系如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The metadata hierarchy is separate from the oop hierarchy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class MetaspaceObj</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstMethod</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstantPoolCache</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodData</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// class Metadata</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Method</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConstantPool</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// class CHeapObj</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompiledICHolder</span>;</span></span><br></pre></td></tr></table></figure>\n<p>Klass 体系：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The klass hierarchy is separate from the oop hierarchy.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Klass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InstanceKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InstanceMirrorKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InstanceClassLoaderKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InstanceRefKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjArrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TypeArrayKlass</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>注意 <strong>Klass 代表元数据，继承自 Metadata 类</strong>，因此像 Method、ConstantPool 都会以成员变量（或指针）的形式存在于 Klass 体系中。<br>以下是 JDK 1.7 中的类在 JDK 1.8 中的存在形式：</p>\n<ul>\n<li>klassOop -&gt; Klass*</li>\n<li>klassKlass 不再需要</li>\n<li>methodOop -&gt; Method*</li>\n<li>methodDataOop -&gt; MethodData*</li>\n<li>constMethodOop -&gt; ConstMethod*</li>\n<li>constantPoolOop -&gt; ConstantPool*</li>\n<li>constantPoolCacheOop -&gt; ConstantPoolCache*</li>\n</ul>\n<p>其中，Klass 对象的继承关系：xxxKlass &lt;:&lt; Klass &lt;:&lt; Metadata &lt;:&lt; MetaspaceObj。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>执行 <code>new A()</code> 的时候，JVM native 层里会发生什么。首先，如果这个类没有被加载过，JVM 就会进行类的加载，并在 JVM 内部创建一个 <code>instanceKlass</code> 对象表示这个类的运行时元数据（相当于 Java 层的 Class 对象）。到初始化的时候（执行 <code>invokespecial A::&lt;init&gt;</code>），JVM 就会创建一个 <code>instanceOopDesc</code> 对象表示这个对象的实例，然后进行 Mark Word 的填充，将元数据指针指向 Klass 对象，并填充实例变量。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ol>\n<li><a href=\"https://www.hollischuang.com/archives/1910\" target=\"_blank\" rel=\"noopener\">深入理解多线程（二）—— Java的对象模型</a></li>\n<li><a href=\"https://www.sczyh30.com/posts/Java/jvm-klass-oop/\" target=\"_blank\" rel=\"noopener\">深入探究 JVM | klass-oop对象模型研究</a></li>\n</ol>\n<h3 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h3><p>oopDesc 中的 <code>_mark</code> 和 <code>_metadata</code> 其实就是对象头的定义。<code>-metadata</code>前面已经做过介绍，下面重点介绍 <code>_mark</code>。</p>\n<p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p>\n<p>对 Mark Word 的设计方式上，非常像网络协议报文头：将 Mark Word 划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在 32 位虚拟机上，在对象不同状态时 Mark Word 各个比特位区间的含义。</p>\n<img src=\"/2020/03/12/深入分析Synchronized/ObjectHead-markword.png\">\n<p>从上图中可以看出，对象的状态一共有五种，分别是<strong>无锁态</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong>、<strong>GC标记</strong>和<strong>偏向锁</strong>。在 32 位的虚拟机中有 2 个Bits是用来存储锁的标记为的，但是我们都知道，2 个 bits 最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖 1Bit 的空间，使用 0 和 1 来区分。</p>\n<p>在 32 位的 HotSpot 虚拟机 中对象未被锁定的状态下，Mark Word 的 32 个 Bits 空间中的 25Bits 用于存储对象哈希码(HashCode)，4Bits 用于存储对象分代年龄，2Bits 用于存储锁标志位，1Bit 固定为0，表示非偏向锁。</p>\n<h3 id=\"Moniter\"><a href=\"#Moniter\" class=\"headerlink\" title=\"Moniter\"></a>Moniter</h3><p>Monitor 是一种同步工具，也可以说是一种同步机制，主要特点是：</p>\n<p>同一个时刻，只有一个 进程/线程 能进入 Monitor 中定义的临界区，这使得 Monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 Monitor 临界区的 进程/线程应该被阻塞，并且在必要的时候会被唤醒。显然，Monitor 作为一个同步工具，也应该提供这样的管理 进程/线程 状态的机制。</p>\n<p>在 Java 中每个对象都有一个 Monitor 对象与之对应，在重量级锁的状态下，对象的 mark word 存放的是一个指针，指向了与之对应的 monitor 对象。这个 Monitor 对象就是实现重量锁的关键。注意这里说的是实现重量锁的关键，所以偏向锁、轻量锁在实现上和 Monitor 是没有关系的。</p>\n<p>无论是 <code>ACC_SYNCHRONIZED</code> 还是 <code>monitorenter</code>、<code>monitorexit</code> 都是基于 Monitor 机制实现的，在 Java 虚拟机（HotSpot）中，Monitor 机制是基于 C++ 的，由 ObjectMonitor 类具体实现。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMonitor() &#123;</span><br><span class=\"line\">  _header       = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  _count        = <span class=\"number\">0</span>;</span><br><span class=\"line\">  _waiters      = <span class=\"number\">0</span>,</span><br><span class=\"line\">  _recursions   = <span class=\"number\">0</span>;</span><br><span class=\"line\">  _object       = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  _owner        = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  _WaitSet      = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  _WaitSetLock  = <span class=\"number\">0</span> ;</span><br><span class=\"line\">  _Responsible  = <span class=\"literal\">NULL</span> ;</span><br><span class=\"line\">  _succ         = <span class=\"literal\">NULL</span> ;</span><br><span class=\"line\">  _cxq          = <span class=\"literal\">NULL</span> ;</span><br><span class=\"line\">  FreeNext      = <span class=\"literal\">NULL</span> ;</span><br><span class=\"line\">  _EntryList    = <span class=\"literal\">NULL</span> ;</span><br><span class=\"line\">  _SpinFreq     = <span class=\"number\">0</span> ;</span><br><span class=\"line\">  _SpinClock    = <span class=\"number\">0</span> ;</span><br><span class=\"line\">  OwnerIsThread = <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ObjectMonitor</code> 中有几个关键属性：</p>\n<ul>\n<li>_owner：指向<strong>持有 ObjectMonitor 对象的线程</strong>。初始时为 <code>NULL</code>，当有线程占有该 monitor 时，<code>_owner</code> 标记为该线程的唯一标识。当线程释放 monitor 时，<code>_owner</code> 又恢复为 <code>NULL</code>。<code>_owner</code> 是一个临界资源，JVM 是通过 <strong>CAS</strong> 操作来保证其线程安全的。</li>\n<li>_cxq：ContentionList，所有请求锁的线程首先会被放在这个集合中。<code>_cxq</code> 是一个临界资源，JVM 通过 <strong>CAS</strong> 来修改 <code>_cxq</code> 。修改前 <code>_cxq</code> 的旧值填入了 node 的 next 字段，<code>_cxq</code> 指向新值（新线程），因此 <code>_cxq</code> 是一个<strong>后进先出的 stack（栈）</strong>。</li>\n<li>_WaitSet：<strong>存放调用 <code>wait()</code> 方法的线程队列</strong>；</li>\n<li>_EntryList：存放处于等待锁 block 状态的<strong>线程队列</strong>，<code>_cxq</code> 队列中有资格成为候选资源的线程会被移动到该队列中；</li>\n<li>_recursions：锁的重入次数；</li>\n<li>_count：用来记录该线程获取锁的次数。</li>\n</ul>\n<p>其中 cxq、EntryList、WaitSet 都是由 ObjectWaiter 组成的链表结构。</p>\n<img src=\"/2020/03/12/深入分析Synchronized/synchronized流程.png\">\n<ol>\n<li><p>假设有 A、B 两个线程竞争被 synchronized 锁住的资源，A 线程抢先拿到了锁。拿到锁的步骤为：</p>\n<ul>\n<li>将 MonitorObject 中的 _owner 设置成 A线程；</li>\n<li>将 mark word 设置为 Monitor 对象地址，锁标志位改为 10；</li>\n<li>将 B 线程阻塞放到 ContentionList 队列；</li>\n</ul>\n</li>\n<li><p>JVM 每次从 Waiting Queue 的尾部取出一个线程放到 OnDeck 作为候选者，但是如果并发比较高，Waiting Queue 会被大量线程执行 CAS 操作，为了降低对尾部元素的竞争，将Waiting Queue 拆分成 ContentionList 和 EntryList 二个队列，JVM 将一部分线程移到 EntryList 作为准备进 OnDeck 的预备线程。</p>\n<ul>\n<li>所有请求锁的线程首先被放在 ContentionList 队列中；</li>\n<li>ContentionList 中那些有资格成为候选资源的线程被移动到 Entry List 中；</li>\n<li>任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</li>\n<li>当前已经获取到锁资源的线程被称为 owner；</li>\n<li>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 下采用 pthread_mutex_lock 内核函数实现的）。</li>\n</ul>\n</li>\n<li><p>作为 owner 的 A 线程执行过程中，可能调用 wait() 释放锁，这个时候 A 线程进入 Wait Set , 等待被唤醒。</p>\n</li>\n</ol>\n<p>当线程释放锁时，会从 cxq 或 EntryList 中挑选一个线程唤醒，被选中的线程叫做 Heir presumptive，即图中的 Ready Thread，该线程被唤醒后会尝试获得锁，但 synchronized 是非公平的，所以该线程不一定能获得锁。</p>\n<p>如果线程获得锁后调用 Object.wait 方法，则会将线程加入到 WaitSet 中，当被 Object.notify 唤醒后，会将线程从 WaitSet 移动到 cxq 或 EntryList 中。需要注意的是，当调用一个锁对象的 wait 或 notify 方法时，如当前锁的状态是偏向锁或轻量级锁则会先升级成重量级锁。</p>\n<h4 id=\"ObjectMonitor-类的重要方法\"><a href=\"#ObjectMonitor-类的重要方法\" class=\"headerlink\" title=\"ObjectMonitor 类的重要方法\"></a>ObjectMonitor 类的重要方法</h4><p>synchronized 关键字在使用的时候，往往需要指定一个对象与之关联，例如 synchronized(this)，或者 synchronized(ANOTHER_LOCK)，synchronized 如果修饰的是实例方法，那么其关联的对象实际上是 this，如果修饰的是类方法，那么其关联的对象是 this.class。总之，synchronzied 需要关联一个对象，而这个对象就是 ObjectMonitor。</p>\n<p>Java 语言中的 java.lang.Object 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 ObjectMonitor。</p>\n<h5 id=\"enter\"><a href=\"#enter\" class=\"headerlink\" title=\"enter\"></a>enter</h5><img src=\"/2020/03/12/深入分析Synchronized/Synchronized_Monitor_enter方法.png\">\n<h5 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h5><img src=\"/2020/03/12/深入分析Synchronized/Synchronized_Monitor_exit方法.png\">\n<h5 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h5><h5 id=\"notify\"><a href=\"#notify\" class=\"headerlink\" title=\"notify\"></a>notify</h5><h5 id=\"notifyAll\"><a href=\"#notifyAll\" class=\"headerlink\" title=\"notifyAll\"></a>notifyAll</h5><h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>通过这篇文章我们知道了 sychronized 加锁的时候，会调用 objectMonitor 的 <code>enter</code> 方法，解锁的时候会调用 <code>exit</code> 方法。事实上，只有在 JDK1.6 之前，synchronized 的实现才会直接调用 ObjectMonitor 的 <code>enter</code> 和 <code>exit</code>，这种锁被称之为<strong>重量级锁</strong>。为什么说这种方式操作锁很重呢？</p>\n<ul>\n<li>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被 synchronized 修饰的<code>get</code> 或 <code>set</code> 方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说 synchronized 是 Java 语言中一个重量级锁。</li>\n</ul>\n<p>所以，在 JDK1.6 中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在 JDK1.4 就有，只不过默认的是关闭的，JDK1.6 是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。</p>\n<h3 id=\"Java虚拟机的锁优化技术\"><a href=\"#Java虚拟机的锁优化技术\" class=\"headerlink\" title=\"Java虚拟机的锁优化技术\"></a>Java虚拟机的锁优化技术</h3><h4 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h4><img src=\"/2020/03/12/深入分析Synchronized/线程状态.png\">\n<h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><p>自旋锁在 JDK 1.4 中已经引入，在 JDK 1.6 中默认开启。</p>\n<p><strong>自旋锁指线程不放弃处理器的执行时间，等待持有锁的线程释放锁</strong>。</p>\n<p>自旋锁和阻塞锁最大的区别就是，<strong>要不要放弃处理器的执行时间</strong>。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了 CPU 时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。<br>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用 CPU 时间。如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。</p>\n<h4 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h4><p>锁消除，是 JIT 编译器对内部锁的具体实现所做的一种优化。在动态编译同步块的时候，JIT 编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。</p>\n<h4 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h4><p>在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。但是，如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。<br>当 JIT 发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。</p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是<strong>在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护</strong>。引入偏向锁是为了在多线程竞争的情况下尽量减少不必要的轻量级锁执行，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻<br>量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，其目的是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>\n<h3 id=\"Synchronized和ReentrantLock的区别\"><a href=\"#Synchronized和ReentrantLock的区别\" class=\"headerlink\" title=\"Synchronized和ReentrantLock的区别\"></a>Synchronized和ReentrantLock的区别</h3><ol>\n<li>Synchronized 是 JVM 层次的锁实现，ReentrantLock 是 JDK 层次的锁实现；</li>\n<li>Synchronized 的锁状态是无法在代码中直接判断的，但是 ReentrantLock 可以通过 ReentrantLock#isLocked 判断；</li>\n<li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>\n<li>Synchronized 是不可以被中断的，而 ReentrantLock#lockInterruptibly 方法是可以被中断的；</li>\n<li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</li>\n<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock()，以及等待指定时长的获取，更加灵活；</li>\n<li>Synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（上文有说），而ReentrantLock对于已经在等待的线程一定是先来的线程先获得锁。</li>\n</ol>\n<h3 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.hollischuang.com/?s=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">Hollis-深入理解多线程系列</a></li>\n<li><a href=\"https://github.com/farmerjohngit/myblog\" target=\"_blank\" rel=\"noopener\">farmerjohngit/myblog</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/123173443\" target=\"_blank\" rel=\"noopener\">就一个Synchronized，也能跟面试官扯了半个小时？</a></li>\n</ol>\n","categories":["Java"],"tags":["Java"]},{"title":"IntelliJ IDEA 快捷键","url":"http://yoursite.com/2019/12/15/IntelliJ Idea常用快捷键/","content":"<h2 id=\"跳转\"><a href=\"#跳转\" class=\"headerlink\" title=\"跳转\"></a>跳转</h2><ul>\n<li>Ctrl+Alt+[  ] 项目跳转</li>\n<li>Ctrl+Shift+A Find Action </li>\n<li>Ctrl+E  文件跳转(Recent Files)</li>\n<li>Ctrl+Shift+E (Recent Changed Files) </li>\n<li>Ctrl+Shift+Backspace 修改位置跳转(Last Edit Location)</li>\n<li><strong>Ctrl+Alt+左/右箭头 浏览位置跳转</strong></li>\n<li>Ctrl+F11+标记 标记书签 </li>\n<li>Ctrl+标记 书签跳转</li>\n<li>Ctrl+Shift+F 收藏</li>\n<li>ESC / Alt+1 文件区编辑区跳转</li>\n</ul>\n<h2 id=\"精确搜索\"><a href=\"#精确搜索\" class=\"headerlink\" title=\"精确搜索\"></a>精确搜索</h2><ul>\n<li>Ctrl+N 搜索Class</li>\n<li>Ctrl+Shift+N 搜索文件</li>\n<li>Ctrl+Alt+Shift+N 搜索方法/属性</li>\n<li>Ctrl+Shift+F 搜索字符串</li>\n</ul>\n<h2 id=\"列操作\"><a href=\"#列操作\" class=\"headerlink\" title=\"列操作\"></a>列操作</h2><ul>\n<li>Ctrl+Shift+Alt+J批量操作</li>\n<li>Ctrl+Shift+U 大小写转换</li>\n</ul>\n<h2 id=\"Live-Template\"><a href=\"#Live-Template\" class=\"headerlink\" title=\"Live Template\"></a>Live Template</h2><ul>\n<li>psvm</li>\n<li>psfi /psfs</li>\n<li>100.for</li>\n<li>sout</li>\n<li>name.field</li>\n<li>user.return</li>\n<li>user.nn(if not null)</li>\n<li>list.replace</li>\n</ul>\n<h2 id=\"Alt-Enter\"><a href=\"#Alt-Enter\" class=\"headerlink\" title=\"Alt+Enter\"></a>Alt+Enter</h2><ul>\n<li>实现单词拼写</li>\n<li>接口实现</li>\n</ul>\n<h2 id=\"高质量代码\"><a href=\"#高质量代码\" class=\"headerlink\" title=\"高质量代码\"></a>高质量代码</h2><ul>\n<li>Shift+F6 重构，变量重写</li>\n</ul>\n<h2 id=\"寻找修改轨迹\"><a href=\"#寻找修改轨迹\" class=\"headerlink\" title=\"寻找修改轨迹\"></a>寻找修改轨迹</h2><ul>\n<li>显示annotation，即可查看git提交记录</li>\n<li>localhistory 查看修改记录 / 添加lable </li>\n</ul>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><ul>\n<li>Ctrl+C 复制文件名</li>\n<li>Ctrl+Shift+C 复制文件路径</li>\n<li>Ctrl+Shift+V 剪切板</li>\n<li>Ctrl+Alt+U 查看Maven依赖，类图</li>\n<li>Hierarchy 查看方法调用</li>\n</ul>\n","categories":[],"tags":[]},{"title":"Java NIO 知识总结","url":"http://yoursite.com/2019/11/15/Java-NIO-知识总结/","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的 I/O 模型，也是 I/O 多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O 处理问题的有效方式。</p>\n<h3 id=\"通道-Channel\"><a href=\"#通道-Channel\" class=\"headerlink\" title=\"通道 (Channel)\"></a>通道 (Channel)</h3><p>通道 Channel 是原 I/O 包中的流，可以通过它读取和写入数据。通道与流的不同之处在于：</p>\n<ol>\n<li>流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写；</li>\n<li>Channel 可以异步读写，Stream则是阻塞地同步读写；</li>\n<li>Channel 总是从 Buffer 读取数据，或将数据写入到 Buffer 中。</li>\n</ol>\n<p>Channel 接口源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Channel</span> <span class=\"keyword\">extends</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOpen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本的 Channel 示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取文件</span></span><br><span class=\"line\">    RandomAccessFile file=<span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"C:\\\\WY\\\\hello.txt\"</span>,<span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\">    FileChannel fileChannel=file.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//获取Buffer</span></span><br><span class=\"line\">    ByteBuffer byteBuffer=ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> read=fileChannel.read(byteBuffer);</span><br><span class=\"line\">    <span class=\"comment\">//读取过程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (read!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        byteBuffer.flip() ;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class=\"line\">            System.out.print((<span class=\"keyword\">char</span>) byteBuffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        byteBuffer.clear();</span><br><span class=\"line\">        read=fileChannel.read(byteBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fileChannel.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Channel有四种分类，如下：</p>\n<ul>\n<li><strong>FileChannel</strong>：从文件中读写数据</li>\n<li><strong>SocketChannel</strong>：通过TCP读写网络中的数据</li>\n<li><strong>DatagramChannel</strong>：通过UDP读写网络中的数据</li>\n<li><strong>ServerSocketChannel</strong>：监听新进来的TCP连接，对每一个新的连接都会创建一个SocketChannel</li>\n</ul>\n<h4 id=\"FileChannel\"><a href=\"#FileChannel\" class=\"headerlink\" title=\"FileChannel\"></a>FileChannel</h4><p>FileChannel 是操作文件的 Channel，我们可以通过 FileChannel 从一个文件中读取数据，也可以将数据写入到文件中。<br>注意，FileChannel 只能为<strong>阻塞模式</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//    写入文件</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        RandomAccessFile file=new RandomAccessFile(\"C:\\\\WY\\\\hello.txt\",\"rw\");</span></span><br><span class=\"line\">        File file1=<span class=\"keyword\">new</span> File(<span class=\"string\">\"C:\\\\WY\\\\hello.txt\"</span>);</span><br><span class=\"line\">        FileOutputStream outputStream=<span class=\"keyword\">new</span> FileOutputStream(file1);</span><br><span class=\"line\">        FileChannel fileChannel=outputStream.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        String string=<span class=\"string\">\"Hello world! ++++++++++++++++++\"</span>+System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"comment\">//        操作 position</span></span><br><span class=\"line\"><span class=\"comment\">//        long pos=fileChannel.position();</span></span><br><span class=\"line\"><span class=\"comment\">//        fileChannel.position(pos+12);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">        byteBuffer.put(string.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class=\"line\">            fileChannel.write(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    读取文件</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取文件</span></span><br><span class=\"line\">        RandomAccessFile file=<span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"C:\\\\WY\\\\hello.txt\"</span>,<span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\">        FileChannel fileChannel=file.getChannel();</span><br><span class=\"line\">        <span class=\"comment\">//获取Buffer</span></span><br><span class=\"line\">        ByteBuffer byteBuffer=ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> read=fileChannel.read(byteBuffer);</span><br><span class=\"line\">        <span class=\"comment\">//读取过程</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (read!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            byteBuffer.flip() ;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class=\"line\">                System.out.print((<span class=\"keyword\">char</span>) byteBuffer.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            byteBuffer.clear();</span><br><span class=\"line\">            read=fileChannel.read(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fileChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"SocketChannel\"><a href=\"#SocketChannel\" class=\"headerlink\" title=\"SocketChannel\"></a>SocketChannel</h4><p>SocketChannel 是一个客户端用来进行 TCP 连接的 Channel。<br>创建一个 SocketChannel 的方法有两种：</p>\n<ol>\n<li>打开一个 SocketChannel，然后将其连接到某个服务器中；</li>\n<li>当一个 ServerSocketChannel 接受到连接请求时，会返回一个 SocketChannel 对象。</li>\n</ol>\n<p>可以设置 SocketChannel 为 <strong>非阻塞模式</strong>，这样我们的 <code>connect</code>、<code>read</code>、<code>write</code> 为非阻塞。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"http://example.com\"</span>, <span class=\"number\">80</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class=\"line\">    <span class=\"comment\">//wait, or do something else...    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在非阻塞模式中，或许连接还没有建立，<code>connect</code> 方法就返回了，因此需要检查当前是否是连接到了主机，因此通过一个 while 循环来判断。</p>\n<h4 id=\"ServerSocketChannel\"><a href=\"#ServerSocketChannel\" class=\"headerlink\" title=\"ServerSocketChannel\"></a>ServerSocketChannel</h4><p>ServerSocketChannel 顾名思义，是用在服务器为端的，可以监听客户端的 TCP 连接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//打开ServerSocketChannel</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel=ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定端口</span></span><br><span class=\"line\">        serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 非阻塞模式下，没有连接时返回null</span></span><br><span class=\"line\">                SocketChannel socketChannel=serverSocketChannel.accept();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(socketChannel != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//do something with socketChannel...</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            serverSocketChannel.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DatagramChannel\"><a href=\"#DatagramChannel\" class=\"headerlink\" title=\"DatagramChannel\"></a>DatagramChannel</h4><p>DatagramChannel 是用来处理 UDP 连接的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test5</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开DatagramChannel</span></span><br><span class=\"line\">    DatagramChannel datagramChannel=DatagramChannel.open();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//因为 UDP 是非连接的, 因此这个的 connect 并不是向 TCP 一样真正意义上的连接,</span></span><br><span class=\"line\">    <span class=\"comment\">// 而是它会将 DatagramChannel 锁住, 因此我们仅仅可以从指定的地址中读取或写入数据</span></span><br><span class=\"line\">    datagramChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">9999</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读取数据</span></span><br><span class=\"line\">    ByteBuffer byteBuffer=ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">    datagramChannel.receive(byteBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 写入数据</span></span><br><span class=\"line\">    String newData = <span class=\"string\">\"String to write to file...\"</span></span><br><span class=\"line\">            + System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">    byteBuffer1.clear();</span><br><span class=\"line\">    byteBuffer1.put(newData.getBytes());</span><br><span class=\"line\">    byteBuffer1.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bytesSent = datagramChannel.send(byteBuffer1, <span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"example.com\"</span>, <span class=\"number\">80</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Scatter-Gather\"><a href=\"#Scatter-Gather\" class=\"headerlink\" title=\"Scatter/Gather\"></a>Scatter/Gather</h4><p>Java NIO 开始支持 scatter/gather，scatter/gather 用于描述从 Channel 中读取或者写入到 Channel 的操作。</p>\n<h5 id=\"Scatter\"><a href=\"#Scatter\" class=\"headerlink\" title=\"Scatter\"></a>Scatter</h5><p><strong>分散(scatter)</strong> 从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer header = ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">ByteBuffer body   = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>\n<p>注意 buffer 首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。read() 方法按照 buffer 在数组中的顺序将从 channel 中读取的数据写入到 buffer，当一个 buffer 被写满后，channel 紧接着向另一个 buffer 中写。<strong>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息（消息大小不固定）</strong>。</p>\n<h5 id=\"Gather\"><a href=\"#Gather\" class=\"headerlink\" title=\"Gather\"></a>Gather</h5><p><strong>聚集(gather)</strong> 写入Channel是指在写操作时将多个 buffer 的数据写入同一个 Channel，因此，Channel 将多个 Buffer 中的数据“聚集（gather）”后发送到 Channel。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ByteBuffer header = ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">ByteBuffer body   = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//write data into buffers</span></span><br><span class=\"line\"></span><br><span class=\"line\">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.write(bufferArray);</span><br></pre></td></tr></table></figure></p>\n<p>buffers 数组是 write() 方法的入参，write() 方法会按照 buffer 在数组中的顺序，将数据写入到 channel，注意只有 position 和 limit 之间的数据才会被写入。因此与 Scattering Reads 相反，Gathering Writes 能较好的处理动态消息。</p>\n<h4 id=\"Channel-之间的数据传输\"><a href=\"#Channel-之间的数据传输\" class=\"headerlink\" title=\"Channel 之间的数据传输\"></a>Channel 之间的数据传输</h4><p>在Java NIO中，如果两个通道中有一个是 FileChannel，那你可以直接将数据从一个 Channel 传输到另外一个 Channel。</p>\n<p>FileChannel 的 <strong><code>transferFrom()</code></strong> 方法可以将数据从源通道传输到 FileChannel 中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile  fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\">FileChannel  fromChannel = fromFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">RandomAccessFile  toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\">FileChannel   toChannel = toFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span>  position = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span>  count = fromChannel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure></p>\n<p>transferFrom 方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count 表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。此外要注意，在 SocketChannel 的实现中，SocketChannel 只会传输此刻准备好的数据（可能不足 count 字节）。因此，SocketChannel 可能不会将请求的所有数据(count 个字节)全部传输到 FileChannel 中。</p>\n<p><strong><code>transferTo()</code></strong> 方法将数据从 FileChannel 传输到其他的 Channel 中。下面是一个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile fromFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"fromFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\">FileChannel   fromChannel = fromFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">RandomAccessFile toFile = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"toFile.txt\"</span>, <span class=\"string\">\"rw\"</span>);</span><br><span class=\"line\">FileChannel   toChannel = toFile.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> position = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> count = fromChannel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>\n<p>上面所说的关于 SocketChannel 的问题在 <code>transferTo()</code> 方法中同样存在。SocketChannel 会一直传输数据直到目标 buffer 被填满。</p>\n<h4 id=\"内存映射文件\"><a href=\"#内存映射文件\" class=\"headerlink\" title=\"内存映射文件\"></a>内存映射文件</h4><h3 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区 (Buffer)\"></a>缓冲区 (Buffer)</h3><p>一个 Buffer 其实就是一块内存区域,，我们可以在这个内存区域中进行数据的读写。NIO Buffer 其实是这样的内存块的一个封装，并提供了一些操作方法让我们能够方便地进行数据的读写。</p>\n<h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h4><ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n<li>MappedByteBuffer (ByteBuffer子类)</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//标记：一个备忘位置。调用 mark( ) 来设定 mark=postion 。调用reset( ) 设定 position= mark。标记在设定前是未定义的(undefined)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//位置：下一个要被读或写的元素的索引。位置会自动由相应的 get() 和  put() 函数更新。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//上界：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> limit ;</span><br><span class=\"line\">    <span class=\"comment\">//容量：缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且不能被改变</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity ;</span><br></pre></td></tr></table></figure>\n<p>属性之间的关系：<strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong>。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ol>\n<li><p><strong>基本方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回容量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">capacity</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//返回位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">position</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//设置容量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">position</span><span class=\"params\">(<span class=\"keyword\">int</span> newPosition)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//返回上届</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">limit</span><span class=\"params\">()</span> </span>;</span><br><span class=\"line\"><span class=\"comment\">//标记当前position为mark</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">mark</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//重回mark位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">reset</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//一般在把数据写入Buffer前调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//翻转:将缓存字节数组的指针设置为数组的开始序列即数组下标0。这样就可以从buffer开头，对该buffer进行遍历（读取）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一般在把数据重写入Buffer前调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">rewind</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// limit - position</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">remaining</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// position &lt; limit</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasRemaining</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isReadOnly</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>存取方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span><span class=\"params\">( )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span> <span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">put</span> <span class=\"params\">(<span class=\"keyword\">byte</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">put</span> <span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">byte</span> b)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>压缩方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将position到limit之间的数据迁移至0开始处,然后limit=capacity</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ByteBuffer <span class=\"title\">compact</span><span class=\"params\">( )</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>比较方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// true： 两个 Buffer 是相同类型</span></span><br><span class=\"line\"><span class=\"comment\">// 两个 Buffer 的剩余的数据个数相同</span></span><br><span class=\"line\"><span class=\"comment\">// 两个 Buffer 的剩余的数据都是相同的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span> <span class=\"params\">(Object ob)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 比较是针对每个缓冲区内 剩余数据 进行的，与它们在equals()中的方式相同</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 直到不相等的元素被发现或者到达缓冲区的上界。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果一个缓冲区在不相等元素发现前已经被耗尽，较短 的缓冲区被认为是小于较长的缓冲区</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span> <span class=\"params\">(Object ob)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"直接缓冲区-VS-非直接缓冲区\"><a href=\"#直接缓冲区-VS-非直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区 VS 非直接缓冲区\"></a>直接缓冲区 VS 非直接缓冲区</h4><ul>\n<li><strong>非直接缓冲区</strong>：通过 <code>allocate()</code> 方法分配缓冲区，直接在 JVM 堆上进行内存的分配，本质上是 byte[] 数组的封装。非直接缓冲区如下图：</li>\n</ul>\n<img src=\"/2019/11/15/Java-NIO-知识总结/NIO-非直接缓冲区.png\">\n<p>当程序想要从硬盘中读取数据，先从物理硬盘把数据读取到物理内存中，再将内容复制到JVM的内存中，然后读取应用程序才可以读取到内容。读写都是需要<strong>复制</strong>这一个动作，当遇到大文本的文件时，效率低下。</p>\n<ul>\n<li><strong>直接缓冲区</strong>：通过 <code>allocateDirect()</code> 方法分配直接缓冲区，所分配的内存不在 JVM 堆上，不受 GC 的管理，当进行一些底层的系统 IO 操作时，效率会比较高，因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中。直接缓冲区如下图：</li>\n</ul>\n<img src=\"/2019/11/15/Java-NIO-知识总结/NIO-直接缓冲区.png\">\n<p>内核地址空间和用户地址空间之间形成了一个物理内存映射文件，减少了之间的复制过程。</p>\n<ol>\n<li>如果为直接缓冲区，则 JVM 会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li>\n<li>直接缓冲区可以通过调用 <code>allocateDirect()</code> 工厂方法来创建，此方法实现的缓冲区分配和取消分配所需成本通常高于非直接缓冲区 。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响并不明显。</li>\n<li>直接缓冲区还可以通过 FileChannel 的 <code>map()</code> 方法将文件区域直接映射到内存中来创建，该方法返回 MappedByteBuffer 。Java平台的实现有助于通过 JNI 从本机代码创建直接缓冲区。</li>\n<li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 <code>isDirect()</code> 方法来确定，提供此方法是为了能够在性能关键的代码中执行显式缓冲区管理。</li>\n</ol>\n<blockquote>\n<p><strong>ByteBuffer.allocateDirect() 和 MappedByteBuffer.load() 区别</strong><br><strong>DirectBuffer GC</strong>  所分配的内存不在 JVM 堆上，不受 GC 的管理。(但是 Direct Buffer 的 Java 对象是由 GC 管理的，因此当发生 GC，对象被回收时，Direct Buffer 也会被释放)</p>\n</blockquote>\n<h3 id=\"选择器-Selector\"><a href=\"#选择器-Selector\" class=\"headerlink\" title=\"选择器 (Selector)\"></a>选择器 (Selector)</h3><p>Selector（选择器）是 Java NIO 中能够检测一到多个 NIO 通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个 Channel，从而管理多个网络连接。</p>\n<img src=\"/2019/11/15/Java-NIO-知识总结/Selector图示.png\">\n<p>为了使用 Selector, 我们首先需要将 Channel 注册到 Selector 中, 随后调用 Selector 的 <code>select()</code>方法, 这个方法会阻塞直到注册在 Selector 中的 Channel 发送可读写事件。当这个方法返回后, 当前的这个线程就可以处理 Channel 的事件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Selector</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Selector</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//实例化Selector</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Selector <span class=\"title\">open</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SelectorProvider.provider().openSelector();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> SelectorProvider <span class=\"title\">provider</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回 注册到它们之上的通道的集合,不可以直接修改的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Set&lt;SelectionKey&gt; <span class=\"title\">keys</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回 就绪的键.已注册的键的集合的子集,这个集合的每个成员都是相关的通道被选择器(在前一个选择操作中)判断为已经准备好的，并且包含于键的interest集合中的操作/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Set&lt;SelectionKey&gt; <span class=\"title\">selectedKeys</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//非阻塞</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">selectNow</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//设定时间内阻塞</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//完全阻塞</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//停止阻塞中的select方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Selector <span class=\"title\">wakeup</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//测试一个选择器是否处于被打开的状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOpen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//释放它可能占用的资源并将所有相关的选择键设置为无效,一个在选择操作中阻塞的线程都将被唤醒，就像wakeup()方法被调用了一样。与选择器相关的通道将被注销，而键将被取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建选择器\"><a href=\"#创建选择器\" class=\"headerlink\" title=\"创建选择器\"></a>创建选择器</h4><p>通过 <code>Selector.open()</code> 方法, 我们可以创建一个选择器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>\n<h4 id=\"将-Channel-注册到选择器中\"><a href=\"#将-Channel-注册到选择器中\" class=\"headerlink\" title=\"将 Channel 注册到选择器中\"></a>将 Channel 注册到选择器中</h4><p>为了使用选择器管理 Channel，我们需要将 Channel 注册到选择器中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>\n<p>注意，如果一个 Channel 要注册到 Selector 中，那么这个 Channel 必须是非阻塞的， 即 <code>channel.configureBlocking(false);</code>。因为 Channel 必须要是非阻塞的，因此 FileChannel 是不能够使用选择器的，因为 FileChannel 都是阻塞的。</p>\n<p>另外，在使用 <code>Channel.register()</code> 方法时，第二个参数指定了我们对 Channel 的什么类型的事件感兴趣，这些事件有：</p>\n<ul>\n<li>Connect， 即连接事件(TCP 连接)，对应于 SelectionKey.OP_CONNECT，某个Channel成功连接到另一个服务器；</li>\n<li>Accept，即确认事件，对应于SelectionKey.OP_ACCEPT，表示准备好接收新进入的连接；</li>\n<li>Read，即读事件，对应于SelectionKey.OP_READ，表示 buffer 可读</li>\n<li>Write，即写事件，对应于SelectionKey.OP_WRITE，表示 buffer 可写</li>\n</ul>\n<p>我们可以使用 或运算 | 来组合多个事件，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n<p>注意，一个 Channel 仅仅可以被注册到一个 Selector 一次，如果将 Channel 注册到 Selector 多次，那么其实就是相当于更新 SelectionKey 的 interest set。<br>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>\n<p>上面的 channel 注册到同一个 Selector 两次，那么第二次的注册其实就是相当于更新这个 Channel 的 interest set 为 SelectionKey.OP_READ | SelectionKey.OP_WRITE。</p>\n<h4 id=\"Selector-维护的-selection-key\"><a href=\"#Selector-维护的-selection-key\" class=\"headerlink\" title=\"Selector 维护的 selection key\"></a>Selector 维护的 selection key</h4><ul>\n<li><strong>key set</strong> 包含着所有 selectionKey，当前所有注册到 Selector 中的Channel 返回的 SelectionKey 都包含在内，这个集合可以通过 <code>selector.keys()</code> 方法返回。</li>\n<li><strong>selected-key set</strong> 是 key set 的子集，其中的每个 selectionKey 所关联的 Channel 在 selection operation 期间被检测出至少准备好了一个可以在兴趣集中匹配到的操作。这个集合可以通过调用 <code>selector.selectedKeys()</code> 方法返回。</li>\n<li><strong>cancelled-key set</strong> 也是 key set 的子集，其中的每个 selectionKey 都已经被取消，但是所关联 Channel 还没有被撤销登记。cancelled-key set 不能够被直接返回。</li>\n</ul>\n<p>对于一个新创建的 Selector，这三个集合都是空的。</p>\n<p>通过 Channel 的 <code>register</code> 方法，一个 selectionKey 被增加到 Selector 的 key set 中。</p>\n<p>当通过 <code>channel.close()</code> 或 <code>selectionKey.cancel()</code> 来取消一个selectionKey，这个 selectionKey 都会被立即添加到 Selector 的 cancelled-key set 中，但是所关联的 Channel 并没有立即被撤销登记，直到发生下次 selection operations，这些 Channel 才被从 Selector 中撤销登记，与此同时这些 Cancelled keys 才会从 Selector 的所有 selectionKey set（可能是 key set_、selected-key set、cancelled-key set）中移除，但是不会影响这些集合本身。</p>\n<p>在 selection operations 期间，一些 selectionKey 会被选中添加到 selected-key set 中。其中的每个 key 可以通过 <code>selectiedKeys.remove()</code> 或 <code>selectiedKeys.iterator().remove()</code> 直接从 selected-key set 中移除，除此之外不能够通过任何方式被直接移除。特殊的，selected-key set 中的keys 还可以在 selection operations 期间被间接移除。但是是不可以直接向 selected-key set 添加 key 的。</p>\n<h4 id=\"Selector-如何选择就绪-Channel\"><a href=\"#Selector-如何选择就绪-Channel\" class=\"headerlink\" title=\"Selector 如何选择就绪 Channel\"></a>Selector 如何选择就绪 Channel</h4><p>每次 selection operation 期间， keys 都可以添加到  selected-key set 或从 selected-key set 中移除，同时也可以从它的 key set 和 cancelled-key set 中移除。 selection operation 通过执行 <code>selector.select()</code> ，<code>selector.select(long)</code>，和 <code>selector.selectNow()</code> 方法被触发，并且这些方法涉及到以下三个步骤：</p>\n<ol>\n<li><p>首先每个位于 cancelled-key set 中的 key 会从每个包含它的 key 集合中被移除，并且对应的 Channel 会被撤销登记。这个步骤使得 cancelled-key set 为空。</p>\n</li>\n<li><p>查询底层操作系统来获得 Selector 中剩余 Channel 的就续事件从 selection operation 开始到此刻的更新情况，只要存在 Channel 的就续事件的更新部分有至少一个与兴趣集中的操作匹配上，那么将会执行以下两个动作：</p>\n<ul>\n<li>如果这个 Channel 对应的 SelectionKey 没有存在于 selected-key set中，那么将它添加到这个集合中，并将它的就绪操作集(ready set)修改成目前就绪的操作，任何先前记录在就绪操作集中的就绪信息都会被丢弃。</li>\n<li>否则，如果这个 Channel 对应的 SelectionKey 存在于 selected-key set 中，那么则保留就绪操作集中先前的就绪信息，并将这些刚刚就绪的操作 写入进去；总而言之，系统底层会通过按位与 &amp; 操作更新当前就绪集。</li>\n</ul>\n</li>\n</ol>\n<p>如果这些 SelectionKey 的兴趣集( interest set )为空，那么 selected-key set 和 所有这些 key 的就续集(ready set)都不会被更新。</p>\n<ol start=\"3\">\n<li>如果在步骤 2 正在进行时将任何 key 添加到 cancelled-key set，则按步骤 1 处理它们。</li>\n</ol>\n<p>selection operations 是否会阻塞等待一个或多个通道准备就绪，以及等待多长时间，这是三种选择方法之间唯一的本质区别。</p>\n<h4 id=\"Selector-是否线程安全\"><a href=\"#Selector-是否线程安全\" class=\"headerlink\" title=\"Selector 是否线程安全\"></a>Selector 是否线程安全</h4><p>多线程并发情况下 Selectors 本身是线程安全的，但是他们所持有的 key set不是线程安全的。</p>\n<p>selection operations 在 selector 本身，key set 和 selected-key set 上是同步的，还在上面的步骤 1 和 3 中涉及的 canceled-key set 上同步。</p>\n<p>在 selection operations 期间改变 SelectionKey 的兴趣集，对于本次操作将不会产生任何影响；影响将会在下次 selection operations 期间发生。</p>\n<p>SelectionKey 可能会被取消，Channel 可能随时关闭。 因此，在一个或多个选择器的 key 集合中存在并不意味着 SelectionKey 有效或其 Channel 是开放的。有可能另一个线程取消 SelectionKey 或关闭一个 Channel，应用程序代码应该小心地同步并检查这些条件。</p>\n<p>一个线程通过 <code>selector.select()</code> 或 <code>selector.select(long)</code> 方法产生的阻塞可以被其他线程用以下三种方式的任意一种来中断：</p>\n<ol>\n<li>调用 <code>selector.wakeup()</code> 方法；</li>\n<li>调用 <code>selector.close()</code> 方法；</li>\n<li>调用阻塞线程的 <code>interrupt()</code> 方法，此时线程会中断，selector 的<code>wakeup()</code> 方法会被调用。</li>\n</ol>\n<p><code>selector.close()</code> 在 selection operations 期间会顺序同步 selector 和三个 key set。</p>\n<p>一个 selector 的 key set 和 selected-key set 通常情况下是线程不安全的。如果一个线程想要修改这个集合，需要同步控制它。通过 key set 的 <code>iterator()</code> 方法返回的 Iterators 提供了 <code>fail-fast</code>：如果在创建迭代器之后修改了 set，除了通过调用迭代器自己的 <code>remove()</code> 方法之外，将抛出 ConcurrentModificationException 。</p>\n<h4 id=\"SelectionKey\"><a href=\"#SelectionKey\" class=\"headerlink\" title=\"SelectionKey\"></a>SelectionKey</h4><p> 当我们使用 <code>register</code> 注册一个 Channel 时，会返回一个 SelectionKey 对象，这个对象包含了如下内容：</p>\n<ul>\n<li>interest set</li>\n<li>ready set</li>\n<li>channel</li>\n<li>selector</li>\n<li>attached object，可选的附加对象</li>\n</ul>\n<h5 id=\"interest-set\"><a href=\"#interest-set\" class=\"headerlink\" title=\"interest set\"></a>interest set</h5><p>即我们感兴趣的事件集, 即在调用 <code>register</code> 注册 channel 时所设置的 interest set。我们可以通过如下方式获取 interest set：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> interestSet = selectionKey.interestOps();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n<h5 id=\"ready-set\"><a href=\"#ready-set\" class=\"headerlink\" title=\"ready set\"></a>ready set</h5><p>ready set 代表了 Channel 所准备好的操作。我们可以像判断 interest set 一样操作 ready set，但是我们还可以使用如下方法进行判断：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> readySet = selectionKey.readyOps();</span><br><span class=\"line\"></span><br><span class=\"line\">selectionKey.isAcceptable();</span><br><span class=\"line\">selectionKey.isConnectable();</span><br><span class=\"line\">selectionKey.isReadable();</span><br><span class=\"line\">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Channel-和-Selector\"><a href=\"#Channel-和-Selector\" class=\"headerlink\" title=\"Channel 和 Selector\"></a>Channel 和 Selector</h5><p>我们可以通过 SelectionKey 获取相对应的 Channel 和 Selector：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Channel  channel  = selectionKey.channel();</span><br><span class=\"line\">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Attaching-Object\"><a href=\"#Attaching-Object\" class=\"headerlink\" title=\"Attaching Object\"></a>Attaching Object</h5><p>我们可以在 selectionKey 中附加一个对象：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selectionKey.attach(theObject);</span><br><span class=\"line\">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p>\n<p>或者在注册时直接附加：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"通过-Selector-选择-Channel\"><a href=\"#通过-Selector-选择-Channel\" class=\"headerlink\" title=\"通过 Selector 选择 Channel\"></a>通过 Selector 选择 Channel</h4><p>我们可以通过 <code>Selector.select()</code> 方法获取对某件事件准备好的 Channel，即如果我们在注册 Channel 时，对其的 可写事件 感兴趣，那么当 select() 返回时，我们就可以获取 Channel 了。注意，select() 方法返回的值表示有多少个 Channel 可操作。</p>\n<h4 id=\"获取可操作的-Channel\"><a href=\"#获取可操作的-Channel\" class=\"headerlink\" title=\"获取可操作的 Channel\"></a>获取可操作的 Channel</h4><p>如果 select()方法返回值表示有多个 Channel 准备好，那么我们可以通过 Selected key set 访问这个 Channel：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(keyIterator.hasNext()) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SelectionKey key = keyIterator.next();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(key.isAcceptable()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// a connection was established with a remote server.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// a channel is ready for reading</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// a channel is ready for writing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    keyIterator.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每次迭代时，<strong>最后要调用 <code>keyIterator.remove()</code> 将这个 key 从迭代器中删除</strong>，因为 select() 方法仅仅是简单地将就绪的 IO 操作放到 selectedKeys 集合中，因此如果我们从 selectedKeys 获取到一个 key，但是没有将它删除， 那么下一次 select 时, 这个 key 所对应的 IO 事件还在 selectedKeys 中。注意，我们<strong>可以动态更改 SekectedKeys 中的 key 的 interest set</strong>。例如在 OP_ACCEPT 中，我们可以将 interest set 更新为 OP_READ，这样 Selector 就会将这个 Channel 的 读 IO 就绪事件包含进来了。</p>\n<h4 id=\"Selector-的基本使用流程\"><a href=\"#Selector-的基本使用流程\" class=\"headerlink\" title=\"Selector 的基本使用流程\"></a>Selector 的基本使用流程</h4><ol>\n<li>通过 Selector.open() 打开一个 Selector</li>\n<li>将 Channel 注册到 Selector 上，并设置需要监听的事件（interest set）</li>\n<li>不断重复：<ul>\n<li>调用 <code>select()</code>  方法</li>\n<li>调用 <code>selector.selectedKeys()</code> 获取 selected keys</li>\n<li>迭代每个 selected key：<ul>\n<li>从 selected key 中获取 对应的 Channel 和附加信息(如果存在)</li>\n<li>判断是哪些 IO 事件已经就绪，然后处理。如果是 OP_ACCEPT 事件, 则调用 <code>SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept()</code> 获取 SocketChannel，并将它设置为非阻塞的，然后将这个 Channel 注册到 Selector 中。</li>\n<li>根据需要更改 selected key 的监听事件。</li>\n<li>将已经处理过的 key 从 selected keys 集合中删除。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelectorTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READ_BUF_SIZE = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WRITE_BUF_SIZE = <span class=\"number\">256</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIMEOUT = <span class=\"number\">3000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打开ServerSocketChannel</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel=ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 打开 Selector</span></span><br><span class=\"line\">        Selector selector=Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">// 服务端 Socket 监听8080端口, 并配置为非阻塞模式</span></span><br><span class=\"line\">        serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>,<span class=\"number\">9980</span>));</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将 channel 注册到 selector 中.</span></span><br><span class=\"line\">        <span class=\"comment\">// 通常我们都是先注册一个 OP_ACCEPT 事件, 然后在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ</span></span><br><span class=\"line\">        <span class=\"comment\">// 注册到 Selector 中</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        ByteBuffer readBuffer=ByteBuffer.allocate(READ_BUF_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">        ByteBuffer writeBuffer=ByteBuffer.allocate(WRITE_BUF_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 select 方法阻塞等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(selector.select(TIMEOUT)==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"继续等待...\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 获取 I/O 操作就绪的 SelectionKey, 通过 SelectionKey 可以知道哪些 Channel 的哪类 I/O 操作已经就绪.</span></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; selectionKeyIterator=selector.keys().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selectionKeyIterator.hasNext())&#123;</span><br><span class=\"line\">                SelectionKey key = selectionKeyIterator.next();</span><br><span class=\"line\">                <span class=\"comment\">// 当获取一个 SelectionKey 后, 就要将它删除, 表示我们已经对这个 IO 事件进行了处理.</span></span><br><span class=\"line\">                selectionKeyIterator.remove();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable())&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 当 OP_ACCEPT 事件到来时, 我们就有从 ServerSocketChannel 中获取一个 SocketChannel,</span></span><br><span class=\"line\">                    <span class=\"comment\">// 代表客户端的连接</span></span><br><span class=\"line\">                    <span class=\"comment\">// 注意, 在 OP_ACCEPT 事件中, 从 key.channel() 返回的 Channel 是 ServerSocketChannel.</span></span><br><span class=\"line\">                    <span class=\"comment\">// 而在 OP_WRITE 和 OP_READ 中, 从 key.channel() 返回的是 SocketChannel.</span></span><br><span class=\"line\">                    SocketChannel socketChannel=((ServerSocketChannel)key.channel()).accept();</span><br><span class=\"line\">                    socketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ 注册到 Selector 中.</span></span><br><span class=\"line\">                    <span class=\"comment\">// 注意, 这里我们如果没有设置 OP_READ 的话, 即 interest set 仍然是 OP_CONNECT 的话, 那么 select 方法会一直直接返回.</span></span><br><span class=\"line\">                    socketChannel.register(selector, OP_READ);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable())&#123;</span><br><span class=\"line\">                    SocketChannel socketChannel=(SocketChannel) key.channel();</span><br><span class=\"line\">                    readBuffer.clear();</span><br><span class=\"line\">                    <span class=\"keyword\">long</span> read=socketChannel.read(readBuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// -1 表示读到末尾，关闭Channel</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (read==-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(read&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        readBuffer.flip();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"received : \"</span> + <span class=\"keyword\">new</span> String(readBuffer.array()));</span><br><span class=\"line\">                        key.interestOps(SelectionKey.OP_WRITE| OP_READ);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key.isWritable())&#123;</span><br><span class=\"line\">                    writeBuffer.rewind();</span><br><span class=\"line\">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                    socketChannel.write(writeBuffer);</span><br><span class=\"line\">                    key.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"BIO-与-NIO-区别\"><a href=\"#BIO-与-NIO-区别\" class=\"headerlink\" title=\"BIO 与 NIO 区别\"></a>BIO 与 NIO 区别</h3><table>\n<thead>\n<tr>\n<th>IO</th>\n<th>NIO</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>阻塞</td>\n<td>非阻塞</td>\n</tr>\n<tr>\n<td>面向流</td>\n<td>面向块</td>\n</tr>\n<tr>\n<td>无</td>\n<td>选择器</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"基于-Stream-与基于-Buffer\"><a href=\"#基于-Stream-与基于-Buffer\" class=\"headerlink\" title=\"基于 Stream 与基于 Buffer\"></a>基于 Stream 与基于 Buffer</h4><p>传统的 IO 是面向字节流或字符流的，而在 NIO 中，我们抛弃了传统的 IO 流，而是引入 Channel 和 Buffer 的概念。在 NIO 中，我只能从 Channel 中读取数据到 Buffer 中或将数据从 Buffer 中写入到 Channel。<br>那什么是基于 Stream 呢？在一般的 Java IO 操作中，我们以流式的方式顺序从一个 Stream 中读取一个或多个字节，因此我们不能随意改变读取指针的位置。而基于 Buffer 就显得有点不同了。我们首先需要从 Channel 中读取数据到 Buffer 中，当 Buffer 中有数据后，我们就可以对这些数据进行操作了。不像 IO 那样是顺序操作，NIO 中我们可以随意地读取任意位置的数据。</p>\n<h4 id=\"阻塞和非阻塞\"><a href=\"#阻塞和非阻塞\" class=\"headerlink\" title=\"阻塞和非阻塞\"></a>阻塞和非阻塞</h4><p>Java 提供的各种 Stream 操作都是阻塞的，例如我们调用一个 <code>read</code> 方法读取一个文件的内容，那么调用 <code>read</code> 的线程会被阻塞住，直到 read 操作完成。<br>而 NIO 的非阻塞模式允许我们非阻塞地进行 IO 操作。例如我们需要从网络中读取数据，在 NIO 的非阻塞模式中，当我们调用 read 方法时，如果此时有数据，则 read 读取并返回；如果此时没有数据，则 read 直接返回，而不会阻塞当前线程。</p>\n<h4 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h4><p>Selector 是 NIO 中才有的概念，它是 Java NIO 之所以可以非阻塞地进行 IO 操作的关键。通过 Selector，一个线程可以监听多个 Channel 的 IO 事件，当我们向一个 Selector 中注册了 Channel 后，Selector 内部的机制就可以自动地为我们不断地查询（select）这些注册的 Channel 是否有已就绪的 IO 事件（例如可读、可写、网络连接完成等）。通过这样的 Selector 机制，我们就可以很简单地使用一个线程高效地管理多个 Channel。</p>\n<h3 id=\"管道-Pipe\"><a href=\"#管道-Pipe\" class=\"headerlink\" title=\"管道 (Pipe)\"></a>管道 (Pipe)</h3><p>Java NIO Pipe是线程之间的单向数据连接。在多线程编程中除了 wait()、notify()、notifyAll()等，增加了一种新的线程间通讯方式。Pipe 有一个 source 通道和一个 sink 通道。数据会被写到 sink 通道，从 source 通道读取。</p>\n<img src=\"/2019/11/15/Java-NIO-知识总结/pipe.png\">\n<h4 id=\"开启管道\"><a href=\"#开启管道\" class=\"headerlink\" title=\"开启管道\"></a>开启管道</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure>\n<h4 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class=\"line\"></span><br><span class=\"line\">sinkChannel.write(ByteBuffer src) ;</span><br><span class=\"line\">sinkChannel.write(ByteBuffer[] srcs) ;</span><br><span class=\"line\">sinkChannel.write(ByteBuffer[] srcs, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length) ;</span><br></pre></td></tr></table></figure>\n<h4 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class=\"line\"></span><br><span class=\"line\">sourceChannel.read(ByteBuffer dst);</span><br><span class=\"line\">sourceChannel.read(ByteBuffer[] dsts);</span><br><span class=\"line\">sourceChannel.read(ByteBuffer[] dsts, <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> length);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Path\"><a href=\"#Path\" class=\"headerlink\" title=\"Path\"></a>Path</h3><p>Java 中的 Path 表示文件系统的路径，可以指向文件或文件夹，也有相对路径和绝对路径之分。<br>在很多方面，java.nio.file.Path 接口和 java.io.File 有相似性，但也有一些细微的差别。在很多情况下，可以用 Path 来代替 File 类。</p>\n<h4 id=\"创建Path实例\"><a href=\"#创建Path实例\" class=\"headerlink\" title=\"创建Path实例\"></a>创建Path实例</h4><p>使用 Paths 类的静态方法 <code>Paths.get()</code> 来产生一个实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Path path = Paths.get(<span class=\"string\">\"c:\\\\data\\\\hello.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建绝对路径Path\"><a href=\"#创建绝对路径Path\" class=\"headerlink\" title=\"创建绝对路径Path\"></a>创建绝对路径Path</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Path path = Paths.get(<span class=\"string\">\"/home/wy/myfile.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建相对路径Path\"><a href=\"#创建相对路径Path\" class=\"headerlink\" title=\"创建相对路径Path\"></a>创建相对路径Path</h4><p>可以通过 <code>Paths.get(basePath, relativePath)</code> 创建一个相对路径 Path。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Path projects = Paths.get(<span class=\"string\">\"d:\\\\data\"</span>, <span class=\"string\">\"projects\"</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Path-normalize\"><a href=\"#Path-normalize\" class=\"headerlink\" title=\"Path.normalize()\"></a>Path.normalize()</h4><p>Path 的 <code>normalize()</code> 方法可以标准化路径。标准化的含义是路径中的 . 和 .. 都去掉，指向真正的路径目录地址。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Path path2 = path1.normalize();</span><br></pre></td></tr></table></figure>\n<h3 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h3><p>Java NIO Files类 (java.nio.file.Files) 提供了操作文件的相关方法。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000010858641\" target=\"_blank\" rel=\"noopener\">Java NIO-阅读笔记及总结</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006824091\" target=\"_blank\" rel=\"noopener\">Java NIO 的前生今世 之一 简介</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006824107\" target=\"_blank\" rel=\"noopener\">Java NIO 的前生今世 之二 NIO Channel 小结</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006824155\" target=\"_blank\" rel=\"noopener\">Java NIO 的前生今世 之三 NIO Buffer 详解</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006824196\" target=\"_blank\" rel=\"noopener\">Java NIO 的前生今世 之四 NIO Selector 详解</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1333349\" target=\"_blank\" rel=\"noopener\">Java NIO笔记</a></li>\n<li><a href=\"http://ifeve.com/pipe/\" target=\"_blank\" rel=\"noopener\">Java NIO系列教程（十一） Pipe</a></li>\n<li><a href=\"https://blog.csdn.net/qq_32331073/article/details/81132937\" target=\"_blank\" rel=\"noopener\">NIO之坑：完全理解NIO Selector</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/36930888\" target=\"_blank\" rel=\"noopener\">Java NIO 之 Selector（选择器）</a></li>\n</ol>\n","categories":["Java"],"tags":["Java"]},{"title":"Java 类加载机制","url":"http://yoursite.com/2019/11/05/Java 类加载机制/","content":"<h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p>class 文件在虚拟机的整个生命周期包括加载、验证、准备、解析、初始化、使用和卸载 7 个阶段，通过 <code>ClassLoader.loadClass()</code> 方法可以加载一个 Java 类到虚拟机中，并返回 Class 类型的引用。</p>\n<ul>\n<li>加载：通过一个类的完全限定名查找此类的字节码文件，并利用字节码文件创建一个 Class 对象；</li>\n<li>验证：目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括文件格式验证、元数据验证、字节码验证、符号引用验证这四种验证方式。</li>\n<li>准备：为类变量（即 static 修饰的字段变量）分配内存并且设置该类变量的初始值为 0 （如 static int i=5;这里只将 i 初始化为 0，至于 5 的值将在初始化时赋值），这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配，注意这里也不会对实例变量进行初始化。</li>\n<li>解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析等。</li>\n<li>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量（如前面只初始化了默认值的 static 变量将会在这个阶段赋值，成员变量也将被初始化）。</li>\n</ul>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>JVM 提供了 3 种类加载器：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）。</p>\n<h4 id=\"启动类加载器\"><a href=\"#启动类加载器\" class=\"headerlink\" title=\"启动类加载器\"></a>启动类加载器</h4><p>启动类加载器（BootstrapClassLoader）主要加载的是 JVM 自身需要的类，这个类加载使用 C++ 语言实现的，是虚拟机自身的一部分，负责将 <code>&lt;JAVA_HOME&gt;/lib</code> 路径下的核心类库或 <code>-Xbootclasspath</code> 参数指定的路径下的 jar 包加载到内存中。</p>\n<p>注意由于虚拟机是按照文件名识别加载 jar 包的，如果文件名不被虚拟机识别，即使把 jar 包丢到 lib 目录下也无法被加载（出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类）。</p>\n<h4 id=\"扩展类加载器\"><a href=\"#扩展类加载器\" class=\"headerlink\" title=\"扩展类加载器\"></a>扩展类加载器</h4><p>扩展类加载器（ExtensionClassLoader）是指 Sun 公司（已被 Oracle 收购）实现的 sun.misc.Launcher$ExtClassLoader 类，由 Java 语言实现的，是 Launcher 的静态内部类，负责加载 <code>&lt;JAVA_HOME&gt;/lib/ext</code> 目录下或者由系统变量 <code>-Djava.ext.dir</code> 指定路径中的类库，开发者可以直接使用标准扩展类加载器。</p>\n<h4 id=\"应用程序类加载器\"><a href=\"#应用程序类加载器\" class=\"headerlink\" title=\"应用程序类加载器\"></a>应用程序类加载器</h4><p>应用程序加载器（AppClassLoader）是指 Sun 公司实现的 sun.misc.Launcher$AppClassLoader，负责加载系统类路径 <code>java -classpath</code> 或 <code>-D java.class.path</code> 指定路径下的类库，即经常用到的 classpath 路径，开发者可以直接使用应用程序类加载器，一般情况下该类加载器是程序中默认的类加载器，通过<code>ClassLoader.getSystemClassLoader()</code> 方法可以获取到该类加载器。</p>\n<h4 id=\"类加载器关系\"><a href=\"#类加载器关系\" class=\"headerlink\" title=\"类加载器关系\"></a>类加载器关系</h4><ul>\n<li>启动类加载器，由 C++ 实现，没有父类；</li>\n<li>拓展类加载器（ExtClassLoader），由 Java 语言实现，父类加载器为 null；</li>\n<li>应用程序类加载器（AppClassLoader），由 Java 语言实现，父类加载器为 ExtClassLoader；<ul>\n<li>Launcher 初始化时首先会创建 ExtClassLoader 类加载器，然后再创建 AppClassLoader 并把 ExtClassLoader 传递给它作为父类加载器。</li>\n</ul>\n</li>\n<li>自定义类加载器，父类加载器为 AppClassLoader。</li>\n</ul>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>工作原理：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>\n<p>双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码。</p>\n<p>双亲委派模式的优点：</p>\n<ul>\n<li>Java 类随着类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父类加载器已经加载该类时，子类加载器没有必要再加载一次。</li>\n<li>安全因素。可以保证 Java 核心 API 中定义类型不会被随意替换。</li>\n</ul>\n<h3 id=\"ClassLoader-源码分析\"><a href=\"#ClassLoader-源码分析\" class=\"headerlink\" title=\"ClassLoader 源码分析\"></a>ClassLoader 源码分析</h3><p>ClassLoader 是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器），这里关注一下 ClassLoader 中几个比较重要的方法。</p>\n<h4 id=\"loadClass-String\"><a href=\"#loadClass-String\" class=\"headerlink\" title=\"loadClass(String)\"></a>loadClass(String)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体看 <code>loadClass()</code> 方法，resolve 参数代表是否生成 class 对象的同时进行解析相关操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"comment\">// 先从缓存查找该 class 对象，找到就不用重新加载</span></span><br><span class=\"line\">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//如果找不到，则委托给父类加载器去加载</span></span><br><span class=\"line\">                    c = parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    <span class=\"comment\">//如果没有父类，则委托给启动加载器去加载</span></span><br><span class=\"line\">                    c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//是否需要在加载时进行解析</span></span><br><span class=\"line\">            resolveClass(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"findClass-String\"><a href=\"#findClass-String\" class=\"headerlink\" title=\"findClass(String)\"></a>findClass(String)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassNotFoundException(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当实现自定义类加载时，建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中，从前面的分析可知，<code>findClass()</code> 方法是在 <code>loadClass()</code> 方法中被调用的，当 <code>loadClass()</code> 方法中父加载器加载失败后，则会调用 <code>findClass()</code> 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是 ClassLoader 类中并没有实现 <code>findClass()</code> 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 <code>findClass()</code> 方法通常是和 <code>defineClass()</code> 方法一起使用的。</p>\n<h4 id=\"defineClass-byte-b-int-off-int-len\"><a href=\"#defineClass-byte-b-int-off-int-len\" class=\"headerlink\" title=\"defineClass(byte[] b, int off, int len)\"></a>defineClass(byte[] b, int off, int len)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Class&lt;?&gt; defineClass(String name, <span class=\"keyword\">byte</span>[] b, <span class=\"keyword\">int</span> off, <span class=\"keyword\">int</span> len,</span><br><span class=\"line\">                                     ProtectionDomain protectionDomain)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> ClassFormatError</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class=\"line\">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class=\"line\">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class=\"line\">    postDefineClass(c, protectionDomain);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>defineClass()</code> 方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中已实现该方法逻辑），通过这个方法不仅能够通过 class 文件实例化 class 对象，也可以通过其他方式实例化 class 对象，如通过网络接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象。</p>\n<p><code>defineClass()</code> 方法通常与 <code>findClass()</code> 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 <code>findClass()</code> 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 <code>defineClass()</code> 方法生成类的 Class 对象。</p>\n<p>需要注意的是，如果直接调用 <code>defineClass()</code> 方法生成类的 Class 对象，这个类的 Class 对象并没有解析（也可以理解为链接阶段，毕竟解析是链接的最后一步），其解析操作需要等待初始化阶段进行。</p>\n<h4 id=\"resolveClass-Class≺-≻-c\"><a href=\"#resolveClass-Class≺-≻-c\" class=\"headerlink\" title=\"resolveClass(Class≺?≻ c)\"></a>resolveClass(Class≺?≻ c)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">resolveClass</span><span class=\"params\">(Class&lt;?&gt; c)</span> </span>&#123;    </span><br><span class=\"line\">    resolveClass0(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用该方法可以让类的 Class 对象在创建完成的同时也被解析。</p>\n<h3 id=\"URLClassLoader\"><a href=\"#URLClassLoader\" class=\"headerlink\" title=\"URLClassLoader\"></a>URLClassLoader</h3><p>ClassLoader 是一个抽象类，很多方法没有实现，比如 <code>findClass()</code>、<code>findResource()</code>等，而 URLClassLoader 这个类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节码流等功能。</p>\n<p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 <code>findClass()</code> 方法及其获取字节码流的方式。</p>\n<p>ExtClassLoader 和 AppClassLoader，这两个类都继承自 URLClassLoader，是 <code>sun.misc.Launcher</code> 的静态内部类。sun.misc.Launcher 主要被系统用于启动主应用程序，ExtClassLoader 和 AppClassLoader 都是由 sun.misc.Launcher 创建的。</p>\n<h3 id=\"显示加载与隐式加载\"><a href=\"#显示加载与隐式加载\" class=\"headerlink\" title=\"显示加载与隐式加载\"></a>显示加载与隐式加载</h3><p>class 文件的显示加载与隐式加载的方式是指 JVM 加载 class 文件到内存的方式。</p>\n<p>显示加载：在代码中通过调用 ClassLoader 加载 class 对象，如直接使用 <code>Class.forName(name)</code> 或<code>this.getClass().getClassLoader().loadClass()</code> 加载 class 对象。</p>\n<p>隐式加载：通过虚拟机自动加载到内存中，如在加载某个类的 class 文件时，该类的 class 文件中引用了另外一个类的对象，此时额外引用的类将通过 JVM 自动加载到内存中。</p>\n<h3 id=\"线程上下文类加载器\"><a href=\"#线程上下文类加载器\" class=\"headerlink\" title=\"线程上下文类加载器\"></a>线程上下文类加载器</h3><p>在 Java 应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供具体实现，常见的 SPI 有 JDBC、JNDI 等，这些 SPI 的接口属于 Java 核心库，一般存在 rt.jar 包中，由 BootstrapClassLoader 加载，而 SPI 的第三方实现类则是作为 Java 应用所依赖的 jar 包被存放在 classpath 路径下，由 AppClassLoader 加载。</p>\n<p>BootstrapClassLoader 是无法找到 SPI 的实现类的（因为它只加载 Java 的核心库），按照双亲委派模型，BootstrapClassLoader 无法委派 AppClassLoader 去加载类。也就是说，类加载器的双亲委派模式无法解决这个问题。</p>\n<p>线程上下文类加载器（ ThreadContextClassLoader ）是从 JDK 1.2 开始引入的，可以通过 java.lang.Thread 类中的 <code>getContextClassLoader()</code> 和 <code>setContextClassLoader(ClassLoader cl)</code> 方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader），在线程中运行的代码可以通过此类加载器来加载类和资源。</p>\n<p>线程上下文类加载器从根本解决了一般应用不能违背双亲委派模式的问题，使得 Java 类加载体系显得更灵活。</p>\n<h4 id=\"Tomcat-与-Spring-的类加载器案例\"><a href=\"#Tomcat-与-Spring-的类加载器案例\" class=\"headerlink\" title=\"Tomcat 与 Spring 的类加载器案例\"></a>Tomcat 与 Spring 的类加载器案例</h4><p>在 Tomcat 目录结构中，有三组目录（ /common/*，/server/* 和 /shared/* ）可以存放公用 Java 类库，此外还有第四组 Web 应用程序自身的目录 /WEB-INF/*，把 Java 类库放置在这些目录中的含义分别是：</p>\n<ul>\n<li>放置在 common 目录中的类库可被 Tomcat 和所有的 Web 应用程序共同使用；</li>\n<li>放置在 server 目录中的类库可被 Tomcat 使用，但对所有的 Web 应用程序都不可见；</li>\n<li>放置在 shared 目录中的类库可被所有的 Web 应用程序共同使用，但对 Tomcat 自己不可见；</li>\n<li>放置在 /WebApp/WEB-INF目录中的类库仅仅可以被此 Web 应用程序使用，对 Tomcat 和其他 Web 应用程序都不可见。</li>\n</ul>\n<p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat 自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现，如下图所示：</p>\n<img src=\"/2019/11/05/Java%20类加载机制/Tomcat类加载器.png\">\n<p>灰色背景的 3 个类加载器是 JDK 默认提供的类加载器；而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebAppClassLoader 则是 Tomcat 自己定义的类加载器。</p>\n<ul>\n<li>CommonClassLoader：加载 /common/* 中的类库；</li>\n<li>CatalinaClassLoader：加载 /server/* 中的类库；</li>\n<li>SharedClassLoader：加载 /shared/* 中的类库；</li>\n<li>WebAppClassLoader： 加载 /WebApp/WEB-INF/* 中的类库。</li>\n</ul>\n<p>其中 WebApp 类加载器和 JSP 类加载器通常会存在多个实例，每一个 Web 应用程序对应一个 WebApp 类加载器，每一个 JSP 文件对应一个 JSP 类加载器。</p>\n<p>从图中的委派关系中可以看出，CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 自己能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。而 JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个 Class，它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。</p>\n<p>如果有 10 个 Web 应用程序都用到 Spring，可以把 Spring 的 jar 包放到 common 或 shared 目录下让这些程序共享。Spring 的作用是管理每个 Web 应用程序的 Bean，getBean 时自然要能访问到应用程序的类，而用户的程序显然是放在 /WebApp/WEB-INF 目录中的（由 WebAppClassLoader 加载），那么在 CommonClassLoader 或 SharedClassLoader 中的 Spring 容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的 Class 呢？</p>\n<p>答案是 Spring 使用线程上下文类加载器（ TCCL）来加载类，而 TCCL 默认设置为 WebAppClassLoader，也就是说哪个 WebApp 应用调用了 Spring，Spring 就去获取该应用对应的 WebAppClassLoader 来加载 Bean。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/73413292\" target=\"_blank\" rel=\"noopener\">深入理解Java类加载器(ClassLoader)</a></li>\n<li><a href=\"https://blog.csdn.net/yangcheng33/article/details/52631940\" target=\"_blank\" rel=\"noopener\">真正理解线程上下文类加载器（多案例分析）</a></li>\n</ol>\n","categories":["Java"],"tags":["Java","JVM"]},{"title":"Java 序列化与反序列化","url":"http://yoursite.com/2019/10/20/Java-序列化与反序列化/","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>序列化是将 Java 对象转换成与平台无关的二进制流，而反序列化则是将二进制流恢复成原来的 Java 对象，二进制流便于保存到磁盘上或者在网络上传输。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ul>\n<li>永久性保存对象，保存对象的字节序列到本地文件或者数据库中</li>\n<li>通过序列化以字节流的形式使对象在网络中进行传递和接收</li>\n<li>通过序列化在进程间传递对象</li>\n</ul>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>当序列化某个类的对象时，需要让该类实现 <strong>Serializable</strong> 接口或者 <strong>Externalizable</strong> 接口。</p>\n<h4 id=\"实现-Serializable-接口\"><a href=\"#实现-Serializable-接口\" class=\"headerlink\" title=\"实现 Serializable 接口\"></a>实现 Serializable 接口</h4><p>如果实现 Serializable 接口，由于该接口只是个 “标记接口”，接口中不含任何方法，序列化是使用 ObjectOutputStream（处理流）中的 <code>writeObject(obj)</code> 方法将 Java 对象输出到输出流中，反序列化是使用 ObjectInputStream 中的 <code>readObject(in)</code> 方法将输入流中的 Java 对象还原出来。</p>\n<h5 id=\"序列化步骤\"><a href=\"#序列化步骤\" class=\"headerlink\" title=\"序列化步骤\"></a>序列化步骤</h5><ol>\n<li>创建一个 ObjectOutputStream 输出流；</li>\n<li>调用 ObjectOutputStream 对象的 <code>writeObject()</code> 输出可序列化对象。</li>\n</ol>\n<h5 id=\"反序列化步骤\"><a href=\"#反序列化步骤\" class=\"headerlink\" title=\"反序列化步骤\"></a>反序列化步骤</h5><ol>\n<li>创建一个 ObjectInputStream 输入流；</li>\n<li>调用 ObjectInputStream 对象的 <code>readObject()</code> 得到序列化的对象。</li>\n</ol>\n<h5 id=\"自定义序列化\"><a href=\"#自定义序列化\" class=\"headerlink\" title=\"自定义序列化\"></a>自定义序列化</h5><p>实现 Serializable 接口的类可以实现自定义序列化，只需要在类中提供下面这三个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(java.io.ObjectOutStream out)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(java.io.ObjectInputStream in)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObjectNoData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重写 <code>writeObject()</code> 与 <code>readObject()</code> 方法，可以选择哪些属性需要序列化， 哪些属性不需要。如果<code>writeObject()</code>  使用某种规则序列化，则相应的<code>readObject()</code> 需要相反的规则反序列化，以便能正确反序列化出对象。</li>\n<li><code>readObjectNoData()</code> 方法是在序列化流不完整、序列化和反序列化版本不一致导致不能正确反序列时调用的容错方法。</li>\n<li><code>writeReplace()</code>：在序列化时，会先调用此方法，再调用 <code>writeObject()</code> 方法。此方法可将任意对象代替目标序列化对象。</li>\n<li><code>readResolve()</code>：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在 <code>readeObject()</code> 后调用。<code>readResolve()</code> 常用来反序列单例类，保证单例类的唯一性。</li>\n</ul>\n<p>注意：<code>readResolve()</code> 与 <code>writeReplace()</code> 的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于 final 修饰的类重写 <code>readResolve()</code> 方法没有问题；否则，重写 <code>readResolve()</code> 使用 private 修饰。</p>\n<h5 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date birthday;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> String gender;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">6849794470754667710L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name,<span class=\"keyword\">int</span> age,Date date,String gender)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday=date;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gender=gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//省略 get\\set 方法</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", age=\"</span> + age +</span><br><span class=\"line\">                <span class=\"string\">\", gender=\"</span> + gender +</span><br><span class=\"line\">                <span class=\"string\">\", birthday=\"</span> + birthday +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializableDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User(<span class=\"string\">\"chris\"</span>,<span class=\"number\">22</span>,<span class=\"keyword\">new</span> Date(),<span class=\"string\">\"male\"</span>);</span><br><span class=\"line\">        System.out.println(user.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Write Obj to File</span></span><br><span class=\"line\">        ObjectOutputStream oos = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            oos = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"tempFile\"</span>));</span><br><span class=\"line\">            oos.writeObject(user);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Read Obj from File</span></span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"tempFile\"</span>);</span><br><span class=\"line\">        ObjectInputStream ois = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ois = <span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> FileInputStream(file));</span><br><span class=\"line\">            User newUser = (User) ois.readObject();</span><br><span class=\"line\">            System.out.println(newUser);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//输出结果，注意 gender =null 是 因为被 transient 修饰</span><br><span class=\"line\">User&#123;name=&apos;chris&apos;, age=22, gender=male, birthday=Tue Dec 03 21:48:48 CST 2019&#125;</span><br><span class=\"line\">User&#123;name=&apos;chris&apos;, age=22, gender=null, birthday=Tue Dec 03 21:48:48 CST 2019&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实现-Externalizable-接口\"><a href=\"#实现-Externalizable-接口\" class=\"headerlink\" title=\"实现 Externalizable 接口\"></a>实现 Externalizable 接口</h4><p>如果实现 Externalizable接口，该接口继承自 Serializable 接口，在 Java Bean 类中实现接口中的<code>writeExternal(out)</code> 和 <code>readExternal(in)</code> 方法，需要注意的是<strong>必须提供默认的无参构造函数</strong>，因为在反序列化的时候需要<strong>反射</strong>创建对象，否则反序列化失败。可以在序列化时选择如何序列化，比如对某个属性加密处理。</p>\n<h5 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Externalizable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age=<span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> String gender;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    必须提供无参构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//省略 get\\set 方法</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeExternal</span><span class=\"params\">(ObjectOutput out)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        out.writeObject(name);</span><br><span class=\"line\">        out.writeInt(age);</span><br><span class=\"line\">        out.writeObject(gender);</span><br><span class=\"line\">        out.writeObject(date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readExternal</span><span class=\"params\">(ObjectInput in)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = in.readObject().toString();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = in.readInt();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gender=in.readObject().toString();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.date=(Date) in.readObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Name:\"</span>+<span class=\"keyword\">this</span>.name</span><br><span class=\"line\">                +<span class=\"string\">\"  Age:\"</span>+<span class=\"keyword\">this</span>.age</span><br><span class=\"line\">                +<span class=\"string\">\"  Sex:\"</span>+<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\">                +<span class=\"string\">\"  Date\"</span>+<span class=\"keyword\">this</span>.date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalizableDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Person person=<span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">        person.setName(<span class=\"string\">\"dawson\"</span>);</span><br><span class=\"line\">        person.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">        person.setDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        person.setGender(<span class=\"string\">\"male\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"开始：\"</span>+person.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">        File file=<span class=\"keyword\">new</span> File(<span class=\"string\">\"hello.txt\"</span>);</span><br><span class=\"line\">        ObjectOutput objectOutput=<span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(file));</span><br><span class=\"line\">        ObjectInput objectInput=<span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> FileInputStream(file));</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            person.writeExternal(objectOutput);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Person newPerson=<span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            newPerson.readExternal(objectInput);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"结束：\"</span>+newPerson.toString());</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (ClassNotFoundException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//输出结果</span><br><span class=\"line\">开始：Name:dawson  Age:22  Sex:male  DateTue Dec 03 21:53:12 CST 2019</span><br><span class=\"line\">结束：Name:dawson  Age:22  Sex:male  DateTue Dec 03 21:53:12 CST 2019</span><br></pre></td></tr></table></figure>\n<h4 id=\"两种序列化方式对比\"><a href=\"#两种序列化方式对比\" class=\"headerlink\" title=\"两种序列化方式对比\"></a>两种序列化方式对比</h4><table>\n<thead>\n<tr>\n<th>Serializable接口</th>\n<th>Externalizable接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>系统自动存储必要的信息</td>\n<td>自定义存储信息</td>\n</tr>\n<tr>\n<td>Java默认支持，易于实现，只需实现接口即可</td>\n<td>需要实现两个方法</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"版本问题\"><a href=\"#版本问题\" class=\"headerlink\" title=\"版本问题\"></a>版本问题</h3><p>反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？Java序列化提供了一个 <code>private static final long serialVersionUID</code> 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化。</p>\n<p>如果反序列化使用的class的版本号与序列化时使用的不一致，反序列化会报 InvalidClassException 异常。</p>\n<p>如果不显式定义这个 SerialVersionUID，Java 虚拟机会根据类的信息自动生成，修改前和修改后的计算结果往往不同，造成版本不兼容而发生反序列化失败，另外由于平台的差异性，在程序移植中也可能出现无法反序列化。</p>\n<p>强大的 IDE 工具，也都有自动生成 SeriaVersionUID 的方法。JDK 中自带的也有生成 SeriaVersionUID 值的工具 serialver.exe，使用 serialver 类名（编译后） 命令就能生成该类的 SeriaVersionUID 值。</p>\n<p>什么情况下需要修改 serialVersionUID ？</p>\n<ol>\n<li>如果只是修改方法，反序列化不受影响，则无需修改版本号；</li>\n<li>如果只是修改静态变量，以及 transient 修饰的变量，反序列化不受影响，无需修改版本号；</li>\n<li>如果修改非静态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改 serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li>\n</ol>\n<h4 id=\"序列化算法\"><a href=\"#序列化算法\" class=\"headerlink\" title=\"序列化算法\"></a>序列化算法</h4><p>所有保存到磁盘的对象都有一个序列化编码号，当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。如果此对象已经序列化过，则直接输出编号即可。</p>\n<p>由于序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</p>\n<h3 id=\"ArrayList-序列化\"><a href=\"#ArrayList-序列化\" class=\"headerlink\" title=\"ArrayList 序列化\"></a>ArrayList 序列化</h3><p>首先看一下 ArrayList 源码，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ArrayList 实现了 <code>java.io.Serializable</code> 接口，可以进行序列化及反序列化。从源码中可知 elementData 是 transient 的，是无法通过序列化进行持久化的，但是事实上 ArrayList 是可以序列化的，原因如下：</p>\n<p>在 ArrayList 中定义了来个方法 <code>writeObject()</code> 和 <code>readObject()</code>。</p>\n<blockquote>\n<p>在序列化过程中，如果被序列化的类中定义了 <code>writeObject</code> 和 <code>readObject</code> 方法，虚拟机会试图调用对象类里的 <code>writeObject</code> 和 <code>readObject</code> 方法，进行用户自定义的序列化和反序列化。<br>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 <code>defaultWriteObject</code> 方法以及 ObjectInputStream 的 <code>defaultReadObject</code> 方法。<br>用户自定义的 <code>writeObject</code> 和 <code>readObject</code> 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p>\n</blockquote>\n<p>为什么 ArrayList 要用这种方式来实现序列化呢？</p>\n<p>ArrayList 实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化 99 个 null 元素。为了保证在序列化的时候不会将这么多 null 同时进行序列化，ArrayList 把元素数组设置为 transient。</p>\n<p>因此为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList 使用 transient 来声明<code>elementData</code>。 但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写 <code>writeObject</code> 和 <code>readObject</code> 方法的方式把其中的元素保留下来。</p>\n<ul>\n<li><code>writeObject</code> 方法把 elementData 数组中的元素遍历的保存到输出流（ObjectOutputStream）中。</li>\n<li><code>readObject</code> 方法从输入流（ObjectInputStream）中读出对象并保存赋值到 elementData 数组中。</li>\n</ul>\n<p>虽然 ArrayList 中写了 <code>writeObject</code> 和 <code>readObject</code> 方法，但是这两个方法并没有显示被调用（两个方法都是 private 的）。那么如果一个类中包含 <code>writeObject</code> 和 <code>readObject</code> 方法，那么这两个方法是怎么被调用的呢?</p>\n<p>ObjectOutputStream 会调用这个类的 <code>writeObject()</code> 方法进行序列化，ObjectInputStream 会调用相应的 <code>readObject()</code> 方法进行反序列化。</p>\n<p>那么 ObjectOutputStream 又是如何知道一个类是否实现了 <code>writeObject()</code> 方法呢？又是如何自动调用该类的 <code>writeObject()</code> 方法呢？答案是通过<strong>反射</strong>机制实现的。</p>\n<p>接下来具体分析一下 ArrayList 中的 <code>writeObject</code> 和 <code>readObject</code> 方法到底是如何被调用的呢？<br>为了节省篇幅，这里给出 ObjectOutputStream 的 <code>writeObject</code> 的调用栈：<br><strong>writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObject</strong><br>这里看一下 <code>invokeWriteObject</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invokeWriteObject</span><span class=\"params\">(Object obj, ObjectOutputStream out)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> IOException, UnsupportedOperationException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (writeObjectMethod != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                writeObjectMethod.invoke(obj, <span class=\"keyword\">new</span> Object[]&#123; out &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InvocationTargetException ex) &#123;</span><br><span class=\"line\">                Throwable th = ex.getTargetException();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (th <span class=\"keyword\">instanceof</span> IOException) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> (IOException) th;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    throwMiscException(th);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IllegalAccessException ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// should not occur, as access checks have been suppressed</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>writeObjectMethod.invoke(obj, new Object[]{ out });</code> 是关键，通过反射的方式调用 <code>writeObjectMethod</code> 方法。</p>\n<p>Serializable 明明就是一个空的接口，它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢？</p>\n<p>在进行序列化操作时，会判断要被序列化的类是否是 <strong>Enum</strong>、<strong>Array</strong>和<strong>Serializable</strong> 类型，如果不是则直接抛出 <strong>java.io.NotSerializableException</strong>。</p>\n<p>具体看一下 ObjectOutputStream 的 <code>writeObject</code> 的调用栈：</p>\n<p><strong>writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObject</strong></p>\n<p><code>writeObject0</code> 方法中有这么一段代码，从中可以看出具体如何判断类是否可以实现序列化：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">    writeString((String) obj, unshared);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cl.isArray()) &#123;</span><br><span class=\"line\">    writeArray(obj, desc, unshared);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Enum) &#123;</span><br><span class=\"line\">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Serializable) &#123;</span><br><span class=\"line\">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extendedDebugInfo) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NotSerializableException(</span><br><span class=\"line\">            cl.getName() + <span class=\"string\">\"\\n\"</span> + debugInfoStack.toString());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NotSerializableException(cl.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>需要注意的是反序列化读取的仅仅是 Java 对象中的数据，而不是包含 Java 类的信息，所以在反序列化时还需要对象所属类的字节码（class）文件，否则会出现 <code>ClassNotFoundException</code> 异常。</li>\n<li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现 Serializable 接口。</li>\n<li>如果子类实现 Serializable 接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛 InvalidClassException 异常。要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。</li>\n<li>对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</li>\n<li>注意序列化属性的顺序要和属性反序列化中的顺序一样，否则在反序列化时不能恢复出原来的对象。</li>\n<li>如果一个可序列化的类的成员不是基本类型，也不是 String 类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。</li>\n<li>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</li>\n<li>单例类序列化，需要重写 <code>readResolve()</code> 方法；否则会破坏单例原则。</li>\n</ol>\n<h3 id=\"Java-序列化的方式\"><a href=\"#Java-序列化的方式\" class=\"headerlink\" title=\"Java 序列化的方式\"></a>Java 序列化的方式</h3><h4 id=\"Java-原生序列化\"><a href=\"#Java-原生序列化\" class=\"headerlink\" title=\"Java 原生序列化\"></a>Java 原生序列化</h4><p>缺点：</p>\n<ol>\n<li>无法跨语言：Java 语言序列化的字节数组，其他语言无法进行反序列化。</li>\n<li>序列化后码流太大。</li>\n<li>序列化性能太差：采用同步阻塞 IO，效率差。 </li>\n</ol>\n<h4 id=\"Kryo\"><a href=\"#Kryo\" class=\"headerlink\" title=\"Kryo\"></a>Kryo</h4><p>Kryo 是一个快速有效的 Java 二进制对象序列化框架。具有更高效、序列化之后字节数据更小、更易用等特点。应用场景有对象存入文件、数据库，或者在网络中传输。</p>\n<p>Kryo的 Output 和 Input 类，也是一个装饰器类，可以内置 Java IO 的InputStream 和 OutputStream，也可以实现网络传输和存入文件。Kryo 广泛用在 Rpc 框架中，如 Dubbo 框架。</p>\n<ul>\n<li>Rpc 框架比较关注的是性能，扩展性，通用性，Kryo 的性能与其他几种序列化方式对比中表现较好；</li>\n<li>Kryo 的 API 比较友好；</li>\n<li>不过，Kryo 兼容性不是很好，使用时应注意序列化和反序列化两边的类结构是否一致；</li>\n<li>Kryo 序列化时，不需要对象实现 Serializable。</li>\n</ul>\n<h4 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h4><p>Hessian 是一个基于 HTTP 的高性能 RPC 框架，其序列化算法叫 Hessian 协议，是业界公认的一种高效率高压缩比的序列化方式，如：Dubbo 框架就支持 Hessian 序列化方式。</p>\n<ul>\n<li>Hessian 序列化后的数据要比 Kryo 序列化后的数据大，但要比 Java 原生序列化方式好很多；</li>\n<li>Hessian 跨语言支持比较好；</li>\n<li>Hessian 需要实体类实现 Serializable 接口</li>\n</ul>\n<h4 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h4><p>XML 是一种很常见的数据保存方式，XML具有优秀的跨平台、可读性好的特点，可用于构建基本的 Web Services 平台，不同于 RPC 框架，Web Services 是基于 HTTP 协议的，通过 SOAP 协议，使运行在不同的操作系统并使用不同的技术和编程语言的应用程序可以互相进行通信。SOAP 是基于 XML 为序列化和反序列化协议的结构化消息传递协议。Web Services 还使用网络服务描述语言—WSDL（Web Services Description Language），用于描述 Web Services 以及如何访问 Web Services，WSDL 基于 XML 语言格式。Web Services 使用 XML 来编解码数据，并使用 SOAP 来传输数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XmlSerializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        XmlSerializable serializable=<span class=\"keyword\">new</span> XmlSerializable();</span><br><span class=\"line\">        serializable.WriteObject();</span><br><span class=\"line\">        serializable.ReadObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">WriteObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        User user=<span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setAge(<span class=\"number\">88</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"KKo\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        XStream xStream=<span class=\"keyword\">new</span> XStream();</span><br><span class=\"line\">        xStream.alias(<span class=\"string\">\"User\"</span>,User.class);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            FileOutputStream fileOutputStream=<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        ObjectOutputStream objectOutputStream=new ObjectOutputStream(fileOutputStream);</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.writeObject(user);</span></span><br><span class=\"line\">            xStream.toXML(user,fileOutputStream);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ReadObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        User user=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        FileInputStream fileInputStream=<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        ObjectInputStream objectInputStream=new ObjectInputStream(fileInputStream);</span></span><br><span class=\"line\"><span class=\"comment\">//        user=(User)objectInputStream.readObject();</span></span><br><span class=\"line\">        XStream xStream=<span class=\"keyword\">new</span> XStream();</span><br><span class=\"line\">        xStream.alias(<span class=\"string\">\"User\"</span>,User.class);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            user=(User) xStream.fromXML(fileInputStream);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h4><p>JSON（ JavaScript Object Notation ）是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。使用最多的场景是用于 Web 服务和客户端浏览器之间进行数据交换，如：前端使用 Ajax 以 Json 格式向服务端发起请求，服务端以 Json 格式响应给客户端，客户端根据 Json 数据格式解析响应内容。当然，在网络中传输仍然需要转化成字节，不过很多语言都提供类包支持将 JSON 串转化成字节流，（注：JSON 串相当于一个满足 JSON 数据格式的字符串），如 Java 的 <strong>FastJson</strong>、<strong>Jackson</strong>、<strong>Gson</strong>，JavaScript 的 eval() 函数等。还有一些 Nosql 数据库、消息队列也支持 Json 序列化方式，如 Redis 存储对象时，使用 JSON 格式，使数据支持跨平台、可读性也更强。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonSerializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        User user=<span class=\"keyword\">new</span> User(<span class=\"string\">\"James\"</span>,<span class=\"number\">444</span>,<span class=\"keyword\">null</span>,<span class=\"string\">\"male\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"序列化前：\"</span>+user);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ObjectMapper objectMapper=<span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                bytes=objectMapper.writeValueAsBytes(user);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            User users1=<span class=\"keyword\">new</span> User();</span><br><span class=\"line\">            users1=objectMapper.readValue(bytes,User.class);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"序列化后：\"</span>+user);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (JsonMappingException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (JsonGenerationException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ProtoBuff\"><a href=\"#ProtoBuff\" class=\"headerlink\" title=\"ProtoBuff\"></a>ProtoBuff</h4><p>ProtoBuff 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>\n<p>优点：</p>\n<ol>\n<li>跨语言</li>\n<li>序列化后数据占用空间比 Json 小，Json 有一定的格式，在数据量上还有可以压缩的空间。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出内容。</li>\n</ol>\n<p>Protostuff 是一个基于 ProtoBuff 实现的序列化方法，它较于 ProtoBuff 最明显的好处是，在几乎不损耗性能的情况下做到了不用我们写 .proto 文件来实现序列化。</p>\n<p>与 Thrift 的对比：</p>\n<ul>\n<li>两者语法类似，都支持版本向后兼容和向前兼容。</li>\n<li>Thrift 侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套 RPC 解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。</li>\n<li>ProtoBuff 主要是一种序列化机制，在数据序列化上进行性能比较，ProtoBuff 相对较好。</li>\n</ul>\n<h4 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h4><p>目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。</p>\n<p>Thrift 是由 Facebook 开发的远程服务调用框架 Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://wenshixin.gitee.io/blog/2018/09/02/Java%E5%9F%BA%E7%A1%80-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">Java基础-序列化与反序列化</a></li>\n<li><a href=\"https://www.hollischuang.com/archives/1140\" target=\"_blank\" rel=\"noopener\">深入分析Java的序列化与反序列化</a></li>\n<li><a href=\"https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf\" target=\"_blank\" rel=\"noopener\">java序列化，看这篇就够了</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1446854\" target=\"_blank\" rel=\"noopener\">简述几种序列化方式</a></li>\n</ol>\n","categories":["Java"],"tags":["Java"]},{"title":"从计算机内存模型到 Java 内存模型","url":"http://yoursite.com/2019/10/10/从计算机内存模型到-Java-内存模型/","content":"<h3 id=\"计算机内存模型\"><a href=\"#计算机内存模型\" class=\"headerlink\" title=\"计算机内存模型\"></a>计算机内存模型</h3><h4 id=\"CPU-缓存\"><a href=\"#CPU-缓存\" class=\"headerlink\" title=\"CPU 缓存\"></a>CPU 缓存</h4><img src=\"/2019/10/10/从计算机内存模型到-Java-内存模型/CPU缓存架构.jpg\">\n<p>缓存可以缩小 CPU 与低速内存之间的差距。以三层缓存架构为例：</p>\n<ul>\n<li>L1 Cache：最接近 CPU, 容量最小（如32K、64K、256K等）、速度最高，每个核上都有一个L1 Cache。</li>\n<li>L2 Cache：容量更大（如256K）、速度较低，一般情况下，每个核上都有一个独立的 L2 Cache。</li>\n<li>L3 Cache：最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。</li>\n</ul>\n<p><strong>什么是缓存行？</strong></p>\n<p>缓存是由缓存行组成的，通常是 64 字节（常用处理器的缓存行是 64 字节的，比较老的处理器缓存行是 32 字节），并且它有效地引用主内存中的一块地址。</p>\n<h4 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h4><p>在多核 CPU 多线程的场景中，每个核都至少有一个 L1 缓存。多个线程访问进程中的某个共享内存，且多个线程分别在不同的核心上执行，则每个核心都会在各自的 cache 中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的 cache 之间的数据就有可能不同。也就是说，在多核 CPU 中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p>\n<p><strong>如何解决缓存一致性问题呢？</strong></p>\n<p>第一种方式是通过在总线加 LOCK 锁的方式。在早期的 CPU 当中，是通过在总线上加 LOCK 锁的形式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能访问该变量。但是由于在对总线加锁期间，其他 CPU 无法访问内存，会导致效率低下。</p>\n<p>第二种方式是通过缓存一致性协议（Cache Coherence Protocol）。缓存一致性协议（Cache Coherence Protocol），最出名的就是 Intel 的 MESI 协议，MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。</p>\n<h4 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h4><p>重排序问题有两种场景：编译器编译时的优化、处理器执行时的乱序优化。</p>\n<blockquote>\n<p>CPU 可能会对输入的代码进行乱序执行优化，然后在计算之后再将乱序执行的结果进行重组，保证该结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序与代码的输入顺序一致。因此，如果一个计算任务依赖于另一个计算任务的结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>\n</blockquote>\n<p>只要不影响程序单线程、顺序执行的结果，就可以对两个指令重排序。指令重排序可以节省大量等待时间，提高了处理器的性能。</p>\n<p>然而并不是所有的指令都是简单的读或者写，在多线程环境下，指令重排序会导致一系列的问题。内存屏障解决了硬件层面的可见性与重排序问题。</p>\n<h4 id=\"MESI-协议和-ROF-指令\"><a href=\"#MESI-协议和-ROF-指令\" class=\"headerlink\" title=\"MESI 协议和 ROF 指令\"></a>MESI 协议和 ROF 指令</h4><p>MESI 协议的核心思想是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么就会从内存重新读取。 </p>\n<p>在 MESI 协议中，每个 Cache line 有 4 个状态，可用 2 个 bit 表示，分别是： </p>\n<ul>\n<li><strong>M(Modified)</strong> ：这行数据有效且被修改，和内存中的数据不一致，数据只存在于本 Cache 中；</li>\n<li><strong>E(Exclusive)</strong> ：这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中；</li>\n<li><strong>S(Shared)</strong> ：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中；</li>\n<li><strong>I(Invalid)</strong> ：这行数据无效。</li>\n</ul>\n<p>在 MESI 协议中，每个 Cache 的 Cache 控制器不仅知道自己的读写操作，而且也监听其它 Cache 的读写操作。每个 Cache line 所处的状态根据本核和其它核的读写操作在 4 个状态间进行迁移，如下图：</p>\n<img src=\"/2019/10/10/从计算机内存模型到-Java-内存模型/MESI状态转移.jpg\">\n<ul>\n<li><p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p>\n</li>\n<li><p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p>\n</li>\n<li><p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：</p>\n<ul>\n<li>其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态；</li>\n<li>其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</li>\n</ul>\n</li>\n<li><p>远程读（Remote Read）：假设有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p>\n</li>\n<li>远程写（Remote Write）： c2 得到 c1 的数据后进行本地写，此时 c1 也拥有这份数据的拷贝，这种情况下 c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</li>\n</ul>\n<p>AMD 的 Opteron 处理器使用从 MESI 中演化出的 MOESI 协议，O(Owned) 是 MESI 中 S 和 M 的一个合体，表示本 Cache line 被修改，和内存中的数据不一致，不过其它的核可以有这份数据的拷贝，状态为 S。Intel 的 core i7 处理器使用从 MESI 中演化出的 MESIF 协议，F(Forward) 从 Share 中演化而来，一个 Cache line 如果是 Forward 状态，它可以把数据直接传给其它内核的 Cache，而 Share 则不能。</p>\n<blockquote>\n<p>什么时候会发送 RFO 请求呢？</p>\n<ul>\n<li>线程的工作从一个处理器移到另一个处理器，它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送 RFO 请求。</li>\n<li>两个不同的处理器都需要操作相同的缓存行。（如上面“远程写”中所述）</li>\n</ul>\n</blockquote>\n<p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存切换状态时，其他缓存收到消息完成各自的切换并且发出回应消息的时间中 <strong>CPU 都会等待所有缓存响应完成</strong>，这种阻塞都会导致各种各样的性能问题和稳定性问题。</p>\n<p>为了解决这种问题，引入了 Store Buffer 和 Invalidate Queue。</p>\n<img src=\"/2019/10/10/从计算机内存模型到-Java-内存模型/MESI协议.png\">\n<h4 id=\"Store-Buffer-和-Invalidate-Queue\"><a href=\"#Store-Buffer-和-Invalidate-Queue\" class=\"headerlink\" title=\"Store Buffer 和 Invalidate Queue\"></a>Store Buffer 和 Invalidate Queue</h4><p>Store Buffer：处理器把想要写入到主存的值先写到 Store Buffer，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交。</p>\n<p>但这样存在两个问题：</p>\n<p>一是当前 CPU 需要读取最新信息，而此时最新信息却并不在 Cache。这种情况的解决方案是当前 CPU 核如果要读 Cache 中的数据，需要先扫描 Store Buffer 之后再读取 Cache。 ( 称为 <strong>Store Forwarding</strong>)</p>\n<p>二是保存什么时候会完成，这个并没有任何保证。因为存在指令重排序问题，这样会导致其他的 CPU 会读到跟程序中写入的顺序不一样的结果。</p>\n<p>然而，Store buffer 空间有限，当存满后 CPU 还需等待响应。为此引入 Invalidate Queue：</p>\n<ol>\n<li>对于所有的收到的 Invalidate 请求，Invalidate Acknowlege消息必须立刻发送；</li>\n<li>Invalidate 并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行；</li>\n<li>处理器不会发送任何消息给所处理的缓存条目，直到它处理 Invalidate。</li>\n</ol>\n<p>为了解决 CPU 间消息时序的不确定性，还有 store buffer 存储写入操作的延迟性的问题，引入内存屏障。内存屏障分为两种：</p>\n<ol>\n<li><strong>写屏障 Store Memory Barrier</strong> 是一条告诉处理器在执行写入指令之前，执行所有已经在存储缓存（store buffer）中的保存的指令，以让数据被其他 CPU 可见。</li>\n<li><strong>读屏障 Load Memory Barrier</strong> 是一条告诉处理器在执行任何的读入前，先执行所有已经在失效队列（invalidate queue）中的失效操作的指令，以保证缓存中的数据失效。</li>\n</ol>\n<p><strong>内存屏障的作用</strong>：</p>\n<ol>\n<li>阻止屏障两侧的指令重排序；</li>\n<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>\n</ol>\n<h4 id=\"伪共享问题\"><a href=\"#伪共享问题\" class=\"headerlink\" title=\"伪共享问题\"></a>伪共享问题</h4><p>在程序运行的过程中，缓存每次更新都从主内存中加载连续的 64 个字节。因此，如果访问一个 long 类型（8 字节）的数组时，当<strong>数组</strong>中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中。（空间局部性）</p>\n<p>伪共享：当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>\n<p>如何解决伪共享问题呢？</p>\n<p>一是采用缓存行填充（Padding），如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePopularObject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> usefulVal;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> t1, t2, t3, t4, t5, t6, t7 = <span class=\"number\">1L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">preventOptmisation</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> t1 + t2 + t3 + t4 + t5 + t6 + t7;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二是采用注解。Java 8 中可以使用 @sun.misc.Contended 注解。使用注解时需要在 JVM 启动参数加上 <code>-XX:-RestrictContended</code> 才会生效，<code>-XX:ContendedPaddingWidth</code> 可以设置填充的字节数。默认情况下 JVM 会为每个加该注解的字段分配 128 字节，为什么不是 64 字节呢？主要考虑到预读，当处理器从主存储器读取指令或数据块时，就会进行预读。 预读会同时占用 2 条 Cache Line，因此必须加倍填充。</p>\n<p>ConcurrentHashMap 中 <code>size()</code> 方法使用的是分段的思想来构造的，每个段使用的类是 CounterCell，它的类上就有 @sun.misc.Contended 注解；除了这个类， LongAdder 也使用了这个注解避免伪共享。</p>\n<h3 id=\"Java-内存模型\"><a href=\"#Java-内存模型\" class=\"headerlink\" title=\"Java 内存模型\"></a>Java 内存模型</h3><p>为了解决缓存一致性以及乱序排序优化的问题，这就有了内存模型。</p>\n<p>Java内存模型（Java Memory Model，JMM）定义了共享内存系统中多线程读写操作行为的规范，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>\n<img src=\"/2019/10/10/从计算机内存模型到-Java-内存模型/Java内存模型.png\">\n<p>Java内存模型规定了所有的变量（变量包括实例字段、静态字段，但不包括局部变量和方法参数）都存储在主内存中，这里的主内存跟计算机内存模型中的主内存类似，但此处仅指虚拟机中内存的一部分。</p>\n<p>除了主内存，每条线程还有自己的工作内存，此处可与 CPU 的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。</p>\n<blockquote>\n<p>有了 MESI，为什么还需要 volatile 的可见性语义？并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM 需要统一的模型。可见性问题不仅仅局限于 CPU 缓存内，JMM 中也有可见性问题。使用volatile 做标记，可以解决 JMM 的可见性问题。</p>\n</blockquote>\n<h4 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>\n<ul>\n<li><strong>lock</strong>：作用于主内存，将一个变量标识为被一个线程独占状态。</li>\n<li><strong>unlock</strong>：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定。</li>\n<li><strong>read</strong>：作用于主内存，将一个变量的值从主内存传输到工作内存中，以便进行后续的 load 操作。</li>\n<li><strong>load</strong>：作用于工作内存，把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li>\n<li><strong>use</strong>：作用于工作内存，把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li>\n<li><strong>assign</strong>：作用于工作内存，把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时，都要使用该操作。</li>\n<li><strong>store</strong>：作用于工作内存，把工作内存中的一个变量的值传递给主内存，以便随后的 write 操作。</li>\n<li><strong>write</strong>：作用于主内存，把 store 操作从工作内存中得到的变量的值写到主内存中的变量。</li>\n</ul>\n<p>Java 内存模型只要求 <code>read</code> 和 <code>load</code>、<code>store</code> 和 <code>write</code> 这两对操作必须按顺序执行，但没有保证连续执行。</p>\n<ul>\n<li><code>read</code> 是把变量从 shared memory 读入 CPU local memory，或者说从内存读入 CPU cache，<code>write</code> 反之。</li>\n<li><code>load</code> 是把变量从 CPU local memory 读入 JVM stack，你可以认为它是把数据从 CPU cache 读入到“JVM寄存器”，<code>store</code> 反之。</li>\n</ul>\n<p>之所以会这么麻烦，是因为现代电脑都有不止一个 CPU，每个 CPU 都有自己的 1 级 2 级甚至 3 级缓存，CPU 之间共享主存，一个 CPU 对主存所做的改动并不会自动被其它 CPU 发现，必须有某种机制让其它 CPU 知道这一点，当然最简单的思路是让 cache 和主存永远同步，但 cache 的速度远高于主存，强制同步其实相当于把 cache 强制降速，这对于程序执行效率是不利的。</p>\n<p>现在的做法是选择性的同步，当你不需要同步时，只需要一次 <code>load</code>，然后就可以多次 <code>read</code>/<code>write</code>，避免和主存的同步，这样可以让 CPU 保持最高的效率运转；当你需要同步时，用 <code>store</code> 将变更写回主存，JVM/CPU/MM 会协调将这个变更通知到其它 CPU 以保证程序的正确性。</p>\n<p><code>use</code> 是用来配合上述过程的，只有 <code>use</code> 了特定变量的 CPU 才会收到针对这个变量做 <code>store</code> 时发出的通知，这样就避免了无谓的 CPU cache flush 操作。</p>\n<p><code>lock</code>/<code>unlock</code> 是传统方式，用来限制 CPU 对共享区域操作的，如果一个变量被 <code>lock</code> 了，那么其它所有 CPU 针对这个变量做出的 <code>lock</code> 操作都回阻塞直到拥有者释放这个锁。</p>\n<p><strong>问题</strong>：Java 内存模型规定了不允许 <code>read</code> 和 <code>load</code> 、<code>store</code> 和 <code>write</code> 操作之一单独出现，是不是和一次 <code>load</code> 多次 <code>read</code>/<code>write</code> 冲突?<br>回答：主要是很多 CPU，包括 x86，并不支持一次 <code>load</code> 多次 <code>read</code> 或者一次 <code>write</code> 多次 <code>store</code>，JVM 也没办法在这样的 CPU 上实现这个功能。以前的 x86 上没有分离的 <code>read</code>/<code>load</code> 和 <code>write</code>/<code>store</code> 指令，直到 SSE 里面才加入了 prefetch，但依然没有单独写 cache 和写 cache 到主存的指令。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>线程安全的三大特性：原子性、可见性、有序性。</p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p>原子性是指一个或多个操作必须连续执行不可分解。</p>\n<p>在 Java 中，为了保证原子性，提供了两个高级的字节码指令 <code>monitorenter</code>  和 <code>monitorexit</code> 。通过这两个指令，可以保证被 synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。</p>\n<p>线程A在执行 monitorenter 指令的时候，会对 Monitor 进行加锁，加锁后其他线程无法获得锁，除非线程A主动解锁。即使在执行过程中，由于某种原因，比如CPU时间片用完，线程A放弃了CPU，但是并不会进行解锁。由于 synchronized 的锁是可重入的，下一个时间片还是只能被自己获取到，还是会继续执行代码。</p>\n<p>下面通过几个简单的示例来看一下在代码层面，哪些操作是原子的。对于 int 类型的变量 a 和 b：</p>\n<ul>\n<li>a = 1 ：这个操作是原子的，字节码指令为 putField，属于 <code>assign</code> 操作</li>\n<li>a = b ：这个操作不是原子的，需要先执行 getField 读变量 b，再执行 putField 对变量 a 进行赋值</li>\n<li>a++ ：实质上是 a = a + 1，首先 getField 读取变量 a，然后执行 add 计算 a + 1 的值，最后通过 putField 将计算后的值赋值给 a</li>\n<li>Object obj = new Object() ：首先会执行 allocMemory 为对象分配内存，然后调用 <init> 初始化对象，最后返回对象内存地址，更加复杂，自然也不是原子性的。</init></li>\n</ul>\n<p>synchronized 可以保证原子性，通过 monitorenter 和 monitorexit 指令实现。</p>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p><strong>问题</strong>：为什么 volatile 能够保证变量在线程中的可见性？<br>回答：观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令（任何带有 lock 前缀的指令以及 CPUID 等指令都有内存屏障的作用），可以实现以下作用：</p>\n<blockquote>\n<p>// todo<br>在 x86，x86-64 下， 有两种方法可以实现内存屏障， 1. mfence 2. locked instruction 。 </p>\n</blockquote>\n<ul>\n<li>对该变量的改写立即刷新到主存（也就是说对 volatile 域的写会导致 assgin -&gt; store -&gt; write 的原子性执行）。</li>\n<li>通过总线通知其他 CPU 该共享变量已被更新，对于也缓存了该共享变量的CPU，如果接收到该通知，那么会在自己的 Cache 中将共享变量所在的缓存行置为无效状态。CPU 在下次读取读取该共享变量时发现缓存行已被置为无效状态，他将重新到主存中读取。</li>\n</ul>\n<p>因为 volatile 只能确保变量的可见性，而不能保证对其复杂操作的原子性。<br>除了 volatile，Java 中的 synchronized 和 final 两个关键字也可以实现可见性。</p>\n<p>synchronized 的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中，即执行 store 和 write 操作”这条规则获取的。</p>\n<p>final 的可见性是指被 final 修饰的字段在构造器中一旦被初始化完成，那么其它线程中就能看见这个 final 字段。</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p>由于 CPU 具有多个不同类型的指令执行单元，因此一个时钟周期可以执行多条指令，为了尽可能地提高程序的并行度，CPU 会将不同类型的指令分发到各个执行单元同时执行。除此以外编译器在编译过程中也可能会对指令进行重排序。但是编译器不会对存在依赖关系的指令进行重排序，并且编译器将通过插入指令屏障的方式也禁止 CPU 对其重排序。</p>\n<p>在 Java 中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。volatile 关键字可以通过插入内存屏障的方式禁止指令重排，而 synchronized 关键字保证同一时刻只允许一条线程操作。</p>\n<h4 id=\"Happens-before-原则\"><a href=\"#Happens-before-原则\" class=\"headerlink\" title=\"Happens-before 原则\"></a>Happens-before 原则</h4><p>如果 Java 内存模型的有序性都只依靠 volatile 和 synchronized 完成，那么操作会很复杂。Java 语言定义了一个“先行发生”原则，依靠这个原则我们可以很容易地判断在并发环境下两个操作是否可能存在竞争冲突问题。</p>\n<ol>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>\n<li>锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作；</li>\n<li>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>\n<li>线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作；</li>\n<li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行；</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于 finalize() 方法的开始。</li>\n</ol>\n<p>先行发生原则并不等同于时间上的先发生。</p>\n<h4 id=\"Java-内存屏障\"><a href=\"#Java-内存屏障\" class=\"headerlink\" title=\"Java 内存屏障\"></a>Java 内存屏障</h4><p>Java 的内存屏障通常所谓的四种，即 LoadLoad、StoreStore、LoadStore、StoreLoad。实际上也是 CPU 两种内存屏障的组合，完成一系列的屏障和数据同步功能。</p>\n<ol>\n<li>LoadLoad屏障：对于这样的语句 <code>Load1; LoadLoad; Load2</code> ，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕（保证可以及时发现缓存的失效）。</li>\n<li>StoreStore屏障：对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>\n<li>LoadStore屏障：对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 Store2 及后续写入操作执行前，保证 Load1 要读取的数据被读取完毕。</li>\n<li>StoreLoad屏障：对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。</li>\n</ol>\n<p>StoreLoad 同时具备其他三个屏障的效果，因此也称之为全能屏障（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p>\n<p>除了 mfence，不同的 CPU 架构对内存屏障的实现方式与实现程度非常不一样。相对来说，Intel CPU 的强内存模型比 DEC Alpha 的弱复杂内存模型（缓存不仅分层了，还分区）更简单。</p>\n<h5 id=\"X86架构的内存屏障\"><a href=\"#X86架构的内存屏障\" class=\"headerlink\" title=\"X86架构的内存屏障\"></a>X86架构的内存屏障</h5><p>x86架构并没有实现全部的内存屏障。</p>\n<ul>\n<li>sfence指令实现了Store Barrier，相当于StoreStore Barriers。</li>\n<li>lfence指令实现了Load Barrier，相当于LoadLoad Barriers。</li>\n<li>mfence指令实现了Full Barrier，相当于StoreLoad Barriers。</li>\n</ul>\n<h5 id=\"volatile-内存屏障\"><a href=\"#volatile-内存屏障\" class=\"headerlink\" title=\"volatile 内存屏障\"></a>volatile 内存屏障</h5><p>基于保守策略的 JMM 内存屏障插入规则如下，可以保证在任意平台都能得到正确的语义。</p>\n<ul>\n<li>在每个 volatile 写操作前插入 StoreStore 屏障，在写操作后插入 StoreLoad 屏障；</li>\n<li>在每个 volatile 读操作前插入 LoadLoad 屏障，在读操作后插入 LoadStore 屏障。</li>\n</ul>\n<p>而在 x86 架构中，JVM 对 volatile 变量的处理如下：</p>\n<ul>\n<li>在写 volatile 变量之后，插入一个 sfence（StoreStore）。禁用跨sfence的store重排序，使得 sfence 之前修改的值都会被写回缓存，并标记其他CPU中的缓存失效。</li>\n<li>在读volatile变量v之前，插入一个lfence（LoadLoad）。禁用跨 lfence 的load重排序，lfence之后，会首先刷新无效缓存，从而得到最新的修改值，与sfence配合保证内存可见性。</li>\n</ul>\n<p>在另外一些平台上，JVM 使用 mfence 代替 sfence 与 lfence，实现更强的语义。</p>\n<h5 id=\"final-内存屏障\"><a href=\"#final-内存屏障\" class=\"headerlink\" title=\"final 内存屏障\"></a>final 内存屏障</h5><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p>\n<ul>\n<li>新建对象过程中，构造体中对 final 域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序。编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。</li>\n<li>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序（意思就是先赋值引用，再调用final值）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li>\n</ul>\n<blockquote>\n<p>在构造函数内部，不能让这个被构造对象的引用（final 修饰）为其他线程可见，也就是对象引用不能在构造函数中“逸出”。</p>\n</blockquote>\n<p>final 语义在 x86 处理器中的实现：由于 x86 处理器不会对写 - 写操作做重排序，所以在 x86 处理器中，写 final 域需要的 StoreStore 障屏会被省略掉。同样，由于 x86 处理器不会对存在间接依赖关系的操作做重排序，所以在 x86 处理器中，读 final 域需要的 LoadLoad 屏障也会被省略掉。也就是说在 x86 处理器中，final 域的读 / 写不会插入任何内存屏障。</p>\n<p>JSR-133 通过为 final 域增加写和读重排序规则，增强了 final 的语义：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://www.cnblogs.com/yanlong300/p/8986041.html\" target=\"_blank\" rel=\"noopener\">CPU缓存一致性协议MESI</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/66085562\" target=\"_blank\" rel=\"noopener\">内存屏障Memory Barrier: a Hardware View</a></li>\n<li><a href=\"https://dzone.com/articles/what-false-sharing-is-and-how-jvm-prevents-it\" target=\"_blank\" rel=\"noopener\">What False Sharing Is and How JVM Prevents It</a></li>\n<li><a href=\"https://www.jianshu.com/p/f5883ca0348f\" target=\"_blank\" rel=\"noopener\">从多核硬件架构，看Java内存模型</a></li>\n<li><a href=\"https://www.infoq.cn/article/java-memory-model-6\" target=\"_blank\" rel=\"noopener\">深入理解 Java 内存模型（六）——final</a></li>\n<li><a href=\"https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\" target=\"_blank\" rel=\"noopener\">一文解决内存屏障</a></li>\n<li>…</li>\n</ol>\n","categories":["Java"],"tags":["Java"]},{"title":"理解 Spring IoC","url":"http://yoursite.com/2019/10/07/理解 Spring IoC/","content":"<h3 id=\"Spring-IoC概述\"><a href=\"#Spring-IoC概述\" class=\"headerlink\" title=\"Spring IoC概述\"></a>Spring IoC概述</h3><p>IoC 全称为 <code>Inversion of Control</code> ，翻译为 “控制反转”。</p>\n<p>如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>\n<ol>\n<li>谁控制谁</li>\n<li>控制什么</li>\n<li>为何是反转</li>\n<li>哪些方面反转</li>\n</ol>\n<p>通过一个例子可以更方便理解IoC。假设一个人想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机和橙子，自己动手制作。值得注意的是：这个过程是自己“主动”创造的过程，也就是说一杯橙汁需要自己创造。这种方法就对应在程序代码中直接 <code>new</code> 一个橙汁对象，橙汁全程由自己制作管理。</p>\n<p>然而到了今时今日，由于饮品店的盛行，当想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。在该过程中并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。这个过程饮品店相当于Spring容器，我们获取橙汁对象并不是自己在程序代码中 <code>new</code> 一个对象，而是直接在Spring容器（饮品店）直接获取，饮品店管理橙汁的制作过程。</p>\n<p>现在在看上面那四个问题，答案就显得非常明显了:</p>\n<ol>\n<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 <code>new</code> 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>\n<li><strong>控制什么</strong>：控制对象。</li>\n<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己代码中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>\n<li><strong>哪些方面反转</strong>：所依赖对象的获取被反转。</li>\n</ol>\n<h4 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h4><p><code>IoC Service Provider</code>为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入。</p>\n<h5 id=\"构造方法注入\"><a href=\"#构造方法注入\" class=\"headerlink\" title=\"构造方法注入\"></a>构造方法注入</h5><p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer(OrangeJuice orangeJuice) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.orangeJuice = orangeJuice;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"setter方法注入\"><a href=\"#setter方法注入\" class=\"headerlink\" title=\"setter方法注入\"></a>setter方法注入</h5><p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrangeJuice orangeJuice;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOrangeJuice</span><span class=\"params\">(OrangeJuice orangeJuice)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orangeJuice = orangeJuice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），</p>\n<h5 id=\"接口注入\"><a href=\"#接口注入\" class=\"headerlink\" title=\"接口注入\"></a>接口注入</h5><p>接口方式注入带有侵入性，因为它需要被依赖的对象实现不必要的接口，一般都不推荐这种方式。</p>\n<h3 id=\"Spring-体系结构\"><a href=\"#Spring-体系结构\" class=\"headerlink\" title=\"Spring 体系结构\"></a>Spring 体系结构</h3><h4 id=\"Resource-体系\"><a href=\"#Resource-体系\" class=\"headerlink\" title=\"Resource 体系\"></a>Resource 体系</h4><p><code>org.springframework.core.io.Resource</code> 是对资源的抽象, 不同实现类代表了对不同资源的访问策略，如 ClassPathResource、RLResource、FileSystemResource 等。</p>\n\n<h4 id=\"ResourceLoader-体系\"><a href=\"#ResourceLoader-体系\" class=\"headerlink\" title=\"ResourceLoader 体系\"></a>ResourceLoader 体系</h4><p>有了资源，就应该有资源加载，Spring 利用<code>org.springframework.core.io.ResourceLoader</code>来进行统一资源加载，类图如下：</p>\n<img src=\"/2019/10/07/理解%20Spring%20IoC/SpringResourceLoader类图.png\">\n<h4 id=\"BeanFactory-体系\"><a href=\"#BeanFactory-体系\" class=\"headerlink\" title=\"BeanFactory 体系\"></a>BeanFactory 体系</h4><p><code>org.springframework.beans.factory.BeanFactory</code>，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。</p>\n<ul>\n<li>BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。</li>\n<li>DefaultListableBeanFactory 为默认实现，它实现了所有接口。</li>\n</ul>\n<img src=\"/2019/10/07/理解%20Spring%20IoC/SpringBeanFactory类图.png\">\n<h4 id=\"BeanDefinition-体系\"><a href=\"#BeanDefinition-体系\" class=\"headerlink\" title=\"BeanDefinition 体系\"></a>BeanDefinition 体系</h4><p><code>org.springframework.beans.factory.config.BeanDefinition</code> ，用来描述 Spring 中的 Bean 对象。</p>\n<img src=\"/2019/10/07/理解%20Spring%20IoC/SpringBeanDefinition类图.png\">\n<h4 id=\"BeanDefinitionReader-体系\"><a href=\"#BeanDefinitionReader-体系\" class=\"headerlink\" title=\"BeanDefinitionReader 体系\"></a>BeanDefinitionReader 体系</h4><p><code>org.springframework.beans.factory.support.BeanDefinitionReader</code> 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。</p>\n<img src=\"/2019/10/07/理解%20Spring%20IoC/SpringBeanDefinitionReader类图.png\">\n<h4 id=\"ApplicationContext-体系\"><a href=\"#ApplicationContext-体系\" class=\"headerlink\" title=\"ApplicationContext 体系\"></a>ApplicationContext 体系</h4><p><code>org.springframework.context.ApplicationContext</code>，它叫做应用上下文，是应用层容器。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：</p>\n<ol>\n<li>继承 <code>org.springframework.context.MessageSource</code> 接口，提供国际化的标准访问策略。</li>\n<li>继承 <code>org.springframework.context.ApplicationEventPublisher</code> 接口，提供强大的事件机制。</li>\n<li>扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。</li>\n<li>对 Web 应用的支持。</li>\n</ol>\n<img src=\"/2019/10/07/理解%20Spring%20IoC/SpringApplicationContext类图.png\">\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要介绍 IoC 的概念，以及 IoC 的三种注入方式，然后介绍了Spring的六大体系，包括Resource、ResourceLoader、BeanFactory、BeanDefinition、BeanDefinitionReader以及ApplicationContext。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"http://svip.iocoder.cn/Spring/IoC-intro/\" target=\"_blank\" rel=\"noopener\">【死磕 Spring】—— IoC 之深入理解 Spring IoC</a></li>\n</ol>\n","categories":["Java"],"tags":["Java","Spring"]},{"title":"浅谈 SPI 机制","url":"http://yoursite.com/2019/09/04/浅谈SPI机制/","content":"<h3 id=\"SPI的概念\"><a href=\"#SPI的概念\" class=\"headerlink\" title=\"SPI的概念\"></a>SPI的概念</h3><p>面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。</p>\n<img src=\"/2019/09/04/浅谈SPI机制/SPI机制.png\">\n<p>SPI 全称为 <code>Service Provider Interface</code> ，是 Java 提供的一套用来被第三方实现或者扩展的API，可以用来启用框架扩展和替换组件。SPI 是一种服务发现机制，本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类，使得运行时可以动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>\n<h4 id=\"SPI对比API\"><a href=\"#SPI对比API\" class=\"headerlink\" title=\"SPI对比API\"></a>SPI对比API</h4><img src=\"/2019/09/04/浅谈SPI机制/API对比SPI.png\">\n<p><strong>API</strong>:</p>\n<ol>\n<li>概念上更接近实现方</li>\n<li>组织上位于实现方所在的包中</li>\n<li>实现和接口在一个包中</li>\n</ol>\n<p><strong>SPI</strong>:</p>\n<ol>\n<li>概念上更依赖调用方</li>\n<li>组织上位于调用方所在的包中</li>\n<li>实现位于独立的包中（也可认为在提供方中）</li>\n</ol>\n<h3 id=\"Java-SPI\"><a href=\"#Java-SPI\" class=\"headerlink\" title=\"Java SPI\"></a>Java SPI</h3><p>在 JDK6 里面引进的一个新的特性 <code>ServiceLoader</code>，它主要是用来装载一系列的 service provider 。而且 <code>ServiceLoader</code> 可以通过 service provider 的配置文件来装载指定的 service provider 。当服务的提供者，提供了服务接口的一种实现之后，只需要在jar包的 <code>META-INF/services/</code> 目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包 <code>META-INF/services/</code> 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p>\n<h4 id=\"Java-SPI-示例\"><a href=\"#Java-SPI-示例\" class=\"headerlink\" title=\"Java SPI 示例\"></a>Java SPI 示例</h4><p>前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，定义一个接口，名称为 Fruit。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">color</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来定义两个实现类，分别为 Apple 和 Banana。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">color</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Red\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Banana</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">color</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Yellow\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来 <code>META-INF/services</code> 文件夹下创建一个文件，名称为 Fruit 的全限定名 <code>org.apache.spi.Fruit</code> 。文件内容为实现类的全限定的类名，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.spi.Apple</span><br><span class=\"line\">org.apache.spi.Banana</span><br></pre></td></tr></table></figure>\n<p>做好所需的准备工作，接下来编写代码进行测试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaSPITest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">color</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ServiceLoader&lt;Fruit&gt; serviceLoader = ServiceLoader.load(Fruit.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Java SPI\"</span>);</span><br><span class=\"line\">        serviceLoader.forEach(Fruit::color);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后来看一下测试结果，从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java SPI</span><br><span class=\"line\">Red</span><br><span class=\"line\">Yellow</span><br></pre></td></tr></table></figure>\n<h3 id=\"DriverManager-SPI\"><a href=\"#DriverManager-SPI\" class=\"headerlink\" title=\"DriverManager SPI\"></a>DriverManager SPI</h3><p><code>DriverManager</code> 是 JDBC 管理和注册不同数据库驱动的工具类。针对一个数据库可能会存在着不同的数据库驱动实现，在使用特定的驱动实现时不希望修改现有的代码才能达到目的，而希望通过一个简单的配置就可以达到效果。比如，我们现在有一个数据库的驱动 A，我们希望在程序里使用它而不修改代码。一种理想的选择就是我们将驱动A的信息加入到一个配置文件中，程序通过读取配置文件信息将 A 加载进来。而以后如果我们希望改用另外一个驱动 B 的时候，我们只需要将配置文件里的信息修改成驱动 B 即可。</p>\n<p>我们在运用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 加载 mysql 驱动后，就会执行其中的静态代码把driver注册到 <code>DriverManager</code> 中，以便后续的使用。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.mysql.jdbc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">extends</span> <span class=\"title\">NonRegisteringDriver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Driver</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            DriverManager.registerDriver(<span class=\"keyword\">new</span> Driver());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException var1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Can't register driver!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以看到，不同的驱动实现了相同的接口 <code>java.sql.Driver</code> ，然后通过 <code>registerDriver</code> 把当前 driver 加载到 <code>DriverManager</code> 中<br>这就体现了使用方提供规则，提供方根据规则把自己加载到使用方中的SPI思想。查看 <code>DriverManager</code> 的源码，可以看到其内部的静态代码块中有一个 <code>loadInitialDrivers</code> 方法，在注释中我们看到用到了上文提到的 SPI 工具类 <code>ServiceLoader</code> 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Load the initial JDBC drivers by checking the System property</span></span><br><span class=\"line\"><span class=\"comment\">* jdbc.properties and then use the &#123;<span class=\"doctag\">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">\tloadInitialDrivers();</span><br><span class=\"line\">\tprintln(<span class=\"string\">\"JDBC DriverManager initialized\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点进方法，看到方法里有如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class=\"line\">Iterator&lt;Driver&gt; drivers = loadedDrivers.iterator();</span><br><span class=\"line\">println(<span class=\"string\">\"DriverManager.initialize: jdbc.drivers = \"</span> + loadedDrivers);</span><br></pre></td></tr></table></figure>\n<p>可见，<code>DriverManager</code> 初始化时也运用了 SPI 机制，使用 <code>ServiceLoader</code> 把写到配置文件里的 Driver 都加载了进来。打开 mysql-connector-java 的 jar 包，果然在 <code>META-INF/services</code> 下发现了上文中提到的接口路径，打开里面的内容，可以看到是 <code>com.mysql.jdbc.Driver</code> 。</p>\n<h3 id=\"Dubbo-SPI\"><a href=\"#Dubbo-SPI\" class=\"headerlink\" title=\"Dubbo SPI\"></a>Dubbo SPI</h3><p>SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 <code>ExtensionLoader</code> 类中，通过 <code>ExtensionLoader</code> ，可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 <code>META-INF/dubbo</code>路径下，配置内容如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apple = org.apache.spi.Apple</span><br><span class=\"line\">banana = org.apache.spi.Banana</span><br></pre></td></tr></table></figure>\n<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Fruit 接口上标注<code>@SPI</code>注解。下面来演示 Dubbo SPI 的用法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboSPITest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">color</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ExtensionLoader&lt;Fruit&gt; extensionLoader = </span><br><span class=\"line\">            ExtensionLoader.getExtensionLoader(Fruit.class);</span><br><span class=\"line\">        Fruit apple = extensionLoader.getExtension(<span class=\"string\">\"apple\"</span>);</span><br><span class=\"line\">        apple.color();</span><br><span class=\"line\">        Fruit banana = extensionLoader.getExtension(<span class=\"string\">\"banana\"</span>);</span><br><span class=\"line\">        banana.color();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo SPI</span><br><span class=\"line\">Red</span><br><span class=\"line\">Yellow</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本篇文章简单分别介绍了SPI机制的概念，以及Java SPI ，DriverManager SPI 与 Dubbo SPI 用法。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28909673\" target=\"_blank\" rel=\"noopener\">Java SPI思想梳理</a></li>\n<li><a href=\"http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html\" target=\"_blank\" rel=\"noopener\">Dubbo SPI</a></li>\n<li><a href=\"https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html\" target=\"_blank\" rel=\"noopener\">设计原则：小议 SPI 和 API</a></li>\n</ol>\n","categories":["Java"],"tags":["Java"]},{"title":"categories","url":"http://yoursite.com/categories/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://yoursite.com/about/index.html","content":"<blockquote class=\"blockquote-center\"><p>种一棵树最好的时间是十年前，<br>而后是现在。 </p>\n</blockquote>\n<!--   - key: **Github**\n    value: [zer0ing](https://github.com/zer0ing) -->\n<ul>\n<li><p>key: <strong>Zhihu</strong><br>value: <a href=\"https://www.zhihu.com/people/wu-yang-67-1\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n</li>\n<li><p>key: <strong>Email</strong><br>value: <a href=\"mailto:zeroing.young@gmail.com\" target=\"_blank\" rel=\"noopener\">zeroing.young@gmail.com</a></p>\n</li>\n</ul>\n","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"schedule","url":"http://yoursite.com/schedule/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"<p>link:</p>\n<ul>\n<li>name: 织网<br>info: 身体和灵魂，总有一个在路上<br>url: <a href=\"http://zheng-ji.info/\" target=\"_blank\" rel=\"noopener\">http://zheng-ji.info/</a><br>avatar: <a href=\"https://avatars3.githubusercontent.com/u/1414745?v=3&amp;s=460\" target=\"_blank\" rel=\"noopener\">https://avatars3.githubusercontent.com/u/1414745?v=3&amp;s=460</a></li>\n<li>name: Dongyado<br>info: 生命不止，折腾不息<br>url: <a href=\"http://dongyado.com/\" target=\"_blank\" rel=\"noopener\">http://dongyado.com/</a><br>avatar: <a href=\"https://avatars0.githubusercontent.com/u/6274940?v=3&amp;s=460\" target=\"_blank\" rel=\"noopener\">https://avatars0.githubusercontent.com/u/6274940?v=3&amp;s=460</a></li>\n</ul>\n","categories":[],"tags":[]},{"title":"sitemap","url":"http://yoursite.com/sitemap/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"http://yoursite.com/tags/index.html","content":"","categories":[],"tags":[]}]