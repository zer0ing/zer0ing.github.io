<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Spring】——深入理解IoC]]></title>
    <url>%2F2019%2F11%2F13%2F%E3%80%90Spring%E3%80%91%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3IoC%2F</url>
    <content type="text"><![CDATA[Spring IoC概述IoC 全称为 Inversion of Control ，翻译为 “控制反转”。 如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题： 谁控制谁 控制什么 为何是反转 哪些方面反转 通过一个例子可以更方便理解IoC。假设一个人想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机和橙子，自己动手制作。值得注意的是：这个过程是自己“主动”创造的过程，也就是说一杯橙汁需要自己创造。这种方法就对应在程序代码中直接 new 一个橙汁对象，橙汁全程由自己制作管理。 然而到了今时今日，由于饮品店的盛行，当想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。在该过程中并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。这个过程饮品店相当于Spring容器，我们获取橙汁对象并不是自己在程序代码中 new 一个对象，而是直接在Spring容器（饮品店）直接获取，饮品店管理橙汁的制作过程。 现在在看上面那四个问题，答案就显得非常明显了: 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己代码中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转：所依赖对象的获取被反转。 注入方式IoC Service Provider为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入。 构造方法注入构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123Consumer(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice;&#125; setter方法注入对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下： 12345678public class Consumer &#123; private OrangeJuice orangeJuice; public void setOrangeJuice(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice; &#125;&#125; 相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前）， 接口注入接口方式注入带有侵入性，因为它需要被依赖的对象实现不必要的接口，一般都不推荐这种方式。 Spring 体系结构Resource 体系org.springframework.core.io.Resource 是对资源的抽象, 不同实现类代表了对不同资源的访问策略，如 ClassPathResource、RLResource、FileSystemResource 等。 ResourceLoader 体系有了资源，就应该有资源加载，Spring 利用org.springframework.core.io.ResourceLoader来进行统一资源加载，类图如下： BeanFactory 体系org.springframework.beans.factory.BeanFactory，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。 BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。 DefaultListableBeanFactory 为默认实现，它实现了所有接口。 BeanDefinition 体系org.springframework.beans.factory.config.BeanDefinition ，用来描述 Spring 中的 Bean 对象。 BeanDefinitionReader 体系org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。 ApplicationContext 体系org.springframework.context.ApplicationContext，它叫做应用上下文，是应用层容器。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。 继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。 扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。 对 Web 应用的支持。 总结本文主要介绍 IoC 的概念，以及 IoC 的三种注入方式，然后介绍了Spring的六大体系，包括Resource、ResourceLoader、BeanFactory、BeanDefinition、BeanDefinitionReader以及ApplicationContext，后续将详细介绍这些体系的相关源码。 参考 【死磕 Spring】—— IoC 之深入理解 Spring IoC]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring系列——统一资源加载]]></title>
    <url>%2F2019%2F10%2F13%2FSpring%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[[TOC] Java SE中有一个标准类 java.net.URL，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道其实现基本只限于网络形式发布的资源的查找和定位。然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 java.net.URL 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求： 职能划分清楚。资源的定义和资源的加载应该要有一个清晰的界限； 统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。 统一资源：Resource体系 Resource 接口org.springframework.core.io.Resource 为 Spring 框架所有资源的抽象和访问接口，它继承 org.springframework.core.io.InputStreamSource接口。作为所有资源的统一抽象，Resource 定义了一些通用的方法，由子类 AbstractResource 提供统一的默认实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Resource extends InputStreamSource &#123;// 判断资源是否存在 boolean exists();// 判断资源是否可读 default boolean isReadable() &#123; return exists(); &#125;// 资源是否已被打开 default boolean isOpen() &#123; return false; &#125;// 判断是否是文件 default boolean isFile() &#123; return false; &#125;// 返回资源的URL句柄 URL getURL() throws IOException;// 返回资源的URI句柄 URI getURI() throws IOException;// 返回资源的File句柄 File getFile() throws IOException;// 获取资源的可读字节管道 default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125;// 获取资源的内容长度 long contentLength() throws IOException;// 获取最后修改时间 long lastModified() throws IOException;// 根据资源的相对路径创建新资源 Resource createRelative(String relativePath) throws IOException;// 获取资源的文件名 @Nullable String getFilename();// 获取资源描述 String getDescription();&#125; Resource的子接口：ContextResource和WritableResourceContextResource和WritableResource均是Resource的子接口，除拥有Resource的全部方法外，ContextResource接口还有下列方法： 12// 从关闭的上下文Context中获取资源的路径 String getPathWithinContext(); getPathWithContext() 方法返回相对于Context的路径，如ServletContext、PortletContext、classpath、FileSystem等，在Spring core中它有两个实现类FileSystemContextResource、ClassPathContextResource，分别是FileSystemResourceLoader和DefaultResourceLoader中的内部类，他们对getPathWithContext()方法的实现只是简单的返回path值。 另外，在Spring Web模块中，有一个ServletContextResource实现类，它使用ServletContext和path作为参数构造，getInputStream、getURL、getURI、getFile等方法中将实现代理给ServletContext，其中getPathWithContext方法依然返回path字符串。 WritableResource接口新增三个方法： 123456789101112// 判断是否可写,默认可写 default boolean isWritable() &#123; return true; &#125;// 获取输出流 OutputStream getOutputStream() throws IOException;// 获取写入字节管道 default WritableByteChannel writableChannel() throws IOException &#123; return Channels.newChannel(getOutputStream()); &#125; 因此WritableResource的实现类拥有了写资源的功能。 抽象类：AbstractResourceorg.springframework.core.io.AbstractResource ，为 Resource 接口的默认抽象实现。它实现了 Resource 接口的大部分的公共实现。当我们自定义资源时，只需继承 AbstractResource 抽象类，然后覆盖相应的方法即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public abstract class AbstractResource implements Resource &#123;// 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流 @Override public boolean exists() &#123; // Try file existence: can we find the file in the file system? if (isFile()) &#123; try &#123; return getFile().exists(); &#125; catch (IOException ex) &#123; Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug("Could not retrieve File for existence check of " + getDescription(), ex); &#125; &#125; &#125; // 产生异常,关闭输入流 try &#123; getInputStream().close(); return true; &#125; catch (Throwable ex) &#123; Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug("Could not retrieve InputStream for existence check of " + getDescription(), ex); &#125; return false; &#125; &#125;// 是否可读 @Override public boolean isReadable() &#123; return exists(); &#125;// 是否打开,返回false,未打开 @Override public boolean isOpen() &#123; return false; &#125;// 是否是文件,返回false,不是文件 @Override public boolean isFile() &#123; return false; &#125;// 抛出 FileNotFoundException 异常，交给子类实现 @Override public URL getURL() throws IOException &#123; throw new FileNotFoundException(getDescription() + " cannot be resolved to URL"); &#125;// 基于 getURL() 返回的 URL 构建 URI @Override public URI getURI() throws IOException &#123; URL url = getURL(); try &#123; //URL格式化后返回 return ResourceUtils.toURI(url); &#125; catch (URISyntaxException ex) &#123; throw new NestedIOException("Invalid URI [" + url + "]", ex); &#125; &#125;// 抛出 FileNotFoundException 异常，交给子类实现 @Override public File getFile() throws IOException &#123; throw new FileNotFoundException(getDescription() + " cannot be resolved to absolute file path"); &#125;// 根据 getInputStream() 的返回结果构建 ReadableByteChannel @Override public ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125;// 获取资源的长度// 资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断// 一般在子类中重写 @Override public long contentLength() throws IOException &#123; InputStream is = getInputStream(); try &#123; long size = 0;// 一次最多读取256字节 byte[] buf = new byte[256]; int read; while ((read = is.read(buf)) != -1) &#123; size += read; &#125; return size; &#125; finally &#123; try &#123; is.close(); &#125; catch (IOException ex) &#123; Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug("Could not close content-length InputStream for " + getDescription(), ex); &#125; &#125; &#125; &#125;// 返回资源最后修改时间 @Override public long lastModified() throws IOException &#123; File fileToCheck = getFileForLastModifiedCheck(); long lastModified = fileToCheck.lastModified(); if (lastModified == 0L &amp;&amp; !fileToCheck.exists()) &#123; throw new FileNotFoundException(getDescription() + " cannot be resolved in the file system for checking its last-modified timestamp"); &#125; return lastModified; &#125;// 交给子类重写// 子类没有实现则返回文件 protected File getFileForLastModifiedCheck() throws IOException &#123; return getFile(); &#125;// 抛出 FileNotFoundException 异常，交给子类实现 @Override public Resource createRelative(String relativePath) throws IOException &#123; throw new FileNotFoundException("Cannot create a relative resource for " + getDescription()); &#125;// 获取资源名称,默认返回null,交给子类实现 @Override @Nullable public String getFilename() &#123; return null; &#125; @Override public boolean equals(@Nullable Object other) &#123; return (this == other || (other instanceof Resource &amp;&amp; ((Resource) other).getDescription().equals(getDescription()))); &#125; @Override public int hashCode() &#123; return getDescription().hashCode(); &#125; @Override public String toString() &#123; return getDescription(); &#125;&#125; AbstractResource抽象子类：AbstractFileResolvingResource这个抽象类继承自AbstractResource，重写了AbstractResource的大部分方法，主要作用是将URL解析为File引用，其具体实现的子类有 UrlResource 和 ClassPathResource 。 AbstractResource的实现子类从上面 Resource 体系图可知，AbstractResource 有多种实现类，分别对应着不同的资源。 ByteArrayResourceByteArrayResource是对二进制数组提供的数据的封装,每次调用getInputStream方法时都会以这个二进制数组作为源创建一个ByteArrayInputStream。 1234@Overridepublic InputStream getInputStream() throws IOException &#123; return new ByteArrayInputStream(this.byteArray);&#125; FileSystemResourceFileSystemResource是对 java.io.File 类型资源的封装，在构建FileSystemResource时可以传入File对象或路径字符串（这里的路径可以是相对路径，相对路径是相对于System.getProperty(“user.dir”)的值所在的路径，也可以是绝对路径，也可以是“file:”开头的路径值），实现 了WritableResource 接口。从 Spring Framework 5.0 开始，FileSystemResource 使用 NIO2 API进行读/写交互。 123456789101112131415 @Override public OutputStream getOutputStream() throws IOException &#123; return Files.newOutputStream(this.filePath); &#125;// 利用相对路径返回Resource对象,注意相对路径的计算方法// StringUtils.applyRelativePath() @Override public Resource createRelative(String relativePath) &#123; String pathToUse = StringUtils.applyRelativePath(this.path, relativePath); return (this.file != null ? new FileSystemResource(pathToUse) : new FileSystemResource(this.filePath.getFileSystem(), pathToUse)); &#125; UrlResourceUrlResource是对 URL和URI 类型资源的封装。 123456789101112131415161718192021// 从URL中获取二进制输入流 @Override public InputStream getInputStream() throws IOException &#123;// 使用URL.openConnection()方法获取URLConnection URLConnection con = this.url.openConnection();// 设置是否使用缓存 ResourceUtils.useCachesIfNecessary(con); try &#123; //获取二进制输入流 return con.getInputStream(); &#125; catch (IOException ex) &#123; // 如果打开了资源,需要关闭http连接 if (con instanceof HttpURLConnection) &#123; ((HttpURLConnection) con).disconnect(); &#125; throw ex; &#125; &#125; ClassPathResourceClassPathResource是对classpath下资源的封装，资源从系统的类路径中加载。使用路径名、 ClassLoader 或者 Class 来创建资源。 123456789101112131415161718// 获取类路径下的资源的二进制流 @Override public InputStream getInputStream() throws IOException &#123; InputStream is; if (this.clazz != null) &#123; is = this.clazz.getResourceAsStream(this.path); &#125; else if (this.classLoader != null) &#123; is = this.classLoader.getResourceAsStream(this.path); &#125; else &#123; is = ClassLoader.getSystemResourceAsStream(this.path); &#125; if (is == null) &#123; throw new FileNotFoundException(getDescription() + " cannot be opened because it does not exist"); &#125; return is; &#125; InputStreamResourceInputStreamResource是对InputStream的封装，接收 InputStream 作为构造方法参数，它的 isOpen 总是返回 true，并且只能被读取一次（即getInputStream方法只能被调用一次），exists、isReadable方法也总是返回true。由于不能被多次读取，只有当不用多次读取的时候才使用该类，并且只有当没有其他可用Resource类时才使用该类。 12345678910// 只能读取一次，读取多次时会抛出异常 @Override public InputStream getInputStream() throws IOException, IllegalStateException &#123; if (this.read) &#123; throw new IllegalStateException("InputStream has already been read - " + "do not use InputStreamResource if a stream needs to be read multiple times"); &#125; this.read = true; return this.inputStream; &#125; VfsResourceVfsResource代表Jboss 虚拟文件系统资源。Jboss VFS(Virtual File System)框架是一个文件系统资源访问的抽象层，它能一致的访问物理文件系统、jar资源、zip资源、war资源等，VFS能把这些资源一致的映射到一个目录上，访问它们就像访问物理文件资源一样，而其实这些资源不存在于物理文件系统。 DescriptiveResourceDescriptiveResource 是对非物理资源的Description的封装。它实现了 getDescription() 方法。Resource中 Description 属性主要用于错误处理时能更加准确的打印出错位置的信息。DescriptiveResource提供对那些需要提供Resource接口中的Description属性作为错误打印信息的方法自定义的描述信息。比如在BeanDefinitionReader中，在仅仅使用InputSource作为源加载BeanDefinition时，就可以使用DescriptiveResource定义自己的Description，从而在出错信息中可以方便知道问题源的位置。 统一资源加载：ResourceLoader体系 ResourceLoader接口Spring 将资源的定义和资源的加载区分开，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。 org.springframework.core.io.ResourceLoader 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成。 1234567891011public interface ResourceLoader &#123; String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;// 根据路径返回资源 Resource getResource(String location);// 返回ClassLoader @Nullable ClassLoader getClassLoader();&#125; getResource(String location)通过给定的location参数获取Resource实例，该实例可以是ClassPathResource、FileSystemResource、UrlResource等，但该方法返回的Resource实例并不能保证一定存在，必须通过 exists() 方法进行判断。该方法支持以下模式的资源加载： URL位置资源，如 “file:C:/test.dat” 。 ClassPath位置资源，如 “classpath:test.dat 。 相对路径资源，如 “WEB-INF/test.dat” ，此时返回的Resource 实例，根据实现不同而不同。 getClassLoader()方法返回ClassLoader实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。 DefaultResourceLoader 类构造方法DefaultResourceLoader 类有两个构造方法： 不带参数的构造方法：使用的 ClassLoader 为默认的 ClassLoader（一般为Thread.currentThread().getContextClassLoader() ）。 带参数的构造方法：ClassLoader可以通过 ClassUtils.getDefaultClassLoader()获取。 123456789101112131415161718192021// 不带参数的构造方法 public DefaultResourceLoader() &#123; this.classLoader = ClassUtils.getDefaultClassLoader(); &#125;// 带参数的构造方法 public DefaultResourceLoader(@Nullable ClassLoader classLoader) &#123; this.classLoader = classLoader; &#125;// 可自行设置ClassLoader public void setClassLoader(@Nullable ClassLoader classLoader) &#123; this.classLoader = classLoader; &#125; @Override @Nullable public ClassLoader getClassLoader() &#123; return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader()); &#125; getResource 方法getResource 方法根据给定的location获得对应的资源，注意此方法返回的资源类型只有：ClassPathContextResource、ClassPathResource、FileUrlResource、 UrlResource。 12345678910111213141516171819202122232425262728293031323334 @Override public Resource getResource(String location) &#123; Assert.notNull(location, "Location must not be null");// 首先，通过 ProtocolResolver 加载资源 for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123; Resource resource = protocolResolver.resolve(location, this); if (resource != null) &#123; return resource; &#125; &#125;// 其次，以 / 开头，返回 ClassPathContextResource 类型的资源 if (location.startsWith("/")) &#123; return getResourceByPath(location); &#125;// 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源 else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); &#125;// 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源 else &#123; try &#123; // Try to parse the location as a URL... URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); &#125;// 最后，返回 ClassPathContextResource 类型的资源 catch (MalformedURLException ex) &#123; // No URL -&gt; resolve as resource path. return getResourceByPath(location); &#125; &#125; &#125; ProtocolResolverorg.springframework.core.io.ProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI：它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 AbstractResource 即可；而对ResourceLoader而言，有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口即可实现自定义的 ResourceLoader。 ProtocolResolver 接口，仅有一个方法 Resource resolve(String location, ResourceLoader resourceLoader) 。代码如下： 12345678910// 通过实现ProtocolResolver接口，可以实现自定义的 ResourceLoader@FunctionalInterfacepublic interface ProtocolResolver &#123;// 使用指定的 ResourceLoader ，解析指定的 location// 若成功，则返回对应的 Resource @Nullable Resource resolve(String location, ResourceLoader resourceLoader);&#125; 当自定义实现 ProtocolResolver 接口后，只需调用 DefaultResourceLoader.addProtocolResolver(ProtocolResolver)方法即可将自定义的Resolver 加入工作区。代码如下： 12345678910// ProtocolResolver 集合 private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);// 将自定义实现的ProtocolResolver类加入工作区 public void addProtocolResolver(ProtocolResolver resolver) &#123; Assert.notNull(resolver, "ProtocolResolver must not be null"); this.protocolResolvers.add(resolver); &#125; FileSystemResourceLoaderFileSystemResourceLoader 继承 DefaultResourceLoader ，且覆写了 getResourceByPath(String) 方法，使之从文件系统加载资源并以 FileSystemResource 类型返回。 12345678910 @Override protected Resource getResourceByPath(String path) &#123; if (path.startsWith("/")) &#123;// 截取字符串 path = path.substring(1); &#125;// 创建 FileSystemContextResource 类型的资源 return new FileSystemContextResource(path); &#125; FileSystemContextResource 内部类FileSystemContextResource ，为 FileSystemResourceLoader 的内部类，它继承 FileSystemResource 类，实现 ContextResource 接口。该内部类出现的原因主要是实现getPathWithinContext() 方法。代码如下： 12345678910111213 private static class FileSystemContextResource extends FileSystemResource implements ContextResource &#123; public FileSystemContextResource(String path) &#123;// 调用父类 FileSystemResource 构造方法 super(path); &#125; @Override public String getPathWithinContext() &#123; return getPath(); &#125; &#125; ClassRelativeResourceLoaderorg.springframework.core.io.ClassRelativeResourceLoader，是 DefaultResourceLoader 的另一个子类的实现。和 FileSystemResourceLoader 类似，在实现代码的结构上类似，也是覆写 getResourceByPath(String path) 方法，并返回其对应的 ClassRelativeContextResource 的资源类型。ClassRelativeResourceLoader 扩展的功能是可以根据给定的class所在包或者所在包的子包下加载资源。 ResourcePatternResolver 接口ResourceLoader 的 Resource getResource(String location) 方法，每次只能根据 location 返回一个 Resource 。当需要加载多个资源时，只能多次调用 getResource(String location) 方法。org.springframework.core.io.support.ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下： 123456789//支持根据指定的资源路径匹配模式每次返回多个 Resource 实例public interface ResourcePatternResolver extends ResourceLoader &#123;//新增了一种新的协议前缀 "classpath*:"，该协议前缀由其子类负责实现 String CLASSPATH_ALL_URL_PREFIX = "classpath*:"; Resource[] getResources(String locationPattern) throws IOException;&#125; PathMatchingResourcePatternResolver 类org.springframework.core.io.support.PathMatchingResourcePatternResolver 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 &quot;classpath*:&quot; 前缀外，还支持 Ant 风格的路径匹配模式（类似于 &quot;**/*.xml&quot;）。 123// 支持 Ant 类型的路径匹配 private PathMatcher pathMatcher = new AntPathMatcher(); 构造方法PathMatchingResourcePatternResolver类有三个构造方法： 12345678910111213141516// PathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader public PathMatchingResourcePatternResolver() &#123; this.resourceLoader = new DefaultResourceLoader();&#125;public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) &#123; Assert.notNull(resourceLoader, "ResourceLoader must not be null"); this.resourceLoader = resourceLoader;&#125;public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) &#123; this.resourceLoader = new DefaultResourceLoader(classLoader);&#125; getResource12345678910// 委托给相应的 ResourceLoader 来实现// 未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是使用 DefaultResourceLoader 的过程 public ResourceLoader getResourceLoader() &#123; return this.resourceLoader; &#125; @Override public Resource getResource(String location) &#123; return getResourceLoader().getResource(location); &#125; getResources1234567891011121314151617181920212223242526272829303132333435@Override public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, "Location pattern must not be null");// 路径以 classpath* 开头: if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // a class path resource (multiple resources for same name possible)// 路径包含通配符 if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125;// 路径不包含通配符 else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125;// 路径不以classpath*:开头 else &#123; // Generally only look for a pattern after a prefix here, // and on Tomcat only after the "*/" separator for its "war:" protocol. int prefixEnd = (locationPattern.startsWith("war:") ? locationPattern.indexOf("*/") + 1 : locationPattern.indexOf(':') + 1); // 路径包含通配符 if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; // 路径不包含通配符 else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125; &#125; 非 &quot;classpath*:&quot; 开头，且路径不包含通配符，直接委托给相应的 ResourceLoader 来实现。 其他情况，调用 findAllClassPathResources()或 findPathMatchingResources() 方法，返回多个 Resource 。 findAllClassPathResources当 locationPattern 以 &quot;classpath*:&quot; 开头但是不包含通配符，则调用 findAllClassPathResources() 方法加载资源。该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。 12345678910111213 protected Resource[] findAllClassPathResources(String location) throws IOException &#123; String path = location; if (path.startsWith("/")) &#123; path = path.substring(1); &#125;// 调用doFindAllClassPathResources方法，真正执行加载所有 classpath 资源 Set&lt;Resource&gt; result = doFindAllClassPathResources(path); if (logger.isTraceEnabled()) &#123; logger.trace("Resolved classpath location [" + location + "] to resources " + result); &#125;// 返回Resource数组 return result.toArray(new Resource[0]); &#125; 真正执行加载的是在 doFindAllClassPathResources() 方法，代码如下： 1234567891011121314151617 protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException &#123; Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); ClassLoader cl = getClassLoader(); // &lt;1&gt; 根据 ClassLoader 加载路径下的所有资源 Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path)); // &lt;2&gt; 遍历 URL 集合，调用 convertClassLoaderURL(URL url) 方法，将 URL 转换成 UrlResource 对象 while (resourceUrls.hasMoreElements()) &#123; URL url = resourceUrls.nextElement(); result.add(convertClassLoaderURL(url)); &#125;// &lt;3&gt; 加载路径下得所有 jar 包 if ("".equals(path)) &#123; addAllClassLoaderJarRoots(cl, result); &#125; return result; &#125; &lt;1&gt;处，根据 ClassLoader 加载路径下的所有资源。在加载资源过程时，如果在构造 PathMatchingResourcePatternResolver 实例的时候如果传入了 ClassLoader，则调用该 ClassLoader 的 getResources() 方法，否则调用 ClassLoader.getSystemResources(path) 方法。ClassLoader.getResources()方法代码如下: 1234567891011121314// java.lang.ClassLoader类 public Enumeration&lt;URL&gt; getResources(String name) throws IOException &#123; @SuppressWarnings("unchecked") Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2]; if (parent != null) &#123; tmp[0] = parent.getResources(name); &#125; else &#123; tmp[0] = getBootstrapResources(name); &#125; tmp[1] = findResources(name); return new CompoundEnumeration&lt;&gt;(tmp); &#125; * 如果当前父类加载器不为 null ，则通过父类向上迭代获取资源，否则调用 `getBootstrapResources()`。 处，遍历 URL 集合，调用 #convertClassLoaderURL(URL url) 方法，将 URL 转换成 UrlResource 对象。 处，若 path 为空时，则调用 addAllClassLoaderJarRoots方法。该方法主要是加载路径下所有 jar 包。 由上述分析可知，findAllClassPathResources() 方法，其实就是利用 ClassLoader 来加载指定路径下的资源，不论它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 /，则会调用 addAllClassLoaderJarRoots() 方法，加载所有的 jar 包。 findPathMatchingResources当 locationPattern 中包含了通配符，则调用该方法进行资源加载。代码如下: 主要以下两个过程： 确定目录，获取该目录下得所有资源。 在所获得的所有资源后，进行迭代匹配获取我们想要的资源。 1234567891011121314151617181920212223242526272829303132333435363738// 当 locationPattern 中包含了通配符，则调用该方法进行资源加载 protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123;// 确定根路径、子路径 String rootDirPath = determineRootDir(locationPattern); String subPattern = locationPattern.substring(rootDirPath.length());// 获取根据路径下的资源 Resource[] rootDirResources = getResources(rootDirPath);// 遍历、迭代 Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); URL rootDirUrl = rootDirResource.getURL(); // bundle 资源类型 if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith("bundle")) &#123; URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; // vfs 资源类型 if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; // jar 资源类型 else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; // 其他资源类型 else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace("Resolved location pattern [" + locationPattern + "] to resources " + result); &#125; return result.toArray(new Resource[0]); &#125; determineRootDirdetermineRootDir(String location) 方法，主要是用于确定根路径。代码如下: 123456789101112131415161718// 确定根路径 protected String determineRootDir(String location) &#123; // 找到冒号的后一位 int prefixEnd = location.indexOf(':') + 1; // 根目录结束位置 int rootDirEnd = location.length(); // 在从冒号开始到最后的字符串中，循环判断是否包含通配符，如果包含，则截断最后一个由”/”分割的部分。 // 例如：在我们路径中，就是最后的ap?-context.xml这一段。再循环判断剩下的部分，直到剩下的路径中都不包含通配符。 while (rootDirEnd &gt; prefixEnd &amp;&amp; getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) &#123; rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1; &#125; // 如果查找完成后，rootDirEnd = 0 了，则将之前赋值的 prefixEnd 的值赋给 rootDirEnd ，也就是冒号的后一位 if (rootDirEnd == 0) &#123; rootDirEnd = prefixEnd; &#125; // 截取根目录 return location.substring(0, rootDirEnd); &#125; 总结 Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其加载。使得资源与资源加载有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。 AbstractResource 为 Resource 的默认抽象实现，其对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 也需继承该类。 DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外，还可以实现 ProtocolResolver 接口来实现自定资源加载协议。 DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它不但实现了 Resource getResource(String location) 方法，也实现了 Resource[] getResources(String locationPattern) 方法。 参考 【死磕 Spring】—— IoC 之 Spring 统一资源加载策略 深入Spring IOC源码之Resource 深入Spring IOC源码之ResourceLoader Spring资源抽象Resource]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring系列——理解IoC]]></title>
    <url>%2F2019%2F10%2F07%2FSpring%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%90%86%E8%A7%A3IoC%2F</url>
    <content type="text"><![CDATA[Spring IoC概述IoC 全称为 Inversion of Control ，翻译为 “控制反转”。 如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题： 谁控制谁 控制什么 为何是反转 哪些方面反转 通过一个例子可以更方便理解IoC。假设一个人想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机和橙子，自己动手制作。值得注意的是：这个过程是自己“主动”创造的过程，也就是说一杯橙汁需要自己创造。这种方法就对应在程序代码中直接 new 一个橙汁对象，橙汁全程由自己制作管理。 然而到了今时今日，由于饮品店的盛行，当想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。在该过程中并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。这个过程饮品店相当于Spring容器，我们获取橙汁对象并不是自己在程序代码中 new 一个对象，而是直接在Spring容器（饮品店）直接获取，饮品店管理橙汁的制作过程。 现在在看上面那四个问题，答案就显得非常明显了: 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己代码中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转：所依赖对象的获取被反转。 注入方式IoC Service Provider为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入。 构造方法注入构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 123Consumer(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice;&#125; setter方法注入对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下： 12345678public class Consumer &#123; private OrangeJuice orangeJuice; public void setOrangeJuice(OrangeJuice orangeJuice) &#123; this.orangeJuice = orangeJuice; &#125;&#125; 相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前）， 接口注入接口方式注入带有侵入性，因为它需要被依赖的对象实现不必要的接口，一般都不推荐这种方式。 Spring 体系结构Resource 体系org.springframework.core.io.Resource 是对资源的抽象, 不同实现类代表了对不同资源的访问策略，如 ClassPathResource、RLResource、FileSystemResource 等。 ResourceLoader 体系有了资源，就应该有资源加载，Spring 利用org.springframework.core.io.ResourceLoader来进行统一资源加载，类图如下： BeanFactory 体系org.springframework.beans.factory.BeanFactory，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。 BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。 DefaultListableBeanFactory 为默认实现，它实现了所有接口。 BeanDefinition 体系org.springframework.beans.factory.config.BeanDefinition ，用来描述 Spring 中的 Bean 对象。 BeanDefinitionReader 体系org.springframework.beans.factory.support.BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构 ：BeanDefinition 。 ApplicationContext 体系org.springframework.context.ApplicationContext，它叫做应用上下文，是应用层容器。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： 继承 org.springframework.context.MessageSource 接口，提供国际化的标准访问策略。 继承 org.springframework.context.ApplicationEventPublisher 接口，提供强大的事件机制。 扩展 ResourceLoader ，可以用来加载多种 Resource ，可以灵活访问不同的资源。 对 Web 应用的支持。 总结本文主要介绍 IoC 的概念，以及 IoC 的三种注入方式，然后介绍了Spring的六大体系，包括Resource、ResourceLoader、BeanFactory、BeanDefinition、BeanDefinitionReader以及ApplicationContext，后续将详细介绍这些体系的相关源码。 参考 【死磕 Spring】—— IoC 之深入理解 Spring IoC]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈SPI机制]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%B5%85%E8%B0%88SPI%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SPI的概念面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。 SPI 全称为Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。 SPI对比API API: 概念上更接近实现方 组织上位于实现方所在的包中 实现和接口在一个包中 SPI: 概念上更依赖调用方 组织上位于调用方所在的包中 实现位于独立的包中（也可认为在提供方中） Java SPI在JDK6里面引进的一个新的特性ServiceLoader，它主要是用来装载一系列的service provider。而且ServiceLoader可以通过service provider的配置文件来装载指定的service provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 Java SPI 示例前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。 123public interface Robot &#123; void sayHello();&#125; 接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。 123456789101112131415public class OptimusPrime implements Robot &#123; @Override public void sayHello() &#123; System.out.println("Hello, I am Optimus Prime."); &#125;&#125;public class Bumblebee implements Robot &#123; @Override public void sayHello() &#123; System.out.println("Hello, I am Bumblebee."); &#125;&#125; 接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下： 12org.apache.spi.OptimusPrimeorg.apache.spi.Bumblebee 做好所需的准备工作，接下来编写代码进行测试。 123456789public class JavaSPITest &#123; @Test public void sayHello() throws Exception &#123; ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class); System.out.println("Java SPI"); serviceLoader.forEach(Robot::sayHello); &#125;&#125; 最后来看一下测试结果，从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。 DriverManager SPIDriverManager 是JDBC里管理和注册不同数据库driver的工具类。针对一个数据库 可能会存在着不同的数据库驱动实现，我们在使用特定的驱动实现时不希望修改现有的代码才能达到目的，而希望通过一个简单的配置就可以达到效果。比如，我们现在有一个数据库的驱动A，我们希望在程序里使用它而不修改代码。一种理想的选择就是我们将驱动A的信息加入到一个配置文件中，程序通过读取配置文件信息将A加载进来。而以后如果我们希望改用另外一个驱动B的时候，我们只需要将配置文件里的信息修改成驱动B即可。 我们在运用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;)加载mysql驱动后，就会执行其中的静态代码把driver注册到DriverManager中，以便后续的使用。代码如下： 1234567891011121314package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;&#125; 这里可以看到，不同的驱动实现了相同的接口java.sql.Driver，然后通过registerDriver把当前driver加载到DriverManager中这就体现了使用方提供规则，提供方根据规则把自己加载到使用方中的SPI思想。查看DriverManager的源码，可以看到其内部的静态代码块中有一个loadInitialDrivers方法，在注释中我们看到用到了上文提到的SPI工具类ServiceLoader。 12345678/*** Load the initial JDBC drivers by checking the System property* jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism*/static &#123; loadInitialDrivers(); println("JDBC DriverManager initialized");&#125; 点进方法，看到方法里有如下代码： 123ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);Iterator&lt;Driver&gt; drivers = loadedDrivers.iterator();println("DriverManager.initialize: jdbc.drivers = " + loadedDrivers); 可见，DriverManager初始化时也运用了SPI机制，使用ServiceLoader把写到配置文件里的Driver都加载了进来。我们打开mysql-connector-java的jar包，果然在META-INF/services下发现了上文中提到的接口路径，打开里面的内容，可以看到是com.mysql.jdbc.Driver。 Dubbo SPISPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo路径下，配置内容如下。 12optimusPrime = org.apache.spi.OptimusPrimebumblebee = org.apache.spi.Bumblebee 与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注@SPI注解。下面来演示 Dubbo SPI 的用法： 123456789101112public class DubboSPITest &#123; @Test public void sayHello() throws Exception &#123; ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class); Robot optimusPrime = extensionLoader.getExtension("optimusPrime"); optimusPrime.sayHello(); Robot bumblebee = extensionLoader.getExtension("bumblebee"); bumblebee.sayHello(); &#125;&#125; 测试结果如下： 总结本篇文章简单分别介绍了SPI机制的概念，以及Java SPI ，DriverManager SPI 与 Dubbo SPI 用法。 参考 Java SPI思想梳理 Dubbo SPI 设计原则：小议 SPI 和 API]]></content>
  </entry>
</search>
