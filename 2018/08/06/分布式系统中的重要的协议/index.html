<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>分布式系统中的重要的协议 | Zer0ing&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="分布式存储," />
  

  <meta name="description" content="分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。 1.两阶段提交协议两阶段提交协议（Two-phase Commit,2PC）通常用来实现分布式事务。在该协议中，系统包含两类节点：一类为协调者，通常只有一个，另一类为事务参与者，一般">
<meta name="keywords" content="分布式存储">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式系统中的重要的协议">
<meta property="og:url" content="http://yoursite.com/2018/08/06/分布式系统中的重要的协议/index.html">
<meta property="og:site_name" content="Zer0ing&#39;s Blog">
<meta property="og:description" content="分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。 1.两阶段提交协议两阶段提交协议（Two-phase Commit,2PC）通常用来实现分布式事务。在该协议中，系统包含两类节点：一类为协调者，通常只有一个，另一类为事务参与者，一般">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-08-07T07:27:39.360Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分布式系统中的重要的协议">
<meta name="twitter:description" content="分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。 1.两阶段提交协议两阶段提交协议（Two-phase Commit,2PC）通常用来实现分布式事务。在该协议中，系统包含两类节点：一类为协调者，通常只有一个，另一类为事务参与者，一般">

  

  
    <link rel="icon" href="/icon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">主页</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">主页</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两阶段提交协议"><span class="toc-text">1.两阶段提交协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-三阶段提交协议"><span class="toc-text">2. 三阶段提交协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Paxos协议"><span class="toc-text">3.Paxos协议</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-分布式系统中的重要的协议" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">分布式系统中的重要的协议</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.08.06</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>zer0ing</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>分布式系统中有两个重要协议，包括Paxos选举协议以及两阶段提交协议。Paxos协议用于多个节点之间达成一致，往往用于总控节点的选举。两阶段提交协议用于保证跨多个节点操作的原子性，这些操作要么全部成功，要么全部失败。</p>
<h2 id="1-两阶段提交协议"><a href="#1-两阶段提交协议" class="headerlink" title="1.两阶段提交协议"></a>1.两阶段提交协议</h2><p>两阶段提交协议（Two-phase Commit,2PC）通常用来实现分布式事务。在该协议中，系统包含两类节点：一类为协调者，通常只有一个，另一类为事务参与者，一般包含多个。</p>
<p>在正常的执行过程中，两阶段提交协议包含以下两个过程：</p>
<p>阶段1：请求阶段。在请求阶段，协调者通知事务参与者准备提交或者取消事务，然后进入表决过程。在表决过程中，参与者告知协调者自己的决策：同意（事务本地执行成功）或者取消（事务本地执行失败）。</p>
<p>阶段2：提交阶段。在提交阶段，协调者基于第一阶段的投票结果进行决策：提交或者取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则通知所有参与者取消事务。参与者在接收到协调者的消息后执行相应操作。</p>
<p>二阶段提交协议看起来确实能够提供原子性的操作，但还是存在几个缺点：</p>
<ol>
<li><p>同步阻塞问题。执行过程中，所有参与者都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
</li>
<li><p>单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题。）</p>
</li>
<li><p>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p>
</li>
<li><p>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
</li>
</ol>
<p>上述协议存在问题，在请求阶段，如果某一参与者迟迟不能回复，系统将一直处于等待状态，并且其他参与者持有的资源不能得到释放。不过协调者可以通过引入事务的超时机制防止资源一直不能得到释放的情况。但是若协调者出现故障，事务将被阻塞。故两阶段提交协议可能面临两种故障：</p>
<ol>
<li><p>事务参与者发生故障。给每个事务设置超时时间，若参与者不能及时响应，整个事务失败。</p>
</li>
<li><p>协调者发生故障。协调者需要将事务相关信息记录到操作日志并同步到备用协调者，假如协调者发生故障，备用协调者可以接替完成后续工作。</p>
</li>
</ol>
<p>总之，两阶段提交协议是阻塞协议，协议过程中需要锁住其它更新，且不能容错，并不适合高并发系统，大多数分布式系统都不采用，放弃对分布式事务的支持。</p>
<h2 id="2-三阶段提交协议"><a href="#2-三阶段提交协议" class="headerlink" title="2. 三阶段提交协议"></a>2. 三阶段提交协议</h2><p>三阶段提交协议（Three-phase Commit，3PC）是对二阶段提交协议的改进，改动点如下：</p>
<ol>
<li><p>引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
</li>
<li><p>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。即3PC把2PC的准备阶段一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p>
</li>
</ol>
<p>在DoCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</p>
<p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</p>
<p><a href="http://blog.jobbole.com/89140/" target="_blank" rel="noopener">使用消息队列来避免分布式事务</a></p>
<h2 id="3-Paxos协议"><a href="#3-Paxos协议" class="headerlink" title="3.Paxos协议"></a>3.Paxos协议</h2><p>Paxos协议用于解决多个节点之间的一致性问题。多个节点通过操作日志同步数据，如果只有一个节点为主节点，很容易确保多个节点之间操作日志的一致性。考虑主节点可能发生故障，系统需要选举新的主节点。Paxos协议正是用来实现此需求。只要保证多个节点之间操作日志的一致性，就能在这些节点上构建高可用的全局服务，例如分布式锁服务，全局命名和配置服务等。</p>
<p>为了实现高可用性，主节点把数据以操作日志的形式同步到备节点。若主节点发生故障，备节点会提议自己成为主节点。存在的一个问题是网络分区的时候，可能会存在多个备节点（Proposer,提议者）提议。Paxos协议保证，即使存在多个提议者，也能保证所有节点最终达成一致，即选举出唯一的主节点。</p>
<p>大多数情况下，系统只有一个提议节点，提议会很快被大多数节点接受。Paxos协议执行步骤如下：</p>
<ol>
<li><p>批准（accept）：提议者发送accept消息要求其他所有节点接受某个提议值，其它节点可以接受或者拒绝。</p>
</li>
<li><p>确认（acknowledge）：如果超过一半的其它节点接受，意味着提议值生效，提议者发送确认消息通知所有的节点提议生效。</p>
</li>
</ol>
<p>当网络或者其他异常时，系统中可能存在多个提议者，各自发起不同的提议。这里的提议可以是一个修改，也可以是自己成为主节点。如果提议者第一次发起的accept请求没有被其它节点的多数派批准，那么需要完整地执行一轮Paxos协议。过程如下:</p>
<ol>
<li><p>准备（prepare）：Proposer首先选择一个提议序号n给其他的acceptor节点发送prepare消息。Acceptor收到prepare消息后，如果提议的序号大于其已经回复的所有prepare消息，则acceptor将自己上次接受的提议回复给proposer，并承诺不再回复小于n的提议。</p>
</li>
<li><p>批准（accept）：Proposer收到了acceptor中的多数派对prepare的回复后，就进入批准阶段。如果在之前的prepare阶段acceptor回复了上次接受的提议，那么proposer选择其中序号最大的提议值发给acceptor批准；否则，proposer生成一个新的提议值发给acceptor批准。Acceptor在不违背他之前在prepare阶段的承诺的前提下，接受这个请求。</p>
</li>
<li><p>确认（acknowledge）：如果超过一半的acceptor接受，提议值生效。Proposer发送knowledge消息通知所有的acceptor提议生效。</p>
</li>
</ol>
<p>Paxos协议需要考虑两个问题：正确性，即只有一个提议值生效；可终止性，即最后总有一个提议值生效。</p>
<p><strong>参考</strong>：</p>
<ol>
<li>杨传辉，《大规模分布式存储系统：原理解析与架构实战》</li>
<li><a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Paxos算法</a></li>
<li><a href="http://www.hollischuang.com/archives/693" target="_blank" rel="noopener">分布式一致性算法——paxos</a></li>
</ol>

    
  </div>

  
      <div class="git"></div>
  

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/07/26/数据库主键、外键、索引/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="hide pull-right" href="/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
